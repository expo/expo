const TABLE_HEADER = '| Property | Description |\n| --- | --- |';

type AppSchemaProperty = {
  description?: string;
  type?: string | string[];
  tsType?: string;
  enum?: string[];
  example?: any;
  exampleString?: string;
  meta?: {
    regexHuman?: string;
    autogenerated?: boolean;
    bareWorkflow?: string;
    expoKit?: string;
    deprecated?: boolean;
    hidden?: boolean;
  };
  pattern?: string;
  minLength?: number;
  maxLength?: number;
  minimum?: number;
  maximum?: number;
  uniqueItems?: boolean;
  additionalProperties?: boolean;
  properties?: Record<string, AppSchemaProperty>;
  items?: {
    type?: string | string[];
    enum?: string[];
    properties?: Record<string, AppSchemaProperty>;
  };
  oneOf?: any[];
};

export async function generateAppConfigSchemaMarkdownAsync(schemaImportPath: string) {
  const schema = await loadAppConfigSchemaAsync(schemaImportPath);
  if (!schema) {
    return '';
  }

  const rows: string[] = [];
  Object.entries(schema).forEach(([name, property]) => {
    appendPropertyMarkdown(rows, name, property, '', 0);
  });

  if (rows.length === 0) {
    return '';
  }

  return `${TABLE_HEADER}\n${rows.join('\n')}`;
}

async function loadAppConfigSchemaAsync(importPath: string) {
  const relativePath = importPath.replace(/^~\/public/, '');
  const url = relativePath.startsWith('/') ? relativePath : `/${relativePath}`;

  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch schema from ${url}`);
    }
    return (await response.json()) as Record<string, AppSchemaProperty>;
  } catch (error) {
    console.error('Unable to load app config schema for Markdown conversion:', error);
    return null;
  }
}

function appendPropertyMarkdown(
  rows: string[],
  name: string,
  property: AppSchemaProperty,
  parentPath: string,
  level: number
) {
  if (property.meta?.hidden || property.meta?.deprecated) {
    return;
  }

  const fullName = parentPath ? `${parentPath}.${name}` : name;
  const indent = level === 0 ? '' : '&nbsp;'.repeat(level * 4) + 'â€¢ ';
  const nameCell = `${indent}\`${fullName}\``;
  const description = formatDescription(property, fullName, level);

  rows.push(`| ${escapeMarkdownCell(nameCell)} | ${escapeMarkdownCell(description)} |`);

  if (property.properties) {
    Object.entries(property.properties).forEach(([childName, childProperty]) => {
      appendPropertyMarkdown(rows, childName, childProperty, fullName, level + 1);
    });
  }

  if (property.items?.properties) {
    Object.entries(property.items.properties).forEach(([childName, childProperty]) => {
      appendPropertyMarkdown(rows, childName, childProperty, `${fullName}[]`, level + 1);
    });
  }
}

function formatDescription(property: AppSchemaProperty, fullName: string, level: number) {
  const parts: string[] = [];
  const type = getTypeString(property);
  if (type) {
    parts.push(`**(${type})**`);
  }

  if (property.description) {
    parts.push(property.description);
  }

  if (property.meta?.regexHuman) {
    parts.push(property.meta.regexHuman);
  }

  if (property.meta?.bareWorkflow) {
    parts.push(`Bare workflow: ${property.meta.bareWorkflow}`);
  }

  if (property.meta?.expoKit) {
    parts.push(`ExpoKit: ${property.meta.expoKit}`);
  }

  if (property.meta?.autogenerated) {
    parts.push('This value is autogenerated.');
  }

  if (property.pattern) {
    parts.push(`Pattern: \`${property.pattern}\``);
  }

  if (property.minLength !== undefined) {
    parts.push(`Minimum length: ${property.minLength}`);
  }

  if (property.maxLength !== undefined) {
    parts.push(`Maximum length: ${property.maxLength}`);
  }

  if (property.minimum !== undefined) {
    parts.push(`Minimum value: ${property.minimum}`);
  }

  if (property.maximum !== undefined) {
    parts.push(`Maximum value: ${property.maximum}`);
  }

  if (property.uniqueItems) {
    parts.push('Array items must be unique.');
  }

  if (property.additionalProperties === false) {
    parts.push('Additional properties are not allowed.');
  }

  if (property.enum?.length) {
    parts.push(`Allowed values: ${property.enum.map(value => `\`${value}\``).join(', ')}`);
  }

  if (property.oneOf?.length) {
    parts.push(formatOneOf(property.oneOf));
  }

  if (property.items && !property.items.properties) {
    const itemType = getItemTypeString(property.items);
    if (itemType) {
      parts.push(`Array items type: ${itemType}`);
    }
  }

  if (property.exampleString) {
    parts.push(`Example: \`${escapeBackticks(property.exampleString)}\``);
  }

  if (property.example !== undefined) {
    parts.push(formatExample(property.example));
  }

  if (level > 0) {
    parts.push(`Path: \`${fullName}\``);
  }

  return parts.join('<br><br>');
}

function getTypeString(property: AppSchemaProperty) {
  if (property.enum?.length) {
    return 'enum';
  }

  if (property.type) {
    return Array.isArray(property.type) ? property.type.join(' || ') : property.type;
  }

  if (property.tsType) {
    return property.tsType;
  }

  if (property.oneOf?.length) {
    return 'one of';
  }

  if (property.items?.type) {
    const itemType = Array.isArray(property.items.type)
      ? property.items.type.join(' || ')
      : property.items.type;
    return `array<${itemType}>`;
  }

  return '';
}

function getItemTypeString(items: NonNullable<AppSchemaProperty['items']>) {
  if (items.enum?.length) {
    return `enum: ${items.enum.join(', ')}`;
  }

  if (items.type) {
    return Array.isArray(items.type) ? items.type.join(' || ') : items.type;
  }

  return '';
}

function formatExample(example: any) {
  if (typeof example === 'string' || typeof example === 'number' || typeof example === 'boolean') {
    return `Example: \`${escapeBackticks(String(example))}\``;
  }

  try {
    const json = JSON.stringify(example, null, 2);
    const escaped = escapeHtml(json);
    const formatted = escaped.replace(/\n/g, '<br>').replace(/\s/g, '&nbsp;');
    return `Example:<br><code>${formatted}</code>`;
  } catch {
    return `Example: \`${escapeBackticks(String(example))}\``;
  }
}

function formatOneOf(options: any[]) {
  const formatted = options
    .map(option => {
      const json = JSON.stringify(option, null, 2);
      const escaped = escapeHtml(json);
      const formattedOption = escaped.replace(/\n/g, '<br>').replace(/\s/g, '&nbsp;');
      return `<code>${formattedOption}</code>`;
    })
    .join('<br>');

  return `One of:<br>${formatted}`;
}

function escapeMarkdownCell(value: string) {
  return value.replace(/\|/g, '\\|').replace(/\r?\n/g, '<br>');
}

function escapeHtml(value: string) {
  return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function escapeBackticks(value: string) {
  return value.replace(/`/g, '\\`');
}
