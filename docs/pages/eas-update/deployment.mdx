---
title: Deploy updates
sidebar_title: Deploy updates
description: Learn a simple but powerful process for safely deploying updates to your users.
---

import { Collapsible } from '~/ui/components/Collapsible';

When you have an app with multiple binary versions in production (this is common, users do not always stay up to date with your latest store release), it's important to be able to reason about what code is running on which versions, and to be able to specifically target to a specific version with a hotfix.

In order to determine which app version to target, to help you with bookkeeping to understand the state of your deployments, and to support a variety of [deployment patterns](/eas-update/deployment-patterns/), EAS Update provides "channels", "branches", and "runtime versions".

<Collapsible summary="What if my preferred release process isn't supported by EAS Update?">

Release management is a large topic in software engineering, and the only thing that can be definitvely said about it is that everyone has slightly different takes on how they would like to do it. EAS Update is designed to support [a variety of different workflows](/eas-update/deployment-patterns/), but this guide will focus on the simplest workflow that works for most apps. That said, there are some other workflows that may not work within the constraints of the EAS Update service. For example, each binary version must always point to a single channel, and you cannot dynamically update the channel.

As an escape hatch, you can host your own update service that is compatible with the [Expo Updates Protocol](/technical-specs/expo-updates-1/), and point your expo-updates configuration to that service instead. The only concepts relevant to update selection that exist on the protocol level are and "Runtime Version" and "Platform", and you are free to create your own concepts on top of those, in the same way that we built channels and branches. [Learn more about creating a custom expo-updates server](https://github.com/expo/custom-expo-updates-server).

</Collapsible>

## A simple release process

In this guide we'll describe a simple but powerful release process that uses **channels** and **runtime versions** and mostly ignores _branches_. This gives most of the benefits of EAS Update with a minimal amount of conceptual overhead. You can evolve this process to suit your needs as they arise, or move to [other deployment patterns](/eas-update/deployment-patterns/) entirely.

<Collapsible summary="Why ignore branches in this release process?">

The most simple way to use EAS Update is to ignore the concept of "branches" and to focus instead on "channels". Branches will still exist, but you will not have to interact with them directly to manage deployments. You can keep your channels pointed at a branch with the same name as the channel and think of them as a singlular concept.

EAS Update branches were meant to map to Git branches, to enable teams to publish changes from a Git branch directly to an EAS Update branch of the same name. This can be helpful for [previewing updates](/eas-update/develop-faster/), but for many apps, this level of integration with Git is not required. Often, developers are only interested in being able to release hotfixes to a staging or production version of their app manually, and can run `eas update --channel staging` or `eas update --channel production` when needed rather than managing branches to accomplish the same result.

</Collapsible>

## Configuring your project

We'll only need to think about channels and runtime versions with this release process. Channels will indicate which environment the update targets (such as "production" or "staging"), and runtime versions will indicate the app version that the update will target (such as "1.0.0" or "1.0.1").

### Channel configuration

Run `eas update:configure` in your project if you haven't already.

**If you use EAS Build**, the default configuration that will be applied by the configure command will be almost exactly what we want to use here: each profile will point to a channel of the same name, so our production release of our app will point to the "production" channel. We only need to add a "staging" profile that points to the "staging" channel.

<Collapsible summary="Example eas.json configuration">

The following configuration is approximately what `eas update:configure` will generate for you if you haven't already configured your project.

```json
{
  "build": {
    "production": {
      "channel": "production"
    },
    "staging": {
      "channel": "staging"
    },
    "preview": {
      "channel": "preview",
      "distribution": "internal"
    }
  }
}
```

</Collapsible>

**If you do not use EAS Build**, you will need to modify the channel used in your [native project configuration](/eas-update/updating-your-app/#configuring-the-channel-manually). When you release to production, ensure you update the channel name in native config to "production", and when you release to staging, ensure you update the channel name in native config to "preview". It's worth noting that using EAS Build with EAS Update helps you get the best out of the product, but it is not required.

### Runtime version configuration

By default, `eas update:configure` will set `"runtimeVersion": { "policy": "appVersion" }` in your app config. This is the recommended configuration, it will ensure that the runtime version of your app is always the same as the app version, and you have a unique runtime version to target for every release of your app. The app version in this case refers to the native version of your app that users will see on the app store, and it does not include the build number or version code. For example: `"1.0.0"` will be used as the runtime version, and not `"1.0.0(1)"` (where `1` is the build number or version code).

<Collapsible summary="Example app.json configuration">

```json
{
  "expo": {
    "runtimeVersion": {
      "policy": "appVersion"
    }
  }
}
```

</Collapsible>

<Collapsible summary="What about the fingerprint runtime version policy?">

We hope that this will be the future of runtime version policies, but for now, we recommend using the `"appVersion"` policy. The `"fingerprint"` policy is not yet widely recommended because it is still experimental.

</Collapsible>

## Deploying to previews

You can preview updates in your internal distribution release builds or in development builds. Using internal distribution instead of deploying to a store beta track reduces the friction of distributing the app to internal testers, and is suitable for cases where you want to, for example, share a build on every pull request or an early concept that you're working on.

### Internal distribution release builds

As explained above, preview builds will point to the "preview" channel. If you want to have multiple versions of the preview app distributed internally at any given time, you may want to change the channel name based on the feature name. For example, you might set your channel on your build to "preview-feature-a" when working on feature A, and then set it to "preview-feature-b" when working on feature B.

### Preview in development builds

Development builds can load updates from any channel, provided the runtime version is compatible. Learn more about this in [Previewing updates](/eas-update/develop-faster/).

## Deploying to staging

Run `eas update --channel staging` to publish an update to staging. This will make your hotfix immediately available to users of staging builds with the targeted runtime version.

Your staging environment will be Google Play Beta or TestFlight - the "beta track" on respective app stores. You may alternatively use internal distribution, but deploying to a store beta track is generally recommended when you are staging code for a production release since users are able to access it without any knowledge of internal processes for distributing the app (while using internal distribution would require users to download the app from an expo.dev URL).

A common practice for creating staging builds is to always create one whenever you upload a production build to a store. This allows you to have a staging build with an identical runtime to the production build, which you can use to test your updates before rolling them out to production. With EAS Build, this means running `eas build --profile staging --auto-submit` every time you run `eas build --profile production --auto-submit`.

## Deploying to production

When creating a new production build, increment your app version every time in order to ensure it has a unique runtime version.

Run `eas update --channel production` to publish an update to production. This will make your hotfix immediately available to users of production builds with the same runtime version.

If you have already published the fix to staging and verified it there, you can use `eas update:republish` to promote the update to production.

### Gradually rolling out updates

Rollouts that leverage multiple branches can't be used with this workflow. Instead, you can roll out updates on a single branch.

{/* depends on new feature */}
To roll out the upgrade gradually, run: `......`

Learn more in [Rollouts](/eas-update/rollouts/).

### Rolling back to a previous update version

Learn more in [Rollbacks](/eas-update/rollbacks/).

## Next steps

- [Learn more about the Persistent staging release process](/eas-update/deployment-patterns/#persistent-staging-flow), which is very similar to what is described here.