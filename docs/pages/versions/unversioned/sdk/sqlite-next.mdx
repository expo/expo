---
title: SQLite (Next)
description: A library that provides access to a database that can be queried through a SQLite API.
sourceCodeUrl: 'https://github.com/expo/expo/tree/main/packages/expo-sqlite'
packageName: 'expo-sqlite'
maxHeadingDepth: 3
---

import APISection from '~/components/plugins/APISection';
import { APIInstallSection } from '~/components/plugins/InstallSection';
import PlatformsSection from '~/components/plugins/PlatformsSection';
import { Terminal } from '~/ui/components/Snippet';
import { Step } from '~/ui/components/Step';

`expo-sqlite` gives your app access to a database that can be queried through a SQLite API. The database is persisted across restarts of your app.

<PlatformsSection android emulator ios simulator />

## Installation

<APIInstallSection />

## Usage

### Basic CRUD operations

```js
const db = await SQLite.openDatabaseAsync('databaseName');

// `execAsync` is useful for bulk queries when you want to execute alltogether.
// Please note that `execAsync` does not escape parameters and may lead to SQL injection.
await db.execAsync(`
PRAGMA journal_mode = WAL;
CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY NOT NULL, value TEXT NOT NULL, intValue INTEGER);
INSERT INTO test (value, intValue) VALUES ('test1', 123);
INSERT INTO test (value, intValue) VALUES ('test2', 456);
INSERT INTO test (value, intValue) VALUES ('test3', 789);
`);

// `runAsync` is useful when you want to execute some write operations.
const result = await db.runAsync('INSERT INTO test (value, intValue) VALUES (?, ?)', 'aaa', 100);
console.log(result.lastInsertRowId, result.changes);
await db.runAsync('UPDATE test SET intValue = ? WHERE value = ?', 999, 'aaa'); // Binding unnamed parameters from variadic arguments
await db.runAsync('UPDATE test SET intValue = ? WHERE value = ?', [999, 'aaa']); // Binding unnamed parameters from array
await db.runAsync('DELETE FROM test WHERE value = $value', { $value: 'aaa' }); // Binding named parameters from object

// Prepare statement allows you compile your SQL query once and execute it multiple times with different parameters.
const statement = await db.prepareAsync(
  'INSERT INTO test (value, intValue) VALUES ($value, $intValue)'
);
try {
  await statement.runAsync({ $value: 'bbb', $intValue: 101 });
  await statement.runAsync({ $value: 'ccc', $intValue: 102 });
  await statement.runAsync({ $value: 'ddd', $intValue: 103 });
} finally {
  // Best practice to finalize the statement with try-finally
  await statement.finalizeAsync();
}

// `getAsync` is useful when you want to get a single row from the database.
const oneRow = await db.getAsync('SELECT * FROM test');
console.log(oneRow.id, oneRow.value, oneRow.intValue);

// `allAsync` is useful when you want to get all results as an array of objects.
const allRows = await db.allAsync('SELECT * FROM test');
for (const row of allRows) {
  console.log(row.id, row.value, row.intValue);
}

// `eachAsync` is useful when you want to iterate SQLite query cursor.
for await (const row of db.eachAsync('SELECT * FROM test')) {
  console.log(row.id, row.value, row.intValue);
}
```

### `useSQLiteContext()` hook

```tsx
import { SQLiteProvider, useSQLiteContext, type SQLiteDatabase } from 'expo-sqlite/next';
import { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <SQLiteProvider databaseName="test.db" onInit={migrateDbIfNeeded}>
        <Header />
        <Content />
      </SQLiteProvider>
    </View>
  );
}

export function Header() {
  const db = useSQLiteContext();
  const [version, setVersion] = useState('');
  useEffect(() => {
    async function setup() {
      const result = await db.getAsync<{ 'sqlite_version()': string }>('SELECT sqlite_version()');
      setVersion(result['sqlite_version()']);
    }
    setup();
  }, []);
  return (
    <View style={styles.headerContainer}>
      <Text style={styles.headerText}>SQLite version: {version}</Text>
    </View>
  );
}

interface Todo {
  value: string;
  intValue: number;
}

export function Content() {
  const db = useSQLiteContext();
  const [todos, setTodos] = useState<Todo[]>([]);

  useEffect(() => {
    async function setup() {
      const result = await db.allAsync<Todo>('SELECT * FROM todos');
      setTodos(result);
    }
    setup();
  }, []);

  return (
    <View style={styles.contentContainer}>
      {todos.map((todo, index) => (
        <View style={styles.todoItemContainer} key={index}>
          <Text>{`${todo.intValue} - ${todo.value}`}</Text>
        </View>
      ))}
    </View>
  );
}

async function migrateDbIfNeeded(db: SQLiteDatabase) {
  const DATABASE_VERSION = 1;
  let { user_version: currentDbVersion } = await db.getAsync<{ user_version: number }>(
    'PRAGMA user_version'
  );
  if (currentDbVersion >= DATABASE_VERSION) {
    return;
  }
  if (currentDbVersion === 0) {
    await db.execAsync(`
PRAGMA journal_mode = 'wal';
CREATE TABLE todos (id INTEGER PRIMARY KEY NOT NULL, value TEXT NOT NULL, intValue INTEGER);
`);
    await db.runAsync('INSERT INTO todos (value, intValue) VALUES (?, ?)', 'hello', 1);
    await db.runAsync('INSERT INTO todos (value, intValue) VALUES (?, ?)', 'world', 2);
    currentDbVersion = 1;
  }
  // if (currentDbVersion === 1) {
  //   Add more migrations
  // }
  await db.execAsync(`PRAGMA user_version = ${DATABASE_VERSION}`);
}

const styles = StyleSheet.create({
  // Your styles...
});
```

### `useSQLiteContext()` hook with `React.Suspense`

As with the [`useSQLiteContext()` hook](#usesqlitecontext-hook), you can also integrate the `SQLiteProvider` with [`React.Suspense`](https://react.dev/reference/react/Suspense) to show a fallback component until the database is ready.
To enable the integration, you need to pass the `useSuspense` prop to the `SQLiteProvider` component.

```tsx
import { SQLiteProvider, useSQLiteContext } from 'expo-sqlite/next';
import { Suspense } from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Suspense fallback={<Fallback />}>
        <SQLiteProvider databaseName="test.db" onInit={migrateDbIfNeeded} useSuspense>
          <Header />
          <Content />
        </SQLiteProvider>
      </Suspense>
    </View>
  );
}
```

### Executing queries within an async transaction

```js
const db = await SQLite.openDatabaseAsync('databaseName');

await db.withTransactionAsync(async () => {
  const result = await db.getAsync('SELECT COUNT(*) FROM USERS');
  console.log('Count:', result.rows[0]['COUNT(*)']);
});
```

> **Note:** Due to the nature of the async/await, we can't ensure that the transaction will be executed in the same order as the statements are written. A query out of a transaction may be executed inside the transaction. For example, the following test case may fail from out of order async/await statements. If you care about the order of execution, use the [`withTransactionExclusiveAsync`](#withtransactionexclusiveasynctask) function.
> ```tsx
> db.withTransactionAsync(async () => {
>   await db.execAsync('UPDATE test SET name = "aaa"');
>
>   //
>   // We cannot control the order of async/await order, so order of execution is not guaranteed.
>   // The following UPDATE query out of transaction may be executed here and break the expectation.
>   //
>
>   const result = await db.getAsync<{ name: string }>('SELECT name FROM Users');
>   expect(result?.name).toBe('aaa');
> });
> db.execAsync('UPDATE test SET name = "bbb"');
> ```

### Executing PRAGMA queries

```js
const db = await SQLite.openDatabaseAsync('databaseName');
await db.execAsync('PRAGMA journal_mode = WAL');
await db.execAsync('PRAGMA foreign_keys = ON');
```

> **info** **Tip:** Enable [WAL journal mode](https://www.sqlite.org/wal.html) when you create a new database to improve performance in general.

### Import an existing database

To open a new SQLite database using an existing **.db** file you already have, follow the steps below:

<Step label="1">
Install `expo-file-system` and `expo-asset` libraries:

<Terminal cmd={['$ npx expo install expo-file-system expo-asset']} />

</Step>

<Step label="2">
Create a **metro.config.js** file at the root of your project with the following contents to include [extra asset extensions](/guides/customizing-metro/#adding-more-file-extensions-to--assetexts):

```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');

const defaultConfig = getDefaultConfig(__dirname);

defaultConfig.resolver.assetExts.push('db');

module.exports = defaultConfig;
```

</Step>

<Step label="3">

Use the following function (or similar) to open your database:

```ts
async function openDatabase(pathToDatabaseFile: string): Promise<SQLite.Database> {
  if (!(await FileSystem.getInfoAsync(FileSystem.documentDirectory + 'SQLite')).exists) {
    await FileSystem.makeDirectoryAsync(FileSystem.documentDirectory + 'SQLite');
  }
  await FileSystem.downloadAsync(
    Asset.fromModule(require(pathToDatabaseFile)).uri,
    FileSystem.documentDirectory + 'SQLite/myDatabaseName.db'
  );
  return await SQLite.openDatabaseAsync('myDatabaseName.db');
}
```

</Step>

### Passing binary data

Use `Uint8Array` to pass binary data to the database:

```ts Passing binary data
await db.execAsync(`
DROP TABLE IF EXISTS Blobs;
CREATE TABLE IF NOT EXISTS Blobs (id INTEGER PRIMARY KEY NOT NULL, data BLOB);
`);

const blob = new Uint8Array([0x00, 0x01, 0x02, 0x03, 0x04, 0x05]);
await db.runAsync('INSERT INTO Blobs (data) VALUES (?)', blob);

const row = await db.getAsync<{ data: Uint8Array }>('SELECT * FROM Blobs');
expect(row.data).toEqual(blob);
```

## API

### Cheatsheet for the common API

We offer a few common API for both the [`SQLiteDatabase`](#sqlitedatabase) and [`SQLiteStatement`](#sqlitestatement) classes. The following table summarizes the common API:

| Method                                 | Description                                                                                                                                                       | Use Case                                                                                                                                                                                  |
| -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`runAsync`](#runasyncsource-params)   | Executes a SQL query, returning information on the changes made.                                                                                                  | Ideal for SQL write operations such as `INSERT`, `UPDATE`, `DELETE`.                                                                                                                      |
| [`getAsync`](#getasyncsource-params)   | Retrieves the first row from the query result.                                                                                                                    | Suitable for fetching a single row from the database, for example: `getAsync('SELECT * FROM Users WHERE id = ?', userId)`.                                                                |
| [`allAsync`](#allasyncsource-params)   | Fetches all query results at once.                                                                                                                                | Best suited for scenarios with smaller result sets, such as queries with a LIMIT clause, like SELECT \* FROM Table LIMIT 100, where you intend to retrieve all results in a single batch. |
| [`eachAsync`](#eachasyncsource-params) | Provides an iterator for result set traversal. This method fetches one row at a time from the database, potentially reducing memory usage compared to `allAsync`. | Recommended for handling large result sets incrementally, such as with infinite scrolling implementations.                                                                                |

<APISection packageName="expo-sqlite-next" apiName="SQLite" exposeAllClassPropsInSidebar={true} />
