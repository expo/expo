---
title: Cache dependencies
description: Learn how to speed up your builds by caching dependencies.
---

Before a build job can begin compiling your project, all project dependencies need to be available on disk. The longer it takes to acquire the dependencies, the more you need to wait for your build to complete &mdash; so caching dependencies is an important part of speeding up your builds.

> We're actively working on improving caching and other aspects of the build process to make builds reliably fast.

## Custom caching

The `cache` field on build profiles in [eas.json](/build/eas-json) can be used to configure caching for specific files and directories. Specified files will be saved to persistent storage after a successful build and restored on subsequent builds after the JavaScript dependencies are installed. Restoring does not overwrite existing files. Changing the `cache.key` value will invalidate the cache. Changing any other property of the `cache` object will also invalidate the cache.

## JavaScript dependencies

EAS Build runs an npm cache server that can speed up downloading JavaScript dependencies for your build jobs. By default, projects using npm or Yarn 2+ will use the cache. However, Yarn 1 (Classic) requires that you apply this [workaround](/build-reference/npm-cache-with-yarn) to use the cache in your project's **package.json**.

To disable using our npm cache server for your builds set the `EAS_BUILD_DISABLE_NPM_CACHE` env variable value to `"1"` in **eas.json**.

{/* prettier-ignore */}
```json eas.json
{
  "build": {
    "production": {
      "env": {
        "EAS_BUILD_DISABLE_NPM_CACHE": "1"
        /* @hide ... */ /* @end */
      }
      /* @hide ... */ /* @end */
    }
    /* @hide ... */ /* @end */
  }
  /* @hide ... */ /* @end */
}
```

### Immutable lockfiles

By default, Node packages will be installed with your preferred package manager's immutable lockfile flag/command (for example, `yarn --frozen-lockfile` or `npm ci`). If you would like to disable this, you can set the `EAS_NO_FROZEN_LOCKFILE` environment variable to `"1"` in **eas.json**.

## Android dependencies

EAS Build runs a Maven cache server that can speed up downloading Android dependencies for your build jobs.

Currently, we are caching:

- `maven-central` - [https://repo1.maven.org/maven2/](https://repo1.maven.org/maven2/)
- `google` - [https://maven.google.com/](https://maven.google.com/)
- `jcenter` - [https://jcenter.bintray.com/](https://jcenter.bintray.com/)
- `plugins` - [https://plugins.gradle.org/m2/](https://plugins.gradle.org/m2/)

To disable using our Maven cache server for your builds set the `EAS_BUILD_DISABLE_MAVEN_CACHE` env variable value to `"1"` in **eas.json**.

{/* prettier-ignore */}
```json eas.json
{
  "build": {
    "production": {
      "env": {
        "EAS_BUILD_DISABLE_MAVEN_CACHE": "1"
        /* @hide ... */ /* @end */
      }
      /* @hide ... */ /* @end */
    }
    /* @hide ... */ /* @end */
  }
  /* @hide ... */ /* @end */
}
```

### Caching C/C++ compilation artifacts with ccache

[ccache](https://ccache.dev/) is a compiler cache that speeds up recompilation by caching previous compilations. You can use remote caching to share ccache data across builds, which significantly speeds up builds that include results for native libraries used by React Native, Hermes, or other native modules.

You can configure builds to save and restore ccache automatically with these environment variables:

- `EAS_USE_CACHE`: Enables saving and restoring cache on build jobs. By setting to `1`, it will enable both saving and restoring the cache during a build job. By setting to `0`, it will disable both saving and restoring the cache
- `EAS_RESTORE_CACHE`: Controls restoring the cache at the beginning of a build. Set to `1` to enable or `0` to disable.
- `EAS_SAVE_CACHE`: Controls whether to save the build cache at the end of a build. Set to `1` to enable or `0` to disable.

#### Custom builds

For custom builds, use [`eas/restore_build_cache`](/custom-builds/schema/#easrestore_build_cache) and [`eas/save_build_cache`](/custom-builds/schema/#eassave_build_cache) to cache the ccache directory.

**Android example:**

```yaml .eas/build/config.yml
build:
  name: Android build with ccache
  steps:
    - eas/checkout
    - eas/install_node_modules
    - eas/prebuild
    - eas/restore_build_cache:
        inputs:
          key: android-ccache-${{ hashFiles('package-lock.json') }}
          restore_keys: android
          path: /home/expo/.cache/ccache
    - eas/inject_android_credentials
    - eas/run_gradle
    - eas/save_build_cache:
        inputs:
          key: android-ccache-${{ hashFiles('package-lock.json') }}
          path: /home/expo/.cache/ccache
```

**iOS example:**

```yaml .eas/build/config.yml
build:
  name: iOS build with ccache
  steps:
    - eas/checkout
    - eas/install_node_modules
    - eas/prebuild
    - eas/restore_build_cache:
        inputs:
          key: ios-ccache-${{ hashFiles('package-lock.json') }}
          restore_keys: ios
          path: /Users/expo/Library/Caches/ccache
    - eas/configure_ios_credentials
    - eas/run_fastlane
    - eas/save_build_cache:
        inputs:
          key: ios-ccache-${{ hashFiles('package-lock.json') }}
          path: /Users/expo/Library/Caches/ccache
```

#### EAS Workflows

For EAS Workflows, use [`eas/restore_cache`](/eas/workflows/syntax/#easrestore_cache) and [`eas/save_cache`](/eas/workflows/syntax/#eassave_cache).

**Android example:**

```yaml .eas/workflows/build-android-custom.yml
jobs:
  build_android:
    steps:
      - uses: eas/checkout
      - uses: eas/install_node_modules
      - uses: eas/prebuild
      - uses: eas/restore_cache
        with:
          key: android-ccache-${{ hashFiles('package-lock.json') }}
          restore_keys: android
          path: /home/expo/.cache/ccache
      - uses: eas/run_gradle
      - uses: eas/save_cache
        with:
          key: android-ccache-${{ hashFiles('package-lock.json') }}
          path: /home/expo/.cache/ccache
```

**iOS example:**

```yaml .eas/workflows/build-ios-custom.yml
jobs:
  build_ios:
    steps:
      - uses: eas/checkout
      - uses: eas/install_node_modules
      - uses: eas/prebuild
      - uses: eas/restore_cache
        with:
          key: ios-ccache-${{ hashFiles('package-lock.json') }}
          restore_keys: ios
          path: /Users/expo/Library/Caches/ccache
      - uses: eas/run_fastlane
      - uses: eas/save_cache
        with:
          key: ios-ccache-${{ hashFiles('package-lock.json') }}
          path: /Users/expo/Library/Caches/ccache
```

The cache key uses `hashFiles('package-lock.json')` to create a unique key based on your dependencies. When dependencies change, a new cache will be created while still allowing fallback to previous caches using `restore_keys`.

### Cache key matching

When restoring a cache, the cache system follows a specific search sequence to find matching cache entries:

1. **Exact match**: First, it searches for an exact match to your provided `key`.
2. **Partial match**: If no exact match is found, it will search for partial matches of the `key` (keys that start with your key as a prefix).
3. **Restore keys**: If there is still no match found, and you've provided `restore_keys`, these keys will be checked sequentially for partial matches.

If there is an exact match to the provided `key`, this is considered a cache hit and the cache is restored immediately. If there is a partial match or a match from `restore_keys`, the cache is restored but this is considered a cache miss, which may trigger additional steps in your workflow.

#### Using restore keys

The restore key `android-ccache-` matches any key that starts with the string `android-ccache-`. For example, both of the keys `android-ccache-fd3052de` and `android-ccache-a9b253ff` match the restore key. The cache with the most recent creation date would be used. The keys in this example are searched in the following order:

1. **`android-ccache-${{ hashFiles('package-lock.json') }}`** matches a specific hash.
2. **`android-ccache-`** matches cache keys prefixed with `android-ccache-`.
3. **`android-`** matches any keys prefixed with `android-`.

### Cache restrictions

Access restrictions provide cache isolation and security by creating logical boundaries between different branches and builds. Understanding these restrictions helps you optimize your cache usage and avoid unexpected cache misses.

#### Branch-based access

Caches are scoped to the branch where they were created. Workflow runs can restore caches created in:

- The current branch
- The default branch (`main` or `master`)

If a workflow run is triggered for a pull request, it can also restore caches created in the base branch. For example, if a pull request from `feature-b` targets `main`, the workflow can access caches created in the `main` branch.

#### User-scoped caches

User-scoped caches allow for publishing caches that are just accessible to builds or workflow jobs that are ran by that respective user. Allowing for isolation so that modifications to the build and its cache are not unintentionally shared during development. This means:

- Caches are shared just between the builds and workflows for an account
- Caches persist across different branches and builds
- Each userâ€™s build will have their own isolated cache even when on the same branch

This ensures that builds between teammates will benefit from remote caching with the guarantee that they are isolated and limited to the proper scope.

#### Default branch cache

If a build doesn't restore a user-scoped cache, it will automatically fallback to restoring caches published from GitHub builds triggered on the default branch. This allows builds to benefit from caches created by automated workflows even when no user-scoped cache exists yet, or to only keep publishing caches from a designated job.

This is particularly useful for build tools like ccache, where the compilation cache can be shared across different builds and branches and the performance benefits can be applied broadly.

## iOS dependencies

EAS Build serves most CocoaPods artifacts from a cache server. This improves the consistency of `pod install` times and generally improves speed. The cache will be bypassed automatically if you provide your own **.netrc** or **.curlrc** files.

To disable using our CocoaPods cache server for your builds set the `EAS_BUILD_DISABLE_COCOAPODS_CACHE` env variable value to `"1"` in **eas.json**.

{/* prettier-ignore */}
```json eas.json
{
  "build": {
    "production": {
      "env": {
        "EAS_BUILD_DISABLE_COCOAPODS_CACHE": "1"
        /* @hide ... */ /* @end */
      }
      /* @hide ... */ /* @end */
    }
    /* @hide ... */ /* @end */
  }
  /* @hide ... */ /* @end */
}
```

It is typical to not have your project **Podfile.lock** committed to source control when using [prebuild](/workflow/prebuild) to generate your **ios** directory [remotely at build time](/build-reference/ios-builds).
It can be useful to cache your **Podfile.lock** to have deterministic builds, but the tradeoff in this case is that, because you don't use the lockfile during local development, your ability to determine when a change is needed and to update specific dependencies is limited.
If you cache this file, you may occasionally end up with build errors that require clearing the cache.
To cache **Podfile.lock**, add **./ios/Podfile.lock** to the `cache.paths` list in your build profile in **eas.json**.

{/* prettier-ignore */}
```json eas.json
{
  "build": {
    "production": {
      "cache": {
        "paths": ["./ios/Podfile.lock"]
        /* @hide ... */ /* @end */
      }
      /* @hide ... */ /* @end */
    }
    /* @hide ... */ /* @end */
  }
  /* @hide ... */ /* @end */
}
```
