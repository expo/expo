---
title: Using React DOM in Expo
sidebar_title: DOM Components
description: Learn about rendering React DOM elements in Expo native apps.
---

import { Collapsible } from '~/ui/components/Collapsible';
import { Step } from '~/ui/components/Step';
import { Tab, Tabs } from '~/ui/components/Tabs';

Expo offers a novel approach to working with modern web code directly in a native app via the `'use dom'` directive. This enables incremental migration for an entire website to a universal app, simply moving on a per-component basis.

The Expo native runtime generally does not support using `<div>` or `<img>` tags, but you may find that you want to quickly drop in some web components. This is where webviews come in.

## Usage

To render a web component, simply add the `'use dom'` directive to the top of a file:

```js my-component.js (web)
'use dom';

export default function MyComponent() {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```

```js App.js (native)
import MyComponent from './my-component.js';

export default function App() {
  return (
    // This component is a WebView from react-native-webview.
    <MyComponent style={{ backgroundColor: 'dodgerblue' }} />
  );
}
```

## Features

- Shared bundler config across web native and webviews.
- React, TypeScript, CSS, and all other Metro features are enabled in webview components.
- Logging in the terminal.
- Fast Refresh and HMR.
- Embedded exports for offline support.
- Assets are handled the same way as in the native app.
- WebView bundles can be introspected in Expo Atlas for debugging.
- Access to all web functionality without needing a native rebuild.
- Runtime error overlay in development.

## WebView props

To pass props to the underlying webview, add a `webview` object to the component:

```tsx my-components.tsx (web)
'use dom';

export default function MyComponent({}: { webview: import('expo/dom').WebViewProps }) {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```

Now you can pass [`WebView` props](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md) to the webview component:

```tsx App.tsx (native)
import MyComponent from './my-component';

export default function App() {
  return (
    <MyComponent
      webview={{
        scrollEnabled: false,
      }}
    />
  );
}
```

## Native Actions

You can send type-safe native functions to webview components by passing async functions as props to the webview component:

```ts App.tsx (native)
import MyWebView from './my-component';

export default function App() {
  return (
    <MyWebView
      hello={(data: string) => {
        console.log('Hello', data)
      }}
    />
  );
}
```

```tsx my-component.tsx (web)
'use dom';

export default function MyComponent({ hello }: { hello: (data: string) => Promise<void> }) {
  return <p onClick={() => hello('world')}>Click me</p>;
}
```

> You cannot pass functions as nested props to webview components. They must be top-level props.

Native actions are always asynchronous and only accept serializable arguments (i.e. no functions). This is because the data is sent over a bridge to the webview.

Native actions can return serializable data to the webview, this is useful for getting data back from the native side.

```tsx
getDeviceName(): Promise<string> {
  return DeviceInfo.getDeviceName();
}
```

Think of these functions like React Server Actions, but instead of living on the server they live locally in the native app and communicate with the webview. This is a powerful way to inject truly native functionality into your webviews.

## Marshalled props

You can also send data to the webview through serializable props:

```tsx App.tsx (native)
export default function App() {
  return <MyComponent hello={'world'} />;
}
```

```tsx my-component.tsx (web)
'use dom';

export default function MyComponent({ hello }: { hello: string }) {
  return <p>Hello, {hello}</p>;
}
```

These props are sent over an async bridge so they won't be updated synchronously. They're passed as props to the React root component meaning they re-render the entire React tree.

## Communication

You can also send and receive serializable data between your native app and webviews using the `useBridge` API from `expo/dom`:

```js App.js (native)
import MyComponent from './my-component';
import { useBridge } from 'expo/dom';

export default function App() {
  const [emit, webview] = useBridge(data => {
    console.log('Message from webview:', data);
  });
  return (
    <>
      <MyComponent webview={webview} />
      <Text onPress={() => emit({ type: 'hello', data: 'world' })}>Send message</Text>
    </>
  );
}
```

```js my-component.js (web)
'use dom';

import { useBridge } from 'expo/dom';

export default function MyComponent() {
  const [emit] = useBridge(data => {
    console.log('Message from native:', data);
  });
  return (
    <div>
      <h1>Hello, world!</h1>
      <button onClick={() => emit({ type: 'hello', data: 'world' })}>Send message to native</button>
    </div>
  );
}
```

Data cannot contain functions or circular references. On the web-side you can use the imperative APIs `emit` and `addEventListener` without having to go through React. The native side is more limited since it can host multiple webviews and therefore needs to attach different instances of the event emitters.

```js my-api.js (web)
import { emit, addEventListener } from 'expo/dom';

export function sendData() {
  emit({ type: 'hello', data: 'world' });
}

// Observe any data from the native side.
const remove = addEventListener('hello', data => {
  console.log('Message from native:', data);
});

// unsubscribe from events:
remove();
```

All communication is currently global and not scoped to a single webview. This could be changed in the future if needed.

## Feature detection

Because webview components are simply web components, you may find yourself needing extra qualifiers to better support libraries. You can detect if a component is running in a webview with the following:

```js
if (
  typeof window !== 'undefined' &&
  // Detect if the webview global is available.
  typeof window.ReactNativeWebView !== 'undefined'
) {
  // ...
}
```

## Debugging

By default, all `console.log` methods are extended in WebViews to forward logs to the terminal. This makes it fast and easy to see what's happening in your webview components.

Expo also enables WebView inspection and debugging when bundling in development mode. This means you can open Safari > Develop > Simulator > `@iframe` to see the webview's console and inspect elements.

## Manual WebViews

You can still create a manual webview using the `WebView` component from `react-native-webview`:

```js App.js (native)
import { WebView } from 'react-native-webview';

export default function App() {
  return <WebView source={{ html: '<h1>Hello, world!</h1>' }} />;
}
```

This can be useful for rendering websites from a remote server.

## Measuring WebViews

You may want to measure the size of a webview component and report it back to the native side. This can be done using a native action:

```tsx App.tsx (native)
import MyComponent from './my-component';
import { useState } from 'react';

export default function Route() {
  const [height, setHeight] = useState(270);
  return (
    <MyComponent
      updateSize={size => {
        if (size[1] !== height) {
          setHeight(size[1]);
        }
      }}
      webview={{
        style: { height },
      }}
    />
  );
}
```

```tsx my-component.tsx (web)
import { useEffect } from 'react';

function useSize(callback: (size: [number, number]) => void) {
  useEffect(() => {
    // Observe window size changes
    const observer = new ResizeObserver(entries => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        callback([width, height]);
      }
    });

    observer.observe(document.body);

    callback([document.body.clientWidth, document.body.clientHeight]);

    return () => {
      observer.disconnect();
    };
  }, [callback]);
}

export default function Route({
  onLayout,
}: {
  webview: import('expo/dom').WebViewProps;
  onLayout(size: [number, number]);
}) {
  useSize(onLayout);

  return <div />;
}
```

## Architecture

Built-in webview support only renders content as single-page applications (e.g. no SSR or SSG). This is because it's a bit simpler to work with and because you don't need browser indexing techniques in your embedded JS code.

When a module is marked with `'use dom'`, the module is replaced with a proxy reference which is imported at runtime. This feature is primarily just a number of bundler and CLI magic tricks. You can always use a webview with the stnadard approach by passing raw HTML to a webview component if you'd like.

If you import a webview component from another webview, the component will just be one large webview. This is because web content is passed directly through and not wrapped in an iframe.

Overall, this system shares a lot of similarities with Expo's React Server Components implementation.

## Considerations

We recommend always building truly native apps using universal primitives such as `View`, `Image`, and `Text`. WebViews only support standard JavaScript which is slower to parse and startup than Hermes bytecode.

Data can only be sent between webviews and your native app via an async JSON transport system. Avoid depending on data across JS engines. Also avoid deep linking to nested URLs in webviews.

If you have a global state for sharing data this won't be available across JS engines.

While native modules in the Expo SDK can be optimized to support webviews, we haven't done this yet.

While you should avoid using WebViews for your main app, there are some reasonable uses for them. For example, WebViews are conceptually the best way to render rich text and markdown. WebViews also have very good WebGL support.

Many large apps also use WebViews for auxiliary routes such as settings pages, help pages, and other less frequently visited parts of the app.

## Limitations

- You cannot pass `children` to the webview component from the native side.
- Webviews are standalone and do not automatically share data between different instances.
- You cannot add native views to webviews. You can try to absolutely position native content on top of webviews but it may feel a bit janky.
- Function props cannot return content synchronously. They must be async.
- Webviews support both fetching from a server and reading from disk. By default, Expo's webview support embeds the web content and assets on disk to reduce version conflicts and improve performance. This can be extended in the future to support conditionally hosting components as part of our larger universal React Server Components work.

## Direction

Ultimately, universal architecture is the most exciting direction. Our extensive universal tooling is the only reason we can even offer a feature as intricate and valuable as this one.

While webview components help with migration and moving quickly, we recommend using universal views whenever possible.
