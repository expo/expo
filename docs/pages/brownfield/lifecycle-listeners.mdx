---
title: Configuring lifecycle listeners
sidebar_title: Lifecycle listeners
description: Learn about the mechanism that allows the Expo Modules API to hook into the lifecycle of your app.
---

import { Terminal } from '~/ui/components/Snippet';
import { PlatformTag } from '~/ui/components/Tag/PlatformTag';

Some Expo libraries need to handle system events such as deep links, push notifications, and configuration changes by implementing `AppDelegate` or `Activity`/`Application` lifecycle callbacks.

The Expo Modules API provides an easy way to manage such callbacks:

- <PlatformTag platform="ios" /> `ExpoAppDelegate` forwards `AppDelegate` calls to registered
  subscribers. Modules can provide an `ExpoAppDelegateSubscriber` implementation to register
  callbacks.
- <PlatformTag platform="android" /> `ApplicationLifecycleDispatcher` and `ReactActivityHandler`
  forward `Application` and `Activity` lifecycle events to registered listeners. Modules can provide
  `ReactActivityLifecycleListener` and `ApplicationLifecycleListener` implementations through a
  `Package` class to register callbacks.

Using these mechanisms allows modules to register behavior without requiring you to edit native entry points repeatedly.

## Configure your native project

### Android

To integrate `Application` lifecycle listeners on Android, forward the `onCreate()` and `onConfigurationChanged()` calls from your `Application` class to `ApplicationLifecycleDispatcher`:

```diff
class MainApplication : Application() {

  override fun onCreate() {
    super.onCreate()
    ...
+   ApplicationLifecycleDispatcher.onApplicationCreate(this)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    ...
+   ApplicationLifecycleDispatcher.onConfigurationChanged(this, newConfig)
  }
}
```

### iOS

To integrate `AppDelegate` subscribers on iOS, update your `AppDelegate` to inherit from `ExpoAppDelegate`, which you can import from the Expo module:

```diff AppDelegate.swift
+import Expo

@main
-public class AppDelegate: NSObject, UIApplicationDelegate {
+public class AppDelegate: ExpoAppDelegate {
```

If you cannot extend `ExpoAppDelegate` directly (for example, if you already extend another class), you can forward the calls manually by invoking `ExpoAppDelegateSubscriberManager` methods in your existing `AppDelegate` implementation:

```diff AppDelegate.swift
+ import Expo

public class AppDelegate: UIApplicationDelegate {

  open func application(
    _ application: UIApplication,
    willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
+    return ExpoAppDelegateSubscriberManager.application(application, willFinishLaunchingWithOptions: launchOptions)
  }

  open func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
+    return ExpoAppDelegateSubscriberManager.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  ...
}
```

> **Note:** Not all `UIApplicationDelegate` methods that could cause significant side effects are supported. See the Expo source (**ExpoAppDelegate.swift**) for the full list of forwarded methods if you need to rely on a specific delegate.

## Test your integration

A simple way to test if the callbacks are working correctly is to install a module that relies on them. You can install `expo-linking`, which uses lifecycle listeners to handle deep links:

<Terminal cmd={['$ npx expo install expo-linking']} />

Then, add a listener for deep links in your code and observe the console when opening a deep link:

```jsx
import * as Linking from 'expo-linking';

React.useEffect(() => {
  const listener = Linking.addEventListener('url', ({ url }) => {
    console.log('Received deep link:', url);
  });

  return listener.remove;
}, []);
```
