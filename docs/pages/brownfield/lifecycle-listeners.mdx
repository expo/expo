---
title: Configuring lifecycle listeners
sidebar_title: Lifecycle listeners
description: Learn about the mechanism that allows Expo modules API to hook into the lifecycle of your App.
---

import { Collapsible } from '~/ui/components/Collapsible';
import { ContentSpotlight } from '~/ui/components/ContentSpotlight';
import { Terminal, DiffBlock } from '~/ui/components/Snippet';
import { Step } from '~/ui/components/Step';
import { Tabs, Tab } from '~/ui/components/Tabs';
import { PlatformTag } from '~/ui/components/Tag/PlatformTag';

Some of the Expo libraries need to handle system events (deep links, push notifications, configuration changes, etc.) by implementing `AppDelegate` or `Activity/Application` lifecycle callbacks.

The Expo Modules API provides a easy way to manage such callbacks:

- <PlatformTag platform="ios" /> `ExpoAppDelegate` forwards AppDelegate calls to registered
  subscribers. Modules can provide a `ExpoAppDelegateSubscriber` implementations to register
  callbacks.
- <PlatformTag platform="android" /> `ApplicationLifecycleDispatcher` and `ReactActivityHandler`
  forward `Application` and `Activity` lifecycle events to registered listeners. Modules can provide
  `ReactActivityLifecycleListener` and `ApplicationLifecycleListener` implementations via a
  `Package` class to register callbacks.

Using these mechanisms means modules can register behavior without asking you to edit many native entry points repeatedly.

## Configuring your native project

### Android — Activity & Application lifecycle listeners

Make sure your `MainActivity` extends `ReactActivityHandler` (provided by ExpoModulesCore) instead of `ReactActivity`.

**Application listener (Kotlin)**

```kotlin
package expo.modules.mylib

import android.app.Application
import expo.modules.core.interfaces.ApplicationLifecycleListener

class MyLibApplicationLifecycleListener : ApplicationLifecycleListener {
  override fun onCreate(application: Application) {
    // Setup code that would normally live in Application.onCreate
    doSomeSetupInApplicationOnCreate(application)
  }
}
```

### iOS — AppDelegate subscribers

A easy way integrate AppDelegate subscribers is to update your AppDelegate to inherit from `ExpoAppDelegate`, which can be imported by the Expo module.

e.g.

```diff AppDelegate.swift
+import Expo

@main
-public class AppDelegate: NSObject, UIApplicationDelegate {
+public class AppDelegate: ExpoAppDelegate {
```

Modify your `AppDelegate` to extend `ExpoAppDelegate` or invoke the `ExpoAppDelegateSubscriberManager` class directly

**AppLifecycleDelegate.swift**

```diff AppDelegate.swift
+ import Expo

public class AppDelegate: UIApplicationDelegate {

  open func application(
    _ application: UIApplication,
    willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
+    return ExpoAppDelegateSubscriberManager.application(application, willFinishLaunchingWithOptions: launchOptions)
  }

  open func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
  ) -> Bool {
    return ExpoAppDelegateSubscriberManager.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  ...

  public func applicationWillTerminate(_ application: UIApplication) {
    // App will terminate
  }
}
```

Some delegate methods return values or call completion handlers. When multiple subscribers exist, `ExpoAppDelegate` reconciles results to provide the final response expected by the system:

- For boolean-returning delegates like `application(_:didFinishLaunchingWithOptions:) -> Bool`, the aggregated result is `true` if _any_ subscriber returns `true` (this avoids dropping handling when one subscriber needs to claim the event).
- For methods with completion handlers (e.g., remote notification fetch completion), `ExpoAppDelegate` passes a separate completion to each subscriber, waits for all to complete, then merges results in priority order (e.g., `failed` > `newData` > `noData`) to call the original completion with a sensible final value.

> Note: Not all `UIApplicationDelegate` methods that could cause significant side effects are supported. Check the Expo source (ExpoAppDelegate.swift) for the full list of forwarded methods if you need to rely on a specific delegate.

## Test your integration

You have completed all the basic steps to integrate React Native with your application.

An easy way to test if the callbacks are working correctly is to install a module that relies on them. For example, you can install `expo-linking`, which uses lifecycle listeners to handle deep links.

<Terminal cmd={['$ npx expo install expo-linking']} />
