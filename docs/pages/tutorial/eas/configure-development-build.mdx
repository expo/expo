# Car Wash System - Monorepo (Backend + Web + Mobile)

Este reposit√≥rio cont√©m um scaffold completo (MVP) para **site + app** com sistema de controle de lavagens, status em tempo real (fila ‚Üí lavando ‚Üí pronto), emojis de modelo, indica√ß√£o com desconto de 20% e integra√ß√µes essenciais (Socket.IO, FCM token stub, Postgres, Redis).

---

## Estrutura do reposit√≥rio

```
car-wash-system-monorepo/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ .env.example
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ index.js
‚îÇ       ‚îú‚îÄ‚îÄ models.js
‚îÇ       ‚îú‚îÄ‚îÄ routes.js
‚îÇ       ‚îú‚îÄ‚îÄ socket.js
‚îÇ       ‚îî‚îÄ‚îÄ migrations/
‚îÇ           ‚îî‚îÄ‚îÄ init.sql
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ main.jsx
‚îÇ       ‚îú‚îÄ‚îÄ App.jsx
‚îÇ       ‚îú‚îÄ‚îÄ api.js
‚îÇ       ‚îî‚îÄ‚îÄ styles.css
‚îî‚îÄ‚îÄ mobile/
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ App.js
```

---

> **Observa√ß√£o:** esse scaffold foi pensado para ser um ponto de partida funcional. Em produ√ß√£o, ajuste secrets, CORS, SSL, autentica√ß√£o completa e deployment.

---

## docker-compose.yml

```yaml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: carwash
    ports:
      - '5432:5432'
    volumes:
      - db_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - '6379:6379'

  backend:
    build: ./backend
    depends_on:
      - postgres
      - redis
    environment:
      - DATABASE_URL=postgres://postgres:postgres@postgres:5432/carwash
      - REDIS_URL=redis://redis:6379
      - PORT=4000
    ports:
      - '4000:4000'
    volumes:
      - ./backend:/usr/src/app

volumes:
  db_data:
```

---

## BACKEND (Node.js + Express + Sequelize + Socket.IO)

### backend/package.json

```json
{
  "name": "carwash-backend",
  "version": "1.0.0",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.0",
    "sequelize": "^6.32.1",
    "socket.io": "^4.8.1",
    "cors": "^2.8.5",
    "ioredis": "^5.3.2",
    "bcrypt": "^5.1.0",
    "uuid": "^9.0.0",
    "body-parser": "^1.20.2"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
```

### backend/.env.example

```
DATABASE_URL=postgres://postgres:postgres@localhost:5432/carwash
REDIS_URL=redis://localhost:6379
PORT=4000
JWT_SECRET=change_this
FCM_SERVER_KEY=your_fcm_key
```

### backend/src/models.js

```js
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize(process.env.DATABASE_URL, { logging: false });

const User = sequelize.define('User', {
  name: { type: DataTypes.STRING },
  email: { type: DataTypes.STRING, unique: true },
  password_hash: { type: DataTypes.STRING },
  role: { type: DataTypes.STRING, defaultValue: 'customer' },
  referral_code: { type: DataTypes.STRING, unique: true }
});

const Vehicle = sequelize.define('Vehicle', {
  plate: { type: DataTypes.STRING },
  model: { type: DataTypes.STRING },
  category: { type: DataTypes.STRING } // suv, sedan, hatch, pickup, moto
});

const Wash = sequelize.define('Wash', {
  status: { type: DataTypes.STRING, defaultValue: 'queued' },
  queue_position: { type: DataTypes.INTEGER },
  code: { type: DataTypes.STRING },
  started_at: { type: DataTypes.DATE },
  finished_at: { type: DataTypes.DATE }
});

const ReferralReward = sequelize.define('ReferralReward', {
  used: { type: DataTypes.BOOLEAN, defaultValue: false },
  discount_percent: { type: DataTypes.INTEGER, defaultValue: 20 }
});

User.hasMany(Vehicle, { as: 'vehicles' });
Vehicle.belongsTo(User, { as: 'owner' });
Vehicle.hasMany(Wash);
Wash.belongsTo(Vehicle);
Wash.belongsTo(User, { as: 'referredBy' });
ReferralReward.belongsTo(User, { as: 'user' });
ReferralReward.belongsTo(Wash, { as: 'wash' });

module.exports = { sequelize, User, Vehicle, Wash, ReferralReward };
```

### backend/src/routes.js

```js
const express = require('express');
const router = express.Router();
const { User, Vehicle, Wash, ReferralReward, sequelize } = require('./models');
const { v4: uuidv4 } = require('uuid');

// map emoji
const carEmojis = {
  suv: 'üöô',
  sedan: 'üöó',
  hatch: 'üöï',
  pickup: 'üõª',
  sport: 'üèéÔ∏è',
  moto: 'üèçÔ∏è',
  van: 'üöê',
  eletric: '‚ö°üöó'
};

// Create wash (with optional referral_code)
router.post('/washes', async (req, res) => {
  const t = await sequelize.transaction();
  try {
    const { plate, model, category, owner_name, referred_code, user_email } = req.body;

    // upsert user (simplified)
    let user = null;
    if (user_email) {
      user = await User.findOne({ where: { email: user_email } });
      if (!user) user = await User.create({ email: user_email, name: owner_name, referral_code: uuidv4().slice(0,8) }, { transaction: t });
    }

    const vehicle = await Vehicle.create({ plate, model, category, UserId: user ? user.id : null }, { transaction: t });

    // calculate queue position
    const maxPos = await Wash.max('queue_position', { where: { status: 'queued' } }) || 0;
    const wash = await Wash.create({ VehicleId: vehicle.id, status: 'queued', queue_position: maxPos + 1, code: uuidv4().slice(0,8) }, { transaction: t });

    // handle referral
    if (referred_code) {
      const referrer = await User.findOne({ where: { referral_code: referred_code } });
      if (referrer) {
        wash.set('referredById', referrer.id);
        await wash.save({ transaction: t });
        await ReferralReward.create({ userId: referrer.id, washId: wash.id }, { transaction: t });
      }
    }

    await t.commit();

    const vehicleJson = vehicle.toJSON();
    res.json({ wash, vehicle: { ...vehicleJson, emoji: carEmojis[vehicle.category] || 'üöó' } });
  } catch (err) {
    await t.rollback();
    console.error(err);
    res.status(500).json({ error: 'erro ao criar lavagem' });
  }
});

// Get wash by id
router.get('/washes/:id', async (req,res) => {
  const wash = await Wash.findByPk(req.params.id, { include: [Vehicle] });
  if (!wash) return res.status(404).json({ error: 'not found' });
  const vehicle = await Vehicle.findByPk(wash.VehicleId);
  res.json({ wash, vehicle: { ...vehicle.toJSON(), emoji: carEmojis[vehicle.category] || 'üöó' } });
});

// Update status (operator)
router.put('/washes/:id/status', async (req,res) => {
  try {
    const { status } = req.body;
    const wash = await Wash.findByPk(req.params.id, { include: [Vehicle] });
    if (!wash) return res.status(404).json({ error: 'not found' });

    // if starting, set started_at
    if (status === 'washing') wash.started_at = new Date();
    if (status === 'ready') wash.finished_at = new Date();
    wash.status = status;
    await wash.save();

    // if become ready and referredBy exists -> reward was already created; notify via push (placeholder)
    // Emit socket event via socket module (socket.js will export io)
    const io = require('./socket').getIo();
    io.to(`wash_${wash.id}`).emit('wash-updated', { washId: wash.id, status: wash.status });
    io.emit('queue-updated');

    res.json({ wash });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'erro' });
  }
});

// Apply reward automatically at new wash creation (example endpoint to consume reward)
router.post('/washes/:id/apply-reward', async (req,res) => {
  try {
    const wash = await Wash.findByPk(req.params.id);
    if (!wash) return res.status(404).json({ error: 'not found' });

    // find reward for vehicle owner (simplified; assumes vehicle owner user exists)
    const vehicle = await Vehicle.findByPk(wash.VehicleId);
    if (!vehicle || !vehicle.UserId) return res.json({ applied: false });

    const reward = await ReferralReward.findOne({ where: { userId: vehicle.UserId, used: false } });
    if (reward) {
      reward.used = true;
      await reward.save();
      return res.json({ applied: true, discount_percent: reward.discount_percent });
    }
    return res.json({ applied: false });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'erro' });
  }
});

module.exports = router;
```

### backend/src/socket.js

```js
let io = null;

module.exports = {
  init: (server) => {
    const { Server } = require('socket.io');
    io = new Server(server, { cors: { origin: '*' } });

    io.on('connection', (socket) => {
      socket.on('join-wash-room', ({ washId }) => {
        socket.join(`wash_${washId}`);
      });
      socket.on('disconnect', () => {});
    });

    return io;
  },
  getIo: () => io
};
```

### backend/src/index.js

```js
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const http = require('http');
const { sequelize } = require('./models');
const routes = require('./routes');
const socketModule = require('./socket');

const app = express();
app.use(cors());
app.use(bodyParser.json());
app.use('/api', routes);

const server = http.createServer(app);
const io = socketModule.init(server);

(async () => {
  await sequelize.sync();
  const PORT = process.env.PORT || 4000;
  server.listen(PORT, () => console.log('Server running on', PORT));
})();
```

---

## FRONTEND (React - Vite)

### frontend/package.json

```json
{
  "name": "carwash-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "socket.io-client": "^4.8.1",
    "axios": "^1.4.0"
  }
}
```

### frontend/src/api.js

```js
import axios from 'axios';
const API = axios.create({ baseURL: 'http://localhost:4000/api' });
export default API;
```

### frontend/src/main.jsx

```jsx
import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './styles.css'

createRoot(document.getElementById('root')).render(<App />)
```

### frontend/src/App.jsx

```jsx
import React, { useEffect, useState } from 'react';
import API from './api';
import { io } from 'socket.io-client';

const socket = io('http://localhost:4000');

export default function App() {
  const [washId, setWashId] = useState('');
  const [wash, setWash] = useState(null);
  const [plate, setPlate] = useState('');
  const [model, setModel] = useState('');
  const [category, setCategory] = useState('sedan');

  useEffect(() => {
    socket.on('wash-updated', (data) => {
      if (wash && data.washId === wash.id) {
        // refetch
        fetchWash(wash.id);
      }
    });
    return () => socket.disconnect();
  }, [wash]);

  async function createWash() {
    const res = await API.post('/washes', { plate, model, category, owner_name: 'Cliente Teste', user_email: '' });
    setWash(res.data.wash);
  }

  async function fetchWash(id) {
    const res = await API.get('/washes/' + id);
    setWash(res.data.wash);
  }

  async function joinRoom() {
    socket.emit('join-wash-room', { washId: wash.id });
  }

  return (
    <div className="container">
      <h1>Car Wash - Cliente</h1>
      <div className="card">
        <input placeholder="Placa" value={plate} onChange={e=>setPlate(e.target.value)} />
        <input placeholder="Modelo" value={model} onChange={e=>setModel(e.target.value)} />
        <select value={category} onChange={e=>setCategory(e.target.value)}>
          <option value="sedan">üöó Sedan</option>
          <option value="hatch">üöï Hatch</option>
          <option value="suv">üöô SUV</option>
          <option value="pickup">üõª Picape</option>
          <option value="moto">üèçÔ∏è Moto</option>
        </select>
        <button onClick={createWash}>Registrar lavagem</button>
      </div>

      {wash && (
        <div className="card">
          <h2>Status</h2>
          <p>ID: {wash.id}</p>
          <p>Posi√ß√£o: {wash.queue_position}</p>
          <p>Status: {wash.status}</p>
          <button onClick={joinRoom}>Acompanhar em tempo real</button>
        </div>
      )}
    </div>
  )
}
```

### frontend/src/styles.css

```css
body { font-family: Arial, sans-serif; padding: 24px; }
.container { max-width: 700px; margin: 0 auto; }
.card { padding: 12px; border: 1px solid #ddd; margin-bottom: 12px; border-radius: 8px }
input, select { display:block; margin-bottom:8px; padding:8px; width:100%; }
button { padding:8px 12px }
```

---

## MOBILE (React Native - Expo Minimal)

### mobile/package.json

```json
{
  "name": "carwash-mobile",
  "version": "1.0.0",
  "main": "App.js",
  "scripts": {
    "start": "expo start"
  },
  "dependencies": {
    "expo": "^48.0.0",
    "react": "18.2.0",
    "react-native": "0.71.8",
    "socket.io-client": "^4.8.1",
    "axios": "^1.4.0"
  }
}
```

### mobile/App.js

```js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import API from './src/api';
import { io } from 'socket.io-client';

const socket = io('http://localhost:4000');

export default function App(){
  const [plate, setPlate] = useState('');
  const [model, setModel] = useState('');
  const [category, setCategory] = useState('sedan');
  const [wash, setWash] = useState(null);

  useEffect(()=>{
    socket.on('wash-updated', data => {
      if (wash && data.washId === wash.id) {
        fetchWash(wash.id);
      }
    });
    return () => socket.disconnect();
  }, [wash]);

  async function createWash(){
    const res = await API.post('/washes', { plate, model, category, owner_name: 'Mobile User' });
    setWash(res.data.wash);
  }

  async function fetchWash(id){
    const res = await API.get('/washes/' + id);
    setWash(res.data.wash);
  }

  return (
    <View style={{ padding:20 }}>
      <Text>Car Wash - Mobile</Text>
      <TextInput placeholder="Placa" value={plate} onChangeText={setPlate} style={{borderWidth:1, padding:8, marginVertical:8}} />
      <TextInput placeholder="Modelo" value={model} onChangeText={setModel} style={{borderWidth:1, padding:8, marginVertical:8}} />
      <Button title="Registrar" onPress={createWash} />

      {wash && (
        <View style={{ marginTop:20 }}>
          <Text>ID: {wash.id}</Text>
          <Text>Status: {wash.status}</Text>
        </View>
      )}
    </View>
  );
}
```

---

## MIGRATION SQL (in backend/src/migrations/init.sql)

```sql
-- run only if not using sequelize.sync()
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(150),
  email VARCHAR(150) UNIQUE,
  password_hash VARCHAR(200),
  role VARCHAR(20),
  referral_code VARCHAR(20) UNIQUE
);

CREATE TABLE vehicles (
  id SERIAL PRIMARY KEY,
  plate VARCHAR(20),
  model VARCHAR(100),
  category VARCHAR(20),
  "UserId" INT REFERENCES users(id)
);

CREATE TABLE washes (
  id SERIAL PRIMARY KEY,
  "VehicleId" INT REFERENCES vehicles(id),
  status VARCHAR(30),
  queue_position INT,
  code VARCHAR(32),
  started_at TIMESTAMP,
  finished_at TIMESTAMP,
  "referredById" INT REFERENCES users(id)
);

CREATE TABLE "ReferralRewards" (
  id SERIAL PRIMARY KEY,
  "userId" INT REFERENCES users(id),
  "washId" INT REFERENCES washes(id),
  used BOOLEAN DEFAULT FALSE,
  discount_percent INT DEFAULT 20,
  created_at TIMESTAMP DEFAULT now()
);
```

---

## README - Como rodar localmente (resumo)

1. Tenha Docker e Docker Compose instalados.
2. No diret√≥rio raiz, rode `docker-compose up --build`.
3. Backend estar√° em `http://localhost:4000`.
4. Entrar em `frontend/` e rodar `npm install && npm run dev`.
5. Entrar em `mobile/` e rodar `npm install && npm start` (Expo) ‚Äî no emulador use host machine IP se necess√°rio.

**Aten√ß√£o:** sockets e mobile podem precisar ajustar `localhost` para IP da m√°quina (por exemplo `http://192.168.0.10:4000`).

---

## Observa√ß√µes finais e pr√≥ximos passos sugeridos
- Implementar autentica√ß√£o JWT completa e RBAC.
- Salvar tokens FCM e enviar push reais usando pacote `firebase-admin` ou servi√ßos externos.
- Melhorar UI e UX (barra de progresso, timeline com emojis e imagens pequenas se quiser usar imagens reais em vez de emoji).
- Polir concorr√™ncia da fila (usar advisory locks ou filas Redis).
- Testes unit e E2E.

---

Se quiser, eu j√° adapto esse scaffold com:
- c√≥digo pronto em TypeScript + Prisma, ou
- painel admin React com drag&drop para iniciar lavagens, ou
- integra√ß√£o real com FCM para push.

Diga qual destes prefere que eu gere a seguir e eu j√° atualizo o c√≥digo aqui no canvas.
