const path = require('path');
const fs = require('fs');

let ExpSchema;
try {
  ExpSchema = require('../../dev/xdl/src/project/ExpSchema');
} catch (e) {
  return;
}

if (!process.argv[2]) {
  console.error('Please pass in the path to the target file');
}

const filePath = path.resolve(process.argv[2]);
const stream = fs.createWriteStream(filePath);

const preamble = `
\`\`exp.json\`\` is your go-to place for configuring parts of your app that don't belong in code. The following is a full list of properties available to you.\
\n\n
`;

// Open and write!
stream.once('open', function(fd) {
  const readableSchema = ExpSchema._inner.children.map(property => {
    return extractData(property);
  });

  stream.write(".. _exp:\n\n");
  stream.write("Configuration with exp.json\n");
  stream.write("========\n\n\n");


  stream.write(".. This file is automatically generated! Do not edit it directly -- see scripts/generate-exp-docs.js\n");
  stream.write(preamble);
  writePropertiesToStream(stream, readableSchema);
  stream.end();
});

function writePropertiesToStream(stream, schema, depth = 0) {
  schema.forEach(prop => {
    let depthSpacing = (new Array(depth)).join(' ');
    stream.write(`\n${depthSpacing}.. attribute:: ${prop.key}\n`);
    stream.write(`\n${depthSpacing} ${propertyDescription(prop, depthSpacing)}`);
    if (prop.children) {
      writePropertiesToStream(stream, prop.children, depth + 4);
    }
  });
}

/* Helper functions */

function propertyDescription(prop, depthSpacing) {
  let result = '';

  if (prop.isRequired) {
    result += '**Required**. ';
  }

  if (prop.isStandaloneOnly) {
    result += '**Standalone Apps Only**. ';
  }

  if (prop.description) {
    result += `${prop.description}\n`;
  }

  if (prop.validOptions) {
    result += `${depthSpacing} ${prop.validOptions}\n`;
  }

  return result;
}

function extractValidOptions(property) {
  let { schema } = property;
  if (schema._valids && schema._valids._set.length) {
    return schema._valids._set.join(', ');
  } else if (schema._meta[0] && schema._meta[0].regexHuman) {
    return schema._meta[0].regexHuman;
  }
}

function determineIfStandaloneOnly(property) {
  let { schema } = property;
  let result = false;

  if (schema._meta) {
    schema._meta.forEach(meta => {
      if (meta.standaloneOnly) {
        result = true;
      }
    });
  }

  return result;
}

function extractData(property) {
  let key = property.key;
  let { schema } = property;
  let description = (schema._description || '').trim();
  let type = schema._type;
  let validOptions = extractValidOptions(property);
  let isRequired = !!(schema._flags && schema._flags.presence === 'required');
  let isStandaloneOnly = determineIfStandaloneOnly(property);

  let data = {
    description,
    isRequired,
    isStandaloneOnly,
    key,
    type,
    validOptions,
  };

  let children = property.schema._inner.children;
  if (children) {
    data = Object.assign(data, {children: children.map(child => extractData(child))});
  }

  return data;
}
