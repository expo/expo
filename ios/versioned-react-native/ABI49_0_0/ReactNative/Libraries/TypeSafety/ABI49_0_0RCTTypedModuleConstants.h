/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <utility>

#import <Foundation/Foundation.h>

#import <ABI49_0_0React/ABI49_0_0RCTBridgeModule.h>
#import <ABI49_0_0React/ABI49_0_0RCTDefines.h>

/**
 * Interop type layer for ABI49_0_0RN's exportedConstants and the C++ structs generated by our typesafety codegen.
 *
 * The ABI49_0_0NativeModuleSpec will define a constantsToExport method which you can implement as follows:
 *
 * - (nonnull ModuleConstants<ABI49_0_0JS::Constants>)constantsToExport
 * {
 *   return typedConstants<ABI49_0_0JS::Constants>({ ... });
 * }
 */

// Internal container for module constants. Do not use yourself directly, instead use the typedConstants helpers below.
@interface _ABI49_0_0RCTTypedModuleConstants<StructType> : NSDictionary <NSString *, id>

+ (instancetype)newWithUnsafeDictionary:(NSDictionary<NSString *, id> *)dictionary;

@end

namespace ABI49_0_0facebook {
namespace ABI49_0_0React {

// Objective-C doesn't allow arbitrary types in its lightweight generics, only object and block types. We can work
// around that by having the struct type we care about be a block-argument. The block never exists at runtime.
template <typename T>
using ModuleConstants = _ABI49_0_0RCTTypedModuleConstants<void (^)(T)> *;

template <typename T>
ModuleConstants<T> typedConstants(typename T::Builder::Input &&value)
{
  typename T::Builder builder(std::move(value));
  return [_ABI49_0_0RCTTypedModuleConstants newWithUnsafeDictionary:builder.buildUnsafeRawValue()];
}

}
}
