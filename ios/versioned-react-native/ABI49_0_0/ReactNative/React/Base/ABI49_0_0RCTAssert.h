/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#import <Foundation/Foundation.h>

#import <ABI49_0_0React/ABI49_0_0RCTDefines.h>

/*
 * Defined in ABI49_0_0RCTUtils.m
 */
ABI49_0_0RCT_EXTERN BOOL ABI49_0_0RCTIsMainQueue(void);

/**
 * This is the main assert macro that you should use. Asserts should be compiled out
 * in production builds. You can customize the assert behaviour by setting a custom
 * assert handler through `ABI49_0_0RCTSetAssertFunction`.
 */
#ifndef NS_BLOCK_ASSERTIONS
#define ABI49_0_0RCTAssert(condition, ...)                                                                    \
  do {                                                                                               \
    if ((condition) == 0) {                                                                          \
      _ABI49_0_0RCTAssertFormat(#condition, __FILE__, __LINE__, __func__, __VA_ARGS__);                       \
      if (ABI49_0_0RCT_NSASSERT) {                                                                            \
        [[NSAssertionHandler currentHandler] handleFailureInFunction:(NSString *_Nonnull)@(__func__) \
                                                                file:(NSString *_Nonnull)@(__FILE__) \
                                                          lineNumber:__LINE__                        \
                                                         description:__VA_ARGS__];                   \
      }                                                                                              \
    }                                                                                                \
  } while (false)
#else
#define ABI49_0_0RCTAssert(condition, ...) \
  do {                            \
  } while (false)
#endif
ABI49_0_0RCT_EXTERN void _ABI49_0_0RCTAssertFormat(const char *, const char *, int, const char *, NSString *, ...)
    NS_FORMAT_FUNCTION(5, 6);

/**
 * Report a fatal condition when executing. These calls will _NOT_ be compiled out
 * in production, and crash the app by default. You can customize the fatal behaviour
 * by setting a custom fatal handler through `ABI49_0_0RCTSetFatalHandler` and
 * `ABI49_0_0RCTSetFatalExceptionHandler`.
 */
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTFatal(NSError *error);
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTFatalException(NSException *exception);

/**
 * The default error domain to be used for ABI49_0_0React errors.
 */
ABI49_0_0RCT_EXTERN NSString *const ABI49_0_0RCTErrorDomain;

/**
 * JS Stack trace provided as part of an NSError's userInfo
 */
ABI49_0_0RCT_EXTERN NSString *const ABI49_0_0RCTJSStackTraceKey;

/**
 * Raw JS Stack trace string provided as part of an NSError's userInfo
 */
ABI49_0_0RCT_EXTERN NSString *const ABI49_0_0RCTJSRawStackTraceKey;

/**
 * Objective-C stack trace string provided as part of an NSError's userInfo
 */
ABI49_0_0RCT_EXTERN NSString *const ABI49_0_0RCTObjCStackTraceKey;

/**
 * Name of fatal exceptions generated by ABI49_0_0RCTFatal
 */
ABI49_0_0RCT_EXTERN NSString *const ABI49_0_0RCTFatalExceptionName;

/**
 * Stringified JSON object containing extra data to attach to the error from JavaScript.
 */
ABI49_0_0RCT_EXTERN NSString *const ABI49_0_0RCTJSExtraDataKey;

/**
 * A block signature to be used for custom assertion handling.
 */
typedef void (^ABI49_0_0RCTAssertFunction)(
    NSString *condition,
    NSString *fileName,
    NSNumber *lineNumber,
    NSString *function,
    NSString *message);

typedef void (^ABI49_0_0RCTFatalHandler)(NSError *error);
typedef void (^ABI49_0_0RCTFatalExceptionHandler)(NSException *exception);

/**
 * Convenience macro for asserting that a parameter is non-nil/non-zero.
 */
#define ABI49_0_0RCTAssertParam(name) ABI49_0_0RCTAssert(name, @"'%s' is a required parameter", #name)

/**
 * Convenience macro for asserting that we're running on main queue.
 */
#define ABI49_0_0RCTAssertMainQueue() ABI49_0_0RCTAssert(ABI49_0_0RCTIsMainQueue(), @"This function must be called on the main queue")

/**
 * Convenience macro for asserting that we're running off the main queue.
 */
#define ABI49_0_0RCTAssertNotMainQueue() ABI49_0_0RCTAssert(!ABI49_0_0RCTIsMainQueue(), @"This function must not be called on the main queue")

/**
 * These methods get and set the current assert function called by the ABI49_0_0RCTAssert
 * macros. You can use these to replace the standard behavior with custom assert
 * functionality.
 */
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTSetAssertFunction(ABI49_0_0RCTAssertFunction assertFunction);
ABI49_0_0RCT_EXTERN ABI49_0_0RCTAssertFunction ABI49_0_0RCTGetAssertFunction(void);

/**
 * This appends additional code to the existing assert function, without
 * replacing the existing functionality. Useful if you just want to forward
 * assert info to an extra service without changing the default behavior.
 */
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTAddAssertFunction(ABI49_0_0RCTAssertFunction assertFunction);

/**
 * This method temporarily overrides the assert function while performing the
 * specified block. This is useful for testing purposes (to detect if a given
 * function asserts something) or to suppress or override assertions temporarily.
 */
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTPerformBlockWithAssertFunction(void (^block)(void), ABI49_0_0RCTAssertFunction assertFunction);

/**
 * These methods get and set the current fatal handler called by the `ABI49_0_0RCTFatal`
 * and `ABI49_0_0RCTFatalException` methods.
 */
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTSetFatalHandler(ABI49_0_0RCTFatalHandler fatalHandler);
ABI49_0_0RCT_EXTERN ABI49_0_0RCTFatalHandler ABI49_0_0RCTGetFatalHandler(void);
ABI49_0_0RCT_EXTERN void ABI49_0_0RCTSetFatalExceptionHandler(ABI49_0_0RCTFatalExceptionHandler fatalExceptionHandler);
ABI49_0_0RCT_EXTERN ABI49_0_0RCTFatalExceptionHandler ABI49_0_0RCTGetFatalExceptionHandler(void);

/**
 * Get the current thread's name (or the current queue, if in debug mode)
 */
ABI49_0_0RCT_EXTERN NSString *ABI49_0_0RCTCurrentThreadName(void);

/**
 * Helper to get generate exception message from NSError
 */
ABI49_0_0RCT_EXTERN NSString *
ABI49_0_0RCTFormatError(NSString *message, NSArray<NSDictionary<NSString *, id> *> *stacktrace, NSUInteger maxMessageLength);

/**
 * Formats a JS stack trace for logging.
 */
ABI49_0_0RCT_EXTERN NSString *ABI49_0_0RCTFormatStackTrace(NSArray<NSDictionary<NSString *, id> *> *stackTrace);

/**
 * Convenience macro to assert which thread is currently running (DEBUG mode only)
 */
#if DEBUG

#define ABI49_0_0RCTAssertThread(thread, ...)                                                                                  \
  _Pragma("clang diagnostic push") _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"") ABI49_0_0RCTAssert(       \
      [(id)thread isKindOfClass:[NSString class]]       ? [ABI49_0_0RCTCurrentThreadName() isEqualToString:(NSString *)thread] \
          : [(id)thread isKindOfClass:[NSThread class]] ? [NSThread currentThread] == (NSThread *)thread              \
                                                        : dispatch_get_current_queue() == (dispatch_queue_t)thread,   \
      __VA_ARGS__);                                                                                                   \
  _Pragma("clang diagnostic pop")

#else

#define ABI49_0_0RCTAssertThread(thread, ...) \
  do {                               \
  } while (0)

#endif

// MARK: - New Architecture Validation

typedef enum {
  ABI49_0_0RCTNotAllowedInBridgeless = 1,
  ABI49_0_0RCTNotAllowedInFabricWithoutLegacy = 2,
  ABI49_0_0RCTNotAllowedValidationDisabled = 3,
} ABI49_0_0RCTNotAllowedValidation;

/**
 * // TODO: (T125626909) Only validate legacy architecture usages in Bridgeless mode, not Bridged Fabric mode
 *
 * Ensure runtime assumptions holds for the new architecture by reporting when assumptions are violated.
 * Note: this is work in progress.
 *
 * When level is ABI49_0_0RCTNotAllowedInFabricWithoutLegacy, validate Fabric assumptions.
 * i.e. Report legacy pre-Fabric call sites that should not be used while Fabric is enabled on all surfaces.
 *
 * When level is ABI49_0_0RCTNotAllowedInBridgeless, validate Fabric or Bridgeless assumptions.
 * i.e. Report Bridge call sites that should not be used while Bridgeless mode is enabled.
 *
 * Note: enabling this at runtime is not early enough to report issues within ObjC class +load execution.
 */
__attribute__((used)) ABI49_0_0RCT_EXTERN void ABI49_0_0RCTNewArchitectureSetMinValidationLevel(ABI49_0_0RCTNotAllowedValidation level);

// When new architecture validation reporting is enabled, trigger an assertion and crash.
__attribute__((used)) ABI49_0_0RCT_EXTERN void
ABI49_0_0RCTEnforceNewArchitectureValidation(ABI49_0_0RCTNotAllowedValidation type, id context, NSString *extra);
// When new architecture validation reporting is enabled, trigger an error but do not crash.
// When ready, switch to stricter variant above.
__attribute__((used)) ABI49_0_0RCT_EXTERN void
ABI49_0_0RCTErrorNewArchitectureValidation(ABI49_0_0RCTNotAllowedValidation type, id context, NSString *extra);
// When new architecture validation reporting is enabled, log an message.
// When ready, switch to stricter variant above.
__attribute__((used)) ABI49_0_0RCT_EXTERN void
ABI49_0_0RCTLogNewArchitectureValidation(ABI49_0_0RCTNotAllowedValidation type, id context, NSString *extra);
// A placeholder for callsites that frequently fail validation.
// When ready, switch to stricter variant above.
__attribute__((used)) ABI49_0_0RCT_EXTERN void
ABI49_0_0RCTNewArchitectureValidationPlaceholder(ABI49_0_0RCTNotAllowedValidation type, id context, NSString *extra);
