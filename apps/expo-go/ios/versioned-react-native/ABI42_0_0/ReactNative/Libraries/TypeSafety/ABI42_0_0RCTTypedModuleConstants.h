/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <utility>

#import <Foundation/Foundation.h>

#import <ABI42_0_0React/ABI42_0_0RCTBridgeModule.h>
#import <ABI42_0_0React/ABI42_0_0RCTDefines.h>

/**
 * Interop type layer for RN's exportedConstants and the C++ structs generated by our typesafety codegen.
 *
 * The ABI42_0_0NativeModuleSpec will define a constantsToExport method which you can implement as follows:
 *
 * - (nonnull ModuleConstants<JS::Constants>)constantsToExport
 * {
 *   return typedConstants<JS::Constants>({ ... });
 * }
 */

// Internal container for module constants. Do not use yourself directly, instead use the typedConstants helpers below.
@interface _ABI42_0_0RCTTypedModuleConstants<StructType> : NSDictionary<NSString *, id>

+ (instancetype)newWithUnsafeDictionary:(NSDictionary<NSString *, id> *)dictionary;

@end

namespace ABI42_0_0facebook {
namespace ABI42_0_0React {

// Objective-C doesn't allow arbitrary types in its lightweight generics, only object and block types. We can work
// around that by having the struct type we care about be a block-argument. The block never exists at runtime.
template<typename T>
using ModuleConstants = _ABI42_0_0RCTTypedModuleConstants<void (^)(T)> *;

template<typename T>
ModuleConstants<T> typedConstants(typename T::Builder::Input &&value) {
  typename T::Builder builder(std::move(value));
  return [_ABI42_0_0RCTTypedModuleConstants newWithUnsafeDictionary:builder.buildUnsafeRawValue()];
}

} }
