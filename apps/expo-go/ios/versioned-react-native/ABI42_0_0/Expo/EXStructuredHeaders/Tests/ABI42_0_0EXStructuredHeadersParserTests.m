//  Copyright (c) 2021 650 Industries, Inc. All rights reserved.

@import XCTest;

#import <objc/runtime.h>
#import <ABI42_0_0EXStructuredHeaders/ABI42_0_0EXStructuredHeadersParser.h>

#import "ABI42_0_0EXStructuredHeadersTestFixtures.h"
#import "ABI42_0_0NSArray+ABI42_0_0EXStructuredHeadersTests.h"
#import "ABI42_0_0NSDictionary+ABI42_0_0EXStructuredHeadersTests.h"

@interface ABI42_0_0EXStructuredHeadersParserTests : XCTestCase

@end

@implementation ABI42_0_0EXStructuredHeadersParserTests

- (void)setUp
{
  [super setUp];

  // Replace NSDictionary's isEqual: method at runtime with one that knows about
  // the idiomatic format of the `expected` field in the test JSON objects.
  // This prevents us from having to iterate through every possible item and
  // pre-process the expected objects.
  //
  // Same for NSArray, since dictionaries are represented in the expected results
  // as arrays of tuples rather than key-value objects.
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    [self swizzleMethodForClass:[NSDictionary class]];
    [self swizzleMethodForClass:[NSArray class]];
  });
}

- (void)tearDown
{
  [super tearDown];
}

// https://nshipster.com/method-swizzling/
- (void)swizzleMethodForClass:(Class)class
{
  SEL originalSelector = @selector(isEqual:);
  SEL swizzledSelector = @selector(isEqualToTestResult:);

  Method originalMethod = class_getInstanceMethod(class, originalSelector);
  Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
  
  BOOL didAddMethod =
  class_addMethod(class,
                  originalSelector,
                  method_getImplementation(swizzledMethod),
                  method_getTypeEncoding(swizzledMethod));
  
  if (didAddMethod) {
    class_replaceMethod(class,
                        swizzledSelector,
                        method_getImplementation(originalMethod),
                        method_getTypeEncoding(originalMethod));
  } else {
    method_exchangeImplementations(originalMethod, swizzledMethod);
  }
}

- (void)runTests:(NSString *)testsJson
{
  NSError *error;
  NSArray<NSDictionary *> *tests = [NSJSONSerialization JSONObjectWithData:[testsJson dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:&error];
  XCTAssertNil(error);

  XCTAssert(tests.count > 0, @"There should be at least one test");

  for (NSDictionary *test in tests) {
    // When generating input_bytes, parsers MUST combine all field lines in the same section (header or trailer)
    // that case-insensitively match the field name into one comma-separated field-value, as per [RFC7230], Section 3.2.2;
    // this assures that the entire field value is processed correctly.
    NSString *rawInput = [(NSArray *)test[@"raw"] componentsJoinedByString:@","];
    ABI42_0_0EXStructuredHeadersParser *parser = [[ABI42_0_0EXStructuredHeadersParser alloc] initWithRawInput:rawInput fieldType:[self fieldTypeWithString:test[@"header_type"]]];
    if ([(NSNumber *)test[@"must_fail"] boolValue]) {
      NSError *error;
      XCTAssertNil([parser parseStructuredFieldsWithError:&error], @"Test failed: %@", test[@"name"]);
      XCTAssertNotNil(error, @"Test failed correctly, but there was no error object: %@", test[@"name"]);
    } else {
      NSError *error;
      id actual = [parser parseStructuredFieldsWithError:&error];
      XCTAssertNil(error, @"Test failed: %@", test[@"name"]);

      id expected = test[@"expected"];
      if ([(NSNumber *)test[@"can_fail"] boolValue]) {
        XCTAssert(!actual || [expected isEqual:actual], @"Test failed: %@", test[@"name"]);
      } else {
        XCTAssertEqualObjects(expected, actual, @"Test failed: %@", test[@"name"]);
      }
    }
  }
}

- (ABI42_0_0EXStructuredHeadersParserFieldType)fieldTypeWithString:(NSString *)string
{
  if ([@"dictionary" isEqualToString:string]) {
    return ABI42_0_0EXStructuredHeadersParserFieldTypeDictionary;
  } else if ([@"list" isEqualToString:string]) {
    return ABI42_0_0EXStructuredHeadersParserFieldTypeList;
  } else if ([@"item" isEqualToString:string]) {
    return ABI42_0_0EXStructuredHeadersParserFieldTypeItem;
  } else {
    XCTAssert(NO, @"unexpected header_type");
  }
}

// do not modify below this line - generated by scripts/generated-tests.js

// GENERATED TESTS BEGIN

- (void)testBinary
{
  [self runTests:ABI42_0_0EXStructuredHeadersBinaryTests];
}

- (void)testBoolean
{
  [self runTests:ABI42_0_0EXStructuredHeadersBooleanTests];
}

- (void)testDictionary
{
  [self runTests:ABI42_0_0EXStructuredHeadersDictionaryTests];
}

- (void)testExamples
{
  [self runTests:ABI42_0_0EXStructuredHeadersExamplesTests];
}

- (void)testItem
{
  [self runTests:ABI42_0_0EXStructuredHeadersItemTests];
}

- (void)testKeyGenerated
{
  [self runTests:ABI42_0_0EXStructuredHeadersKeyGeneratedTests];
}

- (void)testLargeGenerated
{
  [self runTests:ABI42_0_0EXStructuredHeadersLargeGeneratedTests];
}

- (void)testList
{
  [self runTests:ABI42_0_0EXStructuredHeadersListTests];
}

- (void)testListlist
{
  [self runTests:ABI42_0_0EXStructuredHeadersListlistTests];
}

- (void)testNumberGenerated
{
  [self runTests:ABI42_0_0EXStructuredHeadersNumberGeneratedTests];
}

- (void)testNumber
{
  [self runTests:ABI42_0_0EXStructuredHeadersNumberTests];
}

- (void)testParamDict
{
  [self runTests:ABI42_0_0EXStructuredHeadersParamDictTests];
}

- (void)testParamList
{
  [self runTests:ABI42_0_0EXStructuredHeadersParamListTests];
}

- (void)testParamListlist
{
  [self runTests:ABI42_0_0EXStructuredHeadersParamListlistTests];
}

- (void)testStringGenerated
{
  [self runTests:ABI42_0_0EXStructuredHeadersStringGeneratedTests];
}

- (void)testString
{
  [self runTests:ABI42_0_0EXStructuredHeadersStringTests];
}

- (void)testTokenGenerated
{
  [self runTests:ABI42_0_0EXStructuredHeadersTokenGeneratedTests];
}

- (void)testToken
{
  [self runTests:ABI42_0_0EXStructuredHeadersTokenTests];
}

@end
