import * as spawnAsync from '@expo/spawn-async';
import { globSync } from 'glob';
import * as path from 'path';
import * as fs from 'fs';

const name = 'NativeComponents';

function buildInlineModule(viewNames: string[]) {
  return `import React
import ExpoModulesCore

public final class ${name}Module: Module {
  public func definition() -> ModuleDefinition {
    Name("${name}Module")

    ${viewNames.map((n) => `View(${n}.self)`).join('\n\n')}
  }
}
`;
}

function buildImportFile(viewName: string) {
  return `// Autogenerated by expo nativegen

import { requireNativeView } from 'expo';

interface Props {}

const NativeView = requireNativeView<Props>('${name}Module', '${viewName}');

export default function ${viewName}(props: Props) {
  return <NativeView {...props} />;
}
`;
}

function buildPodspec() {
  return `require 'json'
Pod::Spec.new do |s|
  s.name           = '${name}Module'
  s.version        = '0.0.1'
  s.summary        = 'A module expo'
  s.description    = 'A module expo'
  s.license        = 'A module expo'
  s.author         = 'A module expo'
  s.homepage       = 'A module expo'
  s.platforms      = {
    :ios => '15.1',
    :tvos => '15.1'
  }
  s.swift_version  = '5.4'
  s.source         = { git: 'https://github.com/expo/expo.git' }
  s.static_framework = true

  s.dependency 'ExpoModulesCore'

  # Swift/Objective-C compatibility
  s.pod_target_xcconfig = {
    'DEFINES_MODULE' => 'YES'
  }

  s.source_files = "**/*.{h,m,mm,swift,hpp,cpp}"
end
`;
}

function main() {
  console.log('linking native files');
  nativegen();
  console.log('installing pods');
  spawnAsync('npx', ['pod-install']);
}

function nativegen() {
  const root = path.join(path.dirname(findNearestPackageJson(__dirname)));
  // const targetFolder = path.join(config.modRequest.projectRoot, 'ios');
  // Use glob to find all `.swift` files in the src folder
  const result = [
    ...globSync(path.join(root, 'app', '*.swift')),
    ...globSync(path.join(root, 'src', '*.swift')),
  ];

  // if (err) throw new Error(`Error finding Swift files: ${err}`);
  const modulePath = path.join(root, 'modules', name.toLowerCase());
  fs.rmSync(modulePath, { force: true, recursive: true });
  fs.mkdirSync(modulePath, { recursive: true });
  const config = {
    platforms: ['apple', 'android'],
    apple: {
      //   modules: result.map((file) => './' + path.relative(root, file)),
      modules: [`${name}Module`],
    },
    // android: {
    //   modules: ['expo.modules.inline.BenchmarkingExpoModule'],
    // },
  };
  fs.writeFileSync(
    path.join(modulePath, 'expo-module.config.json'),
    JSON.stringify(config, null, 2)
  );
  fs.mkdirSync(path.join(modulePath, 'ios'), { recursive: true });
  fs.writeFileSync(path.join(modulePath, 'ios', `${name}Module.podspec`), buildPodspec());
  fs.writeFileSync(
    path.join(modulePath, 'ios', `${name}Module.swift`),
    buildInlineModule(result.map((r) => path.basename(r, path.extname(r))))
  );
  result.forEach((r) => {
    fs.symlinkSync(r, path.join(modulePath, 'ios', path.basename(r)));
  });
  console.log('creating typescript wrappers');
  result.forEach((r) => {
    fs.writeFileSync(
      r.replace('.swift', '.tsx'),
      buildImportFile(path.basename(r, path.extname(r)))
    );
  });
}

function findNearestPackageJson(startDir) {
  let currentDir = startDir;

  // Continue until the root directory is reached
  while (path.dirname(currentDir) !== currentDir) {
    const potentialPath = path.join(currentDir, 'package.json');

    // Check if a package.json exists at this path
    if (fs.existsSync(potentialPath)) {
      return potentialPath;
    }

    // Move to the parent directory
    currentDir = path.dirname(currentDir);
  }

  // If no package.json is found throughout the tree, return null or throw an error
  return null;
}
main();
