"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var spawnAsync = require("@expo/spawn-async");
var glob_1 = require("glob");
var path = require("path");
var fs = require("fs");
var name = 'NativeComponents';
function buildInlineModule(viewNames) {
    return "import React\nimport ExpoModulesCore\n\npublic final class ".concat(name, "Module: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"").concat(name, "Module\")\n\n    ").concat(viewNames.map(function (n) { return "View(".concat(n, ".self)"); }).join('\n\n'), "\n  }\n}\n");
}
function buildImportFile(viewName) {
    return "// Autogenerated by expo nativegen\n\nimport { requireNativeView } from 'expo';\n\ninterface Props {}\n\nconst NativeView = requireNativeView<Props>('".concat(name, "Module', '").concat(viewName, "');\n\nexport default function ").concat(viewName, "(props: Props) {\n  return <NativeView {...props} />;\n}\n");
}
function buildPodspec() {
    return "require 'json'\nPod::Spec.new do |s|\n  s.name           = '".concat(name, "Module'\n  s.version        = '0.0.1'\n  s.summary        = 'A module expo'\n  s.description    = 'A module expo'\n  s.license        = 'A module expo'\n  s.author         = 'A module expo'\n  s.homepage       = 'A module expo'\n  s.platforms      = {\n    :ios => '15.1',\n    :tvos => '15.1'\n  }\n  s.swift_version  = '5.4'\n  s.source         = { git: 'https://github.com/expo/expo.git' }\n  s.static_framework = true\n\n  s.dependency 'ExpoModulesCore'\n\n  # Swift/Objective-C compatibility\n  s.pod_target_xcconfig = {\n    'DEFINES_MODULE' => 'YES'\n  }\n\n  s.source_files = \"**/*.{h,m,mm,swift,hpp,cpp}\"\nend\n");
}
function main() {
    console.log('linking native files');
    nativegen();
    console.log('installing pods');
    spawnAsync('npx', ['pod-install']);
}
function nativegen() {
    var root = path.join(path.dirname(findNearestPackageJson(__dirname)));
    // const targetFolder = path.join(config.modRequest.projectRoot, 'ios');
    // Use glob to find all `.swift` files in the src folder
    var result = __spreadArray(__spreadArray([], (0, glob_1.globSync)(path.join(root, 'app', '*.swift')), true), (0, glob_1.globSync)(path.join(root, 'src', '*.swift')), true);
    // if (err) throw new Error(`Error finding Swift files: ${err}`);
    var modulePath = path.join(root, 'modules', name.toLowerCase());
    fs.rmSync(modulePath, { force: true, recursive: true });
    fs.mkdirSync(modulePath, { recursive: true });
    var config = {
        platforms: ['apple', 'android'],
        apple: {
            //   modules: result.map((file) => './' + path.relative(root, file)),
            modules: ["".concat(name, "Module")],
        },
        // android: {
        //   modules: ['expo.modules.inline.BenchmarkingExpoModule'],
        // },
    };
    fs.writeFileSync(path.join(modulePath, 'expo-module.config.json'), JSON.stringify(config, null, 2));
    fs.mkdirSync(path.join(modulePath, 'ios'), { recursive: true });
    fs.writeFileSync(path.join(modulePath, 'ios', "".concat(name, "Module.podspec")), buildPodspec());
    fs.writeFileSync(path.join(modulePath, 'ios', "".concat(name, "Module.swift")), buildInlineModule(result.map(function (r) { return path.basename(r, path.extname(r)); })));
    result.forEach(function (r) {
        fs.symlinkSync(r, path.join(modulePath, 'ios', path.basename(r)));
    });
    console.log('creating typescript wrappers');
    result.forEach(function (r) {
        fs.writeFileSync(r.replace('.swift', '.tsx'), buildImportFile(path.basename(r, path.extname(r))));
    });
}
function findNearestPackageJson(startDir) {
    var currentDir = startDir;
    // Continue until the root directory is reached
    while (path.dirname(currentDir) !== currentDir) {
        var potentialPath = path.join(currentDir, 'package.json');
        // Check if a package.json exists at this path
        if (fs.existsSync(potentialPath)) {
            return potentialPath;
        }
        // Move to the parent directory
        currentDir = path.dirname(currentDir);
    }
    // If no package.json is found throughout the tree, return null or throw an error
    return null;
}
main();
