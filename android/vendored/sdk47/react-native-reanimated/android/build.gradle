import com.android.Version
import org.apache.tools.ant.filters.ReplaceTokens

import java.nio.file.Paths

/**
 * Finds the path of the installed npm package with the given name using Node's
 * module resolution algorithm, which searches "node_modules" directories up to
 * the file system root. This handles various cases, including:
 *
 *   - Working in the open-source RN repo:
 *       Gradle: /path/to/versioned-react-native/ReactAndroid
 *       Node module: /path/to/versioned-react-native/node_modules/[package]
 *
 *   - Installing RN as a dependency of an app and searching for hoisted
 *     dependencies:
 *       Gradle: /path/to/app/node_modules/versioned-react-native/ReactAndroid
 *       Node module: /path/to/app/node_modules/[package]
 *
 *   - Working in a larger repo (e.g., Facebook) that contains RN:
 *       Gradle: /path/to/repo/path/to/versioned-react-native/ReactAndroid
 *       Node module: /path/to/repo/node_modules/[package]
 *
 * The search begins at the given base directory (a File object). The returned
 * path is a string.
 */
static def findNodeModulePath(baseDir, packageName) {
    def basePath = baseDir.toPath().normalize()
    // Node's module resolution algorithm searches up to the root directory,
    // after which the base path will be null
    while (basePath) {
        def candidatePath = Paths.get(basePath.toString(), "node_modules", packageName)
        if (candidatePath.toFile().exists()) {
            return candidatePath.toString()
        }
        basePath = basePath.getParent()
    }
    return null
}

def safeExtGet(prop, fallback) {
    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
}

def safeAppExtGet(prop, fallback) {
    def appProject = null
    try {
        appProject = project(":app")
    } catch(Exception e) {
        return fallback
    }
    appProject?.ext?.has(prop) ? appProject.ext.get(prop) : fallback
}

def resolveBuildType() {
    Gradle gradle = getGradle()
    String tskReqStr = gradle.getStartParameter().getTaskRequests()['args'].toString()
    
    return tskReqStr.contains('Release') ? 'release' : 'debug'
}

def resolveClientSideBuild() {
    def clientSideBuild = System.getenv("CLIENT_SIDE_BUILD")
    if (clientSideBuild != null) {
        return clientSideBuild == "True"
    }

    if (hasProperty("clientSideBuild")) {
        return property("clientSideBuild") == "true"
    }

    if (isDeveloperMode()) {
        return false
    }

    return true
}

def isDeveloperMode() {
    // developer mode, to run Example app
    return safeAppExtGet("isReanimatedExampleApp", false) || System.getenv("REANIMATED_PACKAGE_BUILD") == "1"
}

def isNewArchitectureEnabled() {
    // To opt-in for the New Architecture, you can either:
    // - Set `newArchEnabled` to true inside the `gradle.properties` file
    // - Invoke gradle with `-newArchEnabled=true`
    // - Set an environment variable `ORG_GRADLE_PROJECT_newArchEnabled=true`
    return project.hasProperty("newArchEnabled") && project.newArchEnabled == "true"
}

def resolveReactNativeDirectory() {
    def reactNativeLocation = safeAppExtGet("REACT_NATIVE_NODE_MODULES_DIR", null)
    if (reactNativeLocation != null) {
        return file(reactNativeLocation)
    }

    if (isDeveloperMode()) {
        return file("$projectDir/../${getPlaygroundAppName()}/node_modules/react-native")
    }

    // monorepo workaround
    // react-native can be hoisted or in project's own node_modules
    def reactNativeFromProjectNodeModules = file("${rootProject.projectDir}/../node_modules/react-native")
    if (reactNativeFromProjectNodeModules.exists()) {
        return reactNativeFromProjectNodeModules
    }
    
    def reactNativeFromNodeModulesWithReanimated = file("${projectDir}/../../react-native")
    if (reactNativeFromNodeModulesWithReanimated.exists()) {
        return reactNativeFromNodeModulesWithReanimated
    }

    throw new Exception(
        "[Reanimated] Unable to resolve react-native location in " +
        "node_modules. You should project extension property (in app/build.gradle) " +
        "`REACT_NATIVE_NODE_MODULES_DIR` with path to react-native."
    )
}

def getPlaygroundAppName() { // only for the development
    String playgroundAppName = ""
    try {
        rootProject.getSubprojects().forEach({project ->
            if (project.plugins.hasPlugin("com.android.application")) {
                var projectCatalogAbsolutePath = project.projectDir.toString().replace("/android/app", "")
                var slashPosition = projectCatalogAbsolutePath.lastIndexOf("/")
                playgroundAppName = projectCatalogAbsolutePath.substring(slashPosition + 1)
            }
        })
    } catch(_) {
        return "NOT_FOUND"
    }
    return playgroundAppName
}

def shouldAssertNoMultipleInstances() {
  if (rootProject.hasProperty("disableMultipleInstancesCheck")) {
    return rootProject.property("disableMultipleInstancesCheck") != "true"
  } else {
    return true
  }
}

def findReanimatedInstancesForPath(String path) {
    return fileTree(path) {
        include "**/react-native-reanimated/package.json"
        exclude "**/.yarn/**"
        exclude {{ file, attr -> attr.isSymbolicLink() }}
    }.files
}

def assertNoMultipleInstances() {
    // Assert there are no multiple installations of Reanimated
    Set<File> files
    if (projectDir.path.contains(rootDir.parent)) {
        // standard app
        files = findReanimatedInstancesForPath(rootDir.parent + "/node_modules")
    } else {
        // monorepo
        files = findReanimatedInstancesForPath(rootDir.parent + "/node_modules")
        files.addAll(
            findReanimatedInstancesForPath(file(projectDir.parent).parent)
        )
    }
    if (files.size() > 1) {
        String parsedLocation = files.stream().map({
            File file -> "- " + file.toString().replace("/package.json", "")
        }).collect().join("\n")
        String exceptionMessage = "\nMultiple versions of Reanimated were detected. Only one " +
            "instance of react-native-reanimated can be installed in a project. You need to " +
            "resolve the conflict manually. Check out the documentation: " +
            "https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/" +
            "troubleshooting#multiple-versions-of-reanimated-were-detected \n\nConflict " +
            "between: \n" + parsedLocation + "\n";
        throw new Exception(exceptionMessage)
    }
}

boolean CLIENT_SIDE_BUILD = resolveClientSideBuild()
if (CLIENT_SIDE_BUILD) {
    configurations.maybeCreate("default")
}

def reactNativeRootDir = Paths.get(projectDir.getPath(), '../../../../versioned-react-native').toFile()

def reactProperties = new Properties()
file("$reactNativeRootDir/../../react-native-lab/react-native/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }

def BOOST_VERSION = reactProperties.getProperty("BOOST_VERSION")
def DOUBLE_CONVERSION_VERSION = reactProperties.getProperty("DOUBLE_CONVERSION_VERSION")
def FOLLY_VERSION = reactProperties.getProperty("FOLLY_VERSION")
def GLOG_VERSION = reactProperties.getProperty("GLOG_VERSION")
def REACT_NATIVE_VERSION = reactProperties.getProperty("VERSION_NAME")
def REACT_NATIVE_MINOR_VERSION = REACT_NATIVE_VERSION.split("\\.")[1].toInteger()
def FBJNI_VERSION = "0.3.0"
def REANIMATED_PACKAGE_BUILD = System.getenv("REANIMATED_PACKAGE_BUILD")

// We download various C++ open-source dependencies into downloads.
// We then copy both the downloaded code and our custom makefiles and headers into third-party-ndk.
// After that we build native code from src/main/jni with module path pointing at third-party-ndk.

def customDownloadsDir = System.getenv("REACT_NATIVE_DOWNLOADS_DIR")
def downloadsDir = customDownloadsDir ? new File(customDownloadsDir) : new File("$buildDir/downloads")
def thirdPartyNdkDir = new File("$buildDir/third-party-ndk")

def reactNativeThirdParty = new File("$reactNativeRootDir/ReactAndroid/src/main/jni/third-party")
def reactNativeAndroidDownloadDir = new File("$reactNativeRootDir/ReactAndroid/build/downloads")

def _stackProtectorFlag = true

def JS_RUNTIME = {
    return "hermes" // Expo Go always uses hermes

    // Returns the js runtime explicitly requested in the environment variable
    if (System.getenv("JS_RUNTIME")) {
        return System.getenv("JS_RUNTIME")
    }

    // Detect js runtime from project setup
    def defaultRuntimeType = "jsc";
    def v8Project = rootProject.getSubprojects().find { project -> project.name == "react-native-v8" }
    if (v8Project != null) {
        return "v8"
    }
    def appProject = findProject(":app") ? project(":app") : null
    return appProject?.ext?.react?.enableHermes ? "hermes" : defaultRuntimeType
}.call()

def jsRuntimeDir = {
    if (JS_RUNTIME == "hermes") {
        if (REACT_NATIVE_MINOR_VERSION >= 69) {
            return Paths.get(reactNativeRootDir.path, "sdks", "hermes")
        } else {
            return Paths.get(reactNativeRootDir.path, "..", "hermes-engine")
        }
    } else if (JS_RUNTIME == "v8") {
        return findProject(":react-native-v8").getProjectDir().getParent()
    } else {
        return Paths.get(reactNativeRootDir.path, "ReactCommon", "jsi")
    }
}.call()

def reactNativeArchitectures() {
    def value = project.getProperties().get("reactNativeArchitectures")
    return value ? value.split(",") : ["armeabi-v7a", "x86", "x86_64", "arm64-v8a"]
}

def detectAAR(Integer rnMinorVersion, String engine) { // Reanimated2 only
    def rnMinorVersionCopy = rnMinorVersion
    def aar = file("react-native-reanimated-${rnMinorVersionCopy}-${engine}.aar")

    if (aar.exists()) {
        println "AAR for react-native-reanimated has been found\n$aar"
        return aar
    } else {
        while (!aar.exists() && rnMinorVersionCopy >= 63) {
            rnMinorVersionCopy -= 1
            aar = file("react-native-reanimated-${rnMinorVersionCopy}-${engine}.aar")
        }

        if (rnMinorVersionCopy < 63) {
            println "No AAR for react-native-reanimated found. Attempting to build from source."
        } else { // aar exists, but was build for lower react-native version
            println "\n\n\n"
            println "****************************************************************************************"
            println "\n\n\n"
            println "WARNING reanimated - no version-specific reanimated AAR for react-native version $minor found."
            println "Falling back to AAR for react-native version $rnMinorVersionCopy."
            println "The react-native JSI interface is not ABI-safe yet, this may result in crashes."
            println "Please post a pull request to implement support for react-native version $minor to the reanimated repo."
            println "Thanks!"
            println "\n\n\n"
            println "****************************************************************************************"

            return aar
        }
    }
    return null
}

def isUserDemandToBuildFromSource() { // Reanimated2 only
    def buildFromSourceConf = false
    rootProject.getSubprojects().forEach({project ->
        if (project.plugins.hasPlugin("com.android.application")) {
            if (
            project.ext.has("reanimated")
                    && project.ext.reanimated.buildFromSource
            ) {
                buildFromSourceConf = true
            }
        }
    })
    return buildFromSourceConf
}

def shouldBuildFromSource(aar, jsRuntimeName) { // Reanimated2 only
    if (jsRuntimeName == "v8") {
        return true
    }
    else if (isDeveloperMode()) {
        // Example app
        return true
    }
    else if (isUserDemandToBuildFromSource()) {
        // on user demand
        return true
    }
    else if (aar != null) {
        // when binary exist
        return false
    }
    // when binary is not found
    return true
}

def getTaskByPath(
        project,
        String appName,
        String secondPart,
        String flavorString,
        String lastPart
) {  // Reanimated2 only
    String pathName = "${appName}:${secondPart}${flavorString}${lastPart}"
    Task task = project.getTasks().findByPath(pathName)
    if (task != null) {
        return task
    }
    pathName = "${appName}:${secondPart}${flavorString.capitalize()}${lastPart}"
    return project.getTasks().findByPath(pathName)
}

def aar = detectAAR(REACT_NATIVE_MINOR_VERSION, JS_RUNTIME)
boolean BUILD_FROM_SOURCE = shouldBuildFromSource(aar, JS_RUNTIME)

if (!BUILD_FROM_SOURCE && !isNewArchitectureEnabled()) { // Reanimated2 only
    if (REACT_NATIVE_MINOR_VERSION < 65) {
        tasks.register("replaceSoTaskDebug", replaceSoTask)
        tasks.register("replaceSoTaskRelease", replaceSoTask)
        Task replaceSoTaskDebug = project.getTasks().findByPath(":react-native-reanimated:replaceSoTaskDebug")
        Task replaceSoTaskRelease = project.getTasks().findByPath(":react-native-reanimated:replaceSoTaskRelease")

        if (replaceSoTaskDebug != null && replaceSoTaskRelease != null) {
            rootProject.getSubprojects().forEach({project ->
                if (project.plugins.hasPlugin("com.android.application") && project.getProperties().get("android")) {
                    def projectProperties = project.getProperties()
                    def flavorString = getCurrentFlavor()
                    def reanimatedConf = projectProperties.get("reanimated")

                    if (
                    flavorString != "NOT-FOUND"
                            && (!reanimatedConf || (reanimatedConf && !reanimatedConf.get("enablePackagingOptions")))
                    ) {
                        replaceSoTask.appName = projectProperties.path
                        replaceSoTask.buildDir = projectProperties.buildDir
                        def appName = projectProperties.path

                        Task debugNativeLibsTask = getTaskByPath(project, appName, "merge", flavorString, "DebugNativeLibs")
                        Task debugDebugSymbolsTask = getTaskByPath(project, appName, "strip", flavorString, "DebugDebugSymbols")
                        Task releaseNativeLibsTask = getTaskByPath(project, appName, "merge", flavorString, "ReleaseNativeLibs")
                        Task releaseDebugSymbolsTask = getTaskByPath(project, appName, "strip", flavorString, "ReleaseDebugSymbols")
                        Task debugTask = getTaskByPath(project, appName, "package", flavorString, "Debug")
                        Task releaseTask = getTaskByPath(project, appName, "package", flavorString, "Release")

                        if (
                        debugNativeLibsTask != null && debugDebugSymbolsTask != null
                                && releaseNativeLibsTask != null && releaseDebugSymbolsTask != null
                                && debugTask != null && releaseTask != null
                        ) {
                            replaceSoTaskDebug.dependsOn(debugNativeLibsTask, debugDebugSymbolsTask)
                            debugTask.dependsOn(replaceSoTaskDebug)
                            replaceSoTaskRelease.dependsOn(releaseNativeLibsTask, releaseDebugSymbolsTask)
                            releaseTask.dependsOn(replaceSoTaskRelease)
                        }
                    }
                }
            })
        }
    }

    artifacts.add("default", aar)
}

// end if already loaded aar
if (!BUILD_FROM_SOURCE) {
    return
}
// You need to have following folders in this directory:
//   - boost_1_63_0
//   - double-conversion-1.1.6
//   - folly-deprecate-dynamic-initializer
//   - glog-0.3.5
def dependenciesPath = System.getenv("REACT_NATIVE_DEPENDENCIES")

// The Boost library is a very large download (>100MB).
// If Boost is already present on your system, define the REACT_NATIVE_BOOST_PATH env variable
// and the build will use that.
def boostPath = dependenciesPath ?: System.getenv("REACT_NATIVE_BOOST_PATH")

def follyReplaceContent = '''
  ssize_t r;
  do {
    r = open(name, flags, mode);
  } while (r == -1 && errno == EINTR);
  return r;
'''

buildscript {
    repositories {
        google()
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath "com.android.tools.build:gradle:7.3.0"
        classpath "de.undercouch:gradle-download-task:5.0.1"
        classpath "com.diffplug.spotless:spotless-plugin-gradle:6.11.0"
    }
}

if (project == rootProject) {
    apply from: "spotless.gradle"
}

apply plugin: "com.android.library"
apply plugin: "maven-publish"
apply plugin: "de.undercouch.download"

android {
    compileSdkVersion safeExtGet("compileSdkVersion", 30)
    defaultConfig {
        minSdkVersion safeExtGet("minSdkVersion", 16)
        targetSdkVersion safeExtGet("targetSdkVersion", 30)
        versionCode 1
        versionName "1.0"
        buildConfigField "boolean", "IS_NEW_ARCHITECTURE_ENABLED", isNewArchitectureEnabled().toString()
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_STL=c++_shared",
                        "-DREACT_NATIVE_MINOR_VERSION=${REACT_NATIVE_MINOR_VERSION}",
                        "-DANDROID_TOOLCHAIN=clang",
                        "-DBOOST_VERSION=${BOOST_VERSION}",
                        "-DREACT_NATIVE_DIR=${reactNativeRootDir.path}",
                        "-DJS_RUNTIME=${JS_RUNTIME}",
                        "-DJS_RUNTIME_DIR=${jsRuntimeDir}",
                        "-DCLIENT_SIDE_BUILD=${CLIENT_SIDE_BUILD}",
                        "-DIS_NEW_ARCHITECTURE_ENABLED=${isNewArchitectureEnabled()}",
                        "-DPLAYGROUND_APP_NAME=${getPlaygroundAppName()}",
                        "-DREANIMATED_PACKAGE_BUILD=${REANIMATED_PACKAGE_BUILD}"
                abiFilters (*reactNativeArchitectures())
                _stackProtectorFlag ? (cppFlags("-fstack-protector-all")) : null
            }
        }

        buildConfigField("boolean", "IS_INTERNAL_BUILD", "false")
        buildConfigField("int", "EXOPACKAGE_FLAGS", "0")
        buildConfigField("int", "REACT_NATIVE_MINOR_VERSION", REACT_NATIVE_MINOR_VERSION.toString())
    }
    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
    buildTypes {
        debug {
            externalNativeBuild {
                cmake {
                    if (JS_RUNTIME == "hermes") {
                        arguments "-DHERMES_ENABLE_DEBUGGER=1"
                    } else {
                        arguments "-DHERMES_ENABLE_DEBUGGER=0"
                    }
                }
            }
        }
        release {
            externalNativeBuild {
                cmake {
                    arguments "-DHERMES_ENABLE_DEBUGGER=0"
                }
            }
        }
    }
    lintOptions {
        abortOnError false
    }
    packagingOptions {
        doNotStrip resolveBuildType() == 'debug' ? "**/**/*.so" : ''
        excludes = [
                "META-INF",
                "META-INF/**",
                "**/libc++_shared.so",
                "**/libfbjni.so",
                "**/libjsi.so",
                "**/libfolly_json.so",
                "**/libfolly_runtime.so",
                "**/libglog.so",
                "**/libhermes.so",
                "**/libhermes-executor-debug.so",
                "**/libreactnativejni.so",
                "**/libjscexecutor.so",
                "**/libv8executor.so",
        ]
    }
    tasks.withType(JavaCompile) {
        compileTask ->
            compileTask.dependsOn(packageNdkLibs)
    }
    configurations {
        extractHeaders
        extractSO
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    packagingOptions {
        // For some reason gradle only complains about the duplicated version of librrc_root and libreact_render libraries
        // while there are more libraries copied in intermediates folder of the lib build directory, we exclude
        // only the ones that make the build fail (ideally we should only include libreanimated but we
        // are only allowed to specify exlude patterns)
        exclude "**/libreact_render*.so"
        exclude "**/librrc_root.so"
    }
    sourceSets.main {
        java {
            if (isNewArchitectureEnabled()) {
                srcDirs += [
                        "src/fabric/java",
                ]
            } else {
                srcDirs += [
                        "src/paper/java",
                ]
            }
        }
    }
}

def assertionTask = task assertNoMultipleInstancesTask {
    onlyIf { shouldAssertNoMultipleInstances() && CLIENT_SIDE_BUILD }
    doFirst {
        assertNoMultipleInstances()
    }
}

tasks.preBuild {
    dependsOn assertionTask
}

task cleanCmakeCache() {
    tasks.getByName("clean").dependsOn(cleanCmakeCache)
    doFirst {
        delete "${projectDir}/.cxx"
    }
}

task printVersions {
    println "Android gradle plugin: ${Version.ANDROID_GRADLE_PLUGIN_VERSION}"
    println "Gradle: ${project.gradle.gradleVersion}"
}

task Log {
    println("building Reanimated2")
}

task applyJavaPatches(type: Copy) {
    def patchDirectory = file("${projectDir}/rnVersionPatch/${REACT_NATIVE_MINOR_VERSION}")
    if (patchDirectory.exists()) {
        from ("${patchDirectory}") {
            include "**/*.java"
        }
        into ("${projectDir}/src/main/java/com/swmansion/reanimated")
    }
}

task createNativeDepsDirectories(dependsOn: applyJavaPatches) {
    downloadsDir.mkdirs()
    thirdPartyNdkDir.mkdirs()
}

def resolveTaskFactory(String taskName, String artifactLocalName, File reactNativeAndroidDownloadDir, File reanimatedDownloadDir) {
    return tasks.create(name: taskName, dependsOn: createNativeDepsDirectories, type: Copy) {
        from reactNativeAndroidDownloadDir
        include artifactLocalName
        into reanimatedDownloadDir

        onlyIf {
            // First we check whether the file is already in our download directory
            if (file("$reanimatedDownloadDir/$artifactLocalName").isFile()) {
                return false
            }

            // If it is not the case we check whether it was downloaded by ReactAndroid project
            if (file("$reactNativeAndroidDownloadDir/$artifactLocalName").isFile()) {
                return true
            }

            return false
        }
    }
}

Task resolveBoost = resolveTaskFactory("resolveBoost", "boost_${BOOST_VERSION}.tar.gz", reactNativeAndroidDownloadDir, downloadsDir)
Task resolveDoubleConversion = resolveTaskFactory(
    "resolveDoubleConversion",
    "double-conversion-${DOUBLE_CONVERSION_VERSION}.tar.gz",
    reactNativeAndroidDownloadDir,
    downloadsDir
)
Task resolveFolly = resolveTaskFactory("resolveFolly", "folly-${FOLLY_VERSION}.tar.gz", reactNativeAndroidDownloadDir, downloadsDir)
Task resolveGlog = resolveTaskFactory("resolveGlog", "glog-${GLOG_VERSION}.tar.gz", reactNativeAndroidDownloadDir, downloadsDir)

if (isNewArchitectureEnabled()) {
    def reactNativeAndroidProject = findProject(":ReactAndroid")
    if (reactNativeAndroidProject != null) {
        reactNativeAndroidProject.afterEvaluate {
            def resolveTasks = [resolveBoost, resolveGlog, resolveDoubleConversion, resolveFolly]
            resolveTasks.forEach({ task ->
                String reactAndroidDownloadTaskName = "download" + task.name.replace("resolve", "")
                def reactAndroidDownloadTask = reactNativeAndroidProject.getTasks().findByName(reactAndroidDownloadTaskName)
                if (reactAndroidDownloadTask != null) {
                    task.dependsOn(reactAndroidDownloadTask)
                } else {
                    logger.warn("[Reanimated] Failed to find task named `$reactAndroidDownloadTaskName` in `:ReactAndroid` project." +
                            " Explicit dependency between it and $task.name task can not be set.")
                }
            })
        }
    } else {
        throw new GradleScriptException("[Reanimated] Failed to find `:ReactAndroid` project. Explicit dependency between download tasks can not be set.")
    }
}

task downloadBoost(dependsOn: resolveBoost, type: Download) {
    def transformedVersion = BOOST_VERSION.replace("_", ".")
    def artifactLocalName = "boost_${BOOST_VERSION}.tar.gz"
    def srcUrl = "https://boostorg.jfrog.io/artifactory/main/release/${transformedVersion}/source/boost_${BOOST_VERSION}.tar.gz"
    if (REACT_NATIVE_MINOR_VERSION < 69) {
        srcUrl = "https://github.com/react-native-community/boost-for-react-native/releases/download/v${transformedVersion}-0/boost_${BOOST_VERSION}.tar.gz"
    }
    src(srcUrl)
    onlyIfNewer(true)
    overwrite(false)
    dest(new File(downloadsDir, artifactLocalName))
}

task prepareBoost(dependsOn: boostPath ? [] : [downloadBoost], type: Copy) {
    from(boostPath ?: tarTree(resources.gzip(downloadBoost.dest)))
    from("$reactNativeThirdParty/boost/Android.mk")
    include("Android.mk", "boost_${BOOST_VERSION}/boost/**/*.hpp", "boost/boost/**/*.hpp")
    includeEmptyDirs = false
    into("$thirdPartyNdkDir/boost")
    doLast {
        file("$thirdPartyNdkDir/boost/boost").renameTo("$thirdPartyNdkDir/boost/boost_${BOOST_VERSION}")
    }
}

task downloadDoubleConversion(dependsOn: resolveDoubleConversion, type: Download) {
    src("https://github.com/google/double-conversion/archive/v${DOUBLE_CONVERSION_VERSION}.tar.gz")
    onlyIfNewer(true)
    overwrite(false)
    dest(new File(downloadsDir, "double-conversion-${DOUBLE_CONVERSION_VERSION}.tar.gz"))
}

task prepareDoubleConversion(dependsOn: dependenciesPath ? [] : [downloadDoubleConversion], type: Copy) {
    from(dependenciesPath ?: tarTree(downloadDoubleConversion.dest))
    from("$reactNativeThirdParty/double-conversion/Android.mk")
    include("double-conversion-${DOUBLE_CONVERSION_VERSION}/src/**/*", "Android.mk")
    filesMatching("*/src/**/*", { fname -> fname.path = "double-conversion/${fname.name}" })
    includeEmptyDirs = false
    into("$thirdPartyNdkDir/double-conversion")
}

task downloadFolly(dependsOn: resolveFolly, type: Download) {
    src("https://github.com/facebook/folly/archive/v${FOLLY_VERSION}.tar.gz")
    onlyIfNewer(true)
    overwrite(false)
    dest(new File(downloadsDir, "folly-${FOLLY_VERSION}.tar.gz"))
}

task prepareFolly(dependsOn: dependenciesPath ? [] : [downloadFolly], type: Copy) {
    from(dependenciesPath ?: tarTree(downloadFolly.dest))
    from("$reactNativeThirdParty/folly/Android.mk")
    include("folly-${FOLLY_VERSION}/folly/**/*", "Android.mk")
    eachFile { fname -> fname.path = (fname.path - "folly-${FOLLY_VERSION}/") }
    // Fixes problem with Folly failing to build on certain systems. See
    // https://github.com/software-mansion/react-native-reanimated/issues/1024
    filter { line -> line.replaceAll("return int\\(wrapNoInt\\(open, name, flags, mode\\)\\);", follyReplaceContent) }
    includeEmptyDirs = false
    into("$thirdPartyNdkDir/folly")
}

task downloadGlog(dependsOn: resolveGlog, type: Download) {
    src("https://github.com/google/glog/archive/v${GLOG_VERSION}.tar.gz")
    onlyIfNewer(true)
    overwrite(false)
    dest(new File(downloadsDir, "glog-${GLOG_VERSION}.tar.gz"))
}

// Prepare glog sources to be compiled, this task will perform steps that normally should've been
// executed by automake. This way we can avoid dependencies on make/automake
task prepareGlog(dependsOn: dependenciesPath ? [] : [downloadGlog], type: Copy) {
    duplicatesStrategy = "include"
    from(dependenciesPath ?: tarTree(downloadGlog.dest))
    from("$reactNativeThirdParty/glog/")
    include("glog-${GLOG_VERSION}/src/**/*", "Android.mk", "config.h")
    includeEmptyDirs = false
    filesMatching("**/*.h.in") {
        filter(ReplaceTokens, tokens: [
                ac_cv_have_unistd_h           : "1",
                ac_cv_have_stdint_h           : "1",
                ac_cv_have_systypes_h         : "1",
                ac_cv_have_inttypes_h         : "1",
                ac_cv_have_libgflags          : "0",
                ac_google_start_namespace     : "namespace google {",
                ac_cv_have_uint16_t           : "1",
                ac_cv_have_u_int16_t          : "1",
                ac_cv_have___uint16           : "0",
                ac_google_end_namespace       : "}",
                ac_cv_have___builtin_expect   : "1",
                ac_google_namespace           : "google",
                ac_cv___attribute___noinline  : "__attribute__ ((noinline))",
                ac_cv___attribute___noreturn  : "__attribute__ ((noreturn))",
                ac_cv___attribute___printf_4_5: "__attribute__((__format__ (__printf__, 4, 5)))"
        ])
        it.path = (it.name - ".in")
    }
    into("$thirdPartyNdkDir/glog")

    doLast {
        copy {
            from(fileTree(dir: "$thirdPartyNdkDir/glog", includes: ["stl_logging.h", "logging.h", "raw_logging.h", "vlog_is_on.h", "**/src/glog/log_severity.h"]).files)
            includeEmptyDirs = false
            into("$thirdPartyNdkDir/glog/exported/glog")
        }
    }
}

/*
Reanimated includes "hermes/hermes.h" header file in `NativeProxy.cpp`.
Previously, we used header files from `hermes-engine` package in `node_modules`.
Starting from React Native 0.69, Hermes is no longer distributed as package on NPM.
On the new architecture, Hermes is downloaded from GitHub and then compiled from sources.
However, on the old architecture, we need to download Hermes header files on our own
as well as unzip Hermes AAR in order to obtain `libhermes.so` shared library.
For more details, see https://reactnative.dev/architecture/bundled-hermes
or https://github.com/reactwg/react-native-new-architecture/discussions/4
*/
if (REACT_NATIVE_MINOR_VERSION >= 69 && !isNewArchitectureEnabled()) {
    // copied from `react-native/ReactAndroid/hermes-engine/build.gradle`

    def downloadDir = customDownloadsDir ? new File(customDownloadsDir) : new File(reactNativeRootDir, "sdks/download")

    // By default we are going to download and unzip hermes inside the /sdks/hermes folder
    // but you can provide an override for where the hermes source code is located.
    def hermesDir = System.getenv("REACT_NATIVE_OVERRIDE_HERMES_DIR") ?: new File(reactNativeRootDir, "sdks/hermes")

    def hermesVersion = "main"
    def hermesVersionFile = new File(reactNativeRootDir, "sdks/.hermesversion")
    if (hermesVersionFile.exists()) {
        hermesVersion = hermesVersionFile.text
    }

    task downloadHermes(type: Download) {
        src("https://github.com/facebook/hermes/tarball/${hermesVersion}")
        onlyIfNewer(true)
        overwrite(false)
        dest(new File(downloadDir, "hermes.tar.gz"))
    }

    task unzipHermes(dependsOn: downloadHermes, type: Copy) {
        from(tarTree(downloadHermes.dest)) {
            eachFile { file ->
                // We flatten the unzip as the tarball contains a `facebook-hermes-<SHA>`
                // folder at the top level.
                if (file.relativePath.segments.size() > 1) {
                    file.relativePath = new RelativePath(!file.isDirectory(), file.relativePath.segments.drop(1))
                }
            }
        }
        into(hermesDir)
    }
}

task prepareHermes() {
    return
    if (REACT_NATIVE_MINOR_VERSION >= 69) {
        if (!isNewArchitectureEnabled()) {
            dependsOn(unzipHermes)
        }

        doLast {
            // e.g. hermes-engine-0.70.0-rc.1-debug.aar
            def hermesAAR = file(
                "$reactNativeRootDir/android/com/facebook/react/hermes-engine/" +
                "${REACT_NATIVE_VERSION}/hermes-engine-${REACT_NATIVE_VERSION}-" +
                "${resolveBuildType()}.aar"
            )
            if (!hermesAAR.exists()) {
                throw new GradleScriptException("Could not find hermes-engine AAR", null)
            }

            def soFiles = zipTree(hermesAAR).matching({ it.include "**/*.so" })

            copy {
                from soFiles
                from "$reactNativeRootDir/ReactAndroid/src/main/jni/first-party/hermes/Android.mk"
                into "$thirdPartyNdkDir/hermes"
            }
        }
    } else {
        doLast {
            def hermesPackagePath = findNodeModulePath(projectDir, "hermes-engine")
            if (!hermesPackagePath) {
                throw new GradleScriptException("Could not find the hermes-engine npm package", null)
            }

            def hermesAAR = file("$hermesPackagePath/android/hermes-${resolveBuildType()}.aar") // e.g. hermes-debug.aar
            if (!hermesAAR.exists()) {
                throw new GradleScriptException("The hermes-engine npm package is missing \"android/hermes-${resolveBuildType()}.aar\"", null)
            }

            def soFiles = zipTree(hermesAAR).matching({ it.include "**/*.so" })

            copy {
                from soFiles
                from "$reactNativeRootDir/ReactAndroid/src/main/jni/first-party/hermes/Android.mk"
                into "$thirdPartyNdkDir/hermes"
            }
        }
    }
}

task prepareJSC {
    doLast {
        def jscPackagePath = findNodeModulePath(projectDir, "jsc-android")
        if (!jscPackagePath) {
            throw new GradleScriptException("Could not find the jsc-android npm package", null)
        }

        def jscDist = file("$jscPackagePath/dist")
        if (!jscDist.exists()) {
            throw new GradleScriptException("The jsc-android npm package is missing its \"dist\" directory", null)
        }

        def jscAAR = fileTree(jscDist).matching({ it.include "**/android-jsc/**/*.aar" }).singleFile
        def soFiles = zipTree(jscAAR).matching({ it.include "**/*.so" })

        def headerFiles = fileTree(jscDist).matching({ it.include "**/include/*.h" })

        copy {
            from(soFiles)
            from(headerFiles)
            from("$reactNativeRootDir/ReactAndroid/src/main/jni/third-party/jsc/Android.mk")

            filesMatching("**/*.h", { it.path = "JavaScriptCore/${it.name}" })

            includeEmptyDirs(false)
            into("$thirdPartyNdkDir/jsc")
        }
    }
}

task extractAARHeaders {
    doLast {
        configurations.extractHeaders.files.each {
            def file = it.absoluteFile
            def packageName = file.name.tokenize('-')[0]
            copy {
                from zipTree(file)
                into "$reactNativeRootDir/ReactAndroid/src/main/jni/first-party/$packageName/headers"
                include "**/*.h"
            }
        }
    }
}

task extractSOFiles {
    doLast {
        configurations.extractSO.files.each {
            def file = it.absoluteFile
            def packageName = file.name.tokenize('-')[0]
            copy {
                from zipTree(file)
                into "$reactNativeRootDir/ReactAndroid/src/main/jni/first-party/$packageName/"
                include "jni/**/*.so"
            }
        }
    }
}

task packageNdkLibs(type: Copy) {
    from("$buildDir/reanimated-ndk/all")
    include("**/libreanimated.so")
    if(REACT_NATIVE_MINOR_VERSION < 64) {
        include("**/libturbomodulejsijni.so")
    }
    into("$projectDir/src/main/jniLibs")
}

repositories {
    mavenCentral()
    mavenLocal()
    maven {
        // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm
        url "$reactNativeRootDir/android"
    }
    maven {
        // Android JSC is installed from npm
        url "$reactNativeRootDir/../jsc-android/dist"
    }
    google()
}

dependencies {
    // noinspection GradleDynamicVersion
    implementation "com.facebook.yoga:proguard-annotations:1.19.0"
    if (isDeveloperMode() && !isNewArchitectureEnabled()) {
        implementation "com.facebook.fbjni:fbjni:" + FBJNI_VERSION
    }
    else {
        // implementation "com.facebook.fbjni:fbjni-java-only:" + FBJNI_VERSION
    }
    implementation 'host.exp:reactandroid-abi47_0_0:1.0.0'
    compileOnly 'com.facebook.fbjni:fbjni:+'
    compileOnly 'com.facebook.yoga:proguard-annotations:+'
    compileOnly 'com.facebook.soloader:soloader:+'
    compileOnly 'androidx.annotation:annotation:+'
    compileOnly 'com.google.code.findbugs:jsr305:+'
    compileOnly 'androidx.appcompat:appcompat:+'
 // From node_modules
    implementation "androidx.transition:transition:1.1.0"
    implementation "androidx.core:core:1.6.0"
    
    extractHeaders("com.facebook.fbjni:fbjni:" + FBJNI_VERSION + ":headers")
    extractSO("com.facebook.fbjni:fbjni:" + FBJNI_VERSION)

    
}

task unpackReactNativeAAR {
    return
    def buildType = resolveBuildType()
    def rnAarMatcher = "**/versioned-react-native/**/*${buildType}.aar"
    if (REACT_NATIVE_MINOR_VERSION < 69) {
        rnAarMatcher = "**/**/*.aar"
    }
    def rnAAR = fileTree("${rootDir}/versioned-abis").matching({ include "**/reactandroid-abi47_0_0/**/*.aar" }).singleFile
    def file = rnAAR.absoluteFile
    def packageName = file.name.tokenize('-')[0]
    copy {
        from zipTree(file)
        into "$reactNativeRootDir/ReactAndroid/src/main/jni/first-party/$packageName/"
        include "jni/**/*.so"
    }
}

task downloadNdkBuildDependencies {
    if (!boostPath) {
        dependsOn(downloadBoost)
    }
    dependsOn(downloadDoubleConversion)
    dependsOn(downloadFolly)
    dependsOn(downloadGlog)
}

task prepareThirdPartyNdkHeaders(dependsOn:[
    downloadNdkBuildDependencies,
    prepareBoost,
    prepareDoubleConversion,
    prepareFolly,
    prepareGlog,
    unpackReactNativeAAR]
) {}

def nativeBuildDependsOn(dependsOnTask) {
    def buildTasks = tasks.findAll({ task ->
        !task.name.contains("Clean") && (task.name.contains("externalNative") || task.name.contains("CMake")) })
    buildTasks.forEach { task -> task.dependsOn(dependsOnTask) }
}

afterEvaluate {
    extractAARHeaders.dependsOn(prepareThirdPartyNdkHeaders)
    extractSOFiles.dependsOn(prepareThirdPartyNdkHeaders)

    nativeBuildDependsOn(prepareThirdPartyNdkHeaders)
    nativeBuildDependsOn(extractAARHeaders)
    nativeBuildDependsOn(extractSOFiles)

    tasks.forEach({ task ->
        if (task.name.contains("JniLibFolders")) {
            task.dependsOn(packageNdkLibs)
        }
    })

    if (JS_RUNTIME == "hermes") {
      extractAARHeaders.dependsOn(prepareHermes)
      extractSOFiles.dependsOn(prepareHermes)
    } else if (JS_RUNTIME == "v8") {
        def buildTasks = tasks.findAll({ task ->
            !task.name.contains("Clean") && (task.name.contains("externalNative") || task.name.contains("CMake") || task.name.startsWith("generateJsonModel")) })
        buildTasks.forEach { task ->
            def buildType = task.name.endsWith('Debug') ? 'Debug' : 'Release'
            task.dependsOn(":react-native-v8:copy${buildType}JniLibsProjectOnly")
        }
    } else if (JS_RUNTIME == "jsc") {
      extractAARHeaders.dependsOn(prepareJSC)
      extractSOFiles.dependsOn(prepareJSC)
    } else {
      throw GradleScriptException("Unknown JS runtime ${JS_RUNTIME}.")
    }
}

if (CLIENT_SIDE_BUILD) {
    def aarDir = "${buildDir}/outputs"
    aar = file("${aarDir}/android-${resolveBuildType()}.aar") // e.g. android-debug.aar
    if (aar == null) {
        throw GradleScriptException("AAR build failed. No AAR found in ${aarDir}.")
    }
    artifacts.add("default", aar)
}

tasks.whenTaskAdded { task ->
  def buildType = task.name.endsWith('Debug') ? 'Debug' : 'Release'
  if (!task.name.contains("Clean") && (task.name.contains('externalNativeBuild') || task.name.startsWith('configureCMake') || task.name.startsWith('buildCMake') || task.name.startsWith('generateJsonModel'))) {
    task.dependsOn(":ReactAndroid:copy${buildType}JniLibsProjectOnly")
  }
}

android {
  buildFeatures {
    prefab true
  }
}

dependencies {
  if (file("${reactNativeRootDir}/ReactAndroid/hermes-engine/build/outputs/aar/hermes-engine-release.aar").exists()) {
    compileOnly(files("${reactNativeRootDir}/ReactAndroid/hermes-engine/build/outputs/aar/hermes-engine-release.aar"))
  }
  compileOnly 'androidx.swiperefreshlayout:swiperefreshlayout:+'
}

android.packagingOptions.excludes.add("**/libhermes*.so")
