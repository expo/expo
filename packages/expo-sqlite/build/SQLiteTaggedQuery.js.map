{"version":3,"file":"SQLiteTaggedQuery.js","sourceRoot":"","sources":["../src/SQLiteTaggedQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import { SQLiteBindValue, SQLiteRunResult } from './NativeStatement';\nimport { SQLiteDatabase } from './SQLiteDatabase';\nimport { parseSQLQuery, type SQLParsedInfo } from './queryUtils';\n\n/**\n * Conditional type that returns T[] when type parameter is explicitly provided,\n * or union type when using default unknown type.\n */\ntype SQLiteTaggedQueryResult<T> = [unknown] extends [T] ? unknown[] | SQLiteRunResult : T[];\n\n/**\n * A SQL query with tagged template literals API that can be awaited directly (returns array of objects by default),\n * or transformed using .values() or .first() methods.\n *\n * This API is inspired by Bun's SQL interface:\n *\n * @example\n * ```ts\n * // Default: returns array of objects\n * const users = await sql`SELECT * FROM users WHERE age > ${21}`;\n *\n * // Get values as arrays\n * const values = await sql`SELECT name, age FROM users`.values();\n * // Returns: [[\"Alice\", 30], [\"Bob\", 25]]\n *\n * // Get first row only\n * const user = await sql`SELECT * FROM users WHERE id = ${1}`.first();\n *\n * // With type parameter\n * const users = await sql<User>`SELECT * FROM users`;\n *\n * // Mutable queries return SQLiteRunResult\n * const result = await sql`INSERT INTO users (name) VALUES (${\"Alice\"})` as SQLiteRunResult;\n * console.log(result.lastInsertRowId, result.changes);\n *\n * // Synchronous API\n * const users = sql<User>`SELECT * FROM users WHERE age > ${21}`.allSync();\n * const user = sql<User>`SELECT * FROM users WHERE id = ${userId}`.firstSync();\n * ```\n */\nexport class SQLiteTaggedQuery<T = unknown> implements PromiseLike<SQLiteTaggedQueryResult<T>> {\n  private readonly source: string;\n  private readonly params: SQLiteBindValue[];\n  private readonly parsedInfo: SQLParsedInfo;\n\n  constructor(\n    private readonly database: SQLiteDatabase,\n    strings: TemplateStringsArray,\n    values: unknown[]\n  ) {\n    const sql = strings.join('?');\n    this.source = sql;\n    this.params = values as SQLiteBindValue[];\n    this.parsedInfo = parseSQLQuery(sql);\n  }\n\n  /**\n   * Make the query awaitable - automatically returns rows or metadata based on query type.\n   * This is called automatically when you await the query.\n   *\n   * @example\n   * ```ts\n   * // SELECT returns array of objects\n   * const users = await sql`SELECT * FROM users`;\n   *\n   * // INSERT returns metadata\n   * const result = await sql`INSERT INTO users (name) VALUES (${\"Alice\"})`;\n   * console.log(result.lastInsertRowId, result.changes);\n   *\n   * // With type parameter (no assertion needed)\n   * const users = await sql<User>`SELECT * FROM users`; // Type: User[]\n   * ```\n   */\n  then<TResult1 = SQLiteTaggedQueryResult<T>, TResult2 = never>(\n    onfulfilled?: ((value: SQLiteTaggedQueryResult<T>) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): PromiseLike<TResult1 | TResult2> {\n    if (this.parsedInfo.canReturnRows) {\n      // SELECT, PRAGMA, WITH, EXPLAIN, or has RETURNING clause\n      return this.database.getAllAsync<T>(this.source, this.params).then(onfulfilled, onrejected);\n    } else {\n      // INSERT, UPDATE, DELETE without RETURNING\n      return this.database.runAsync(this.source, this.params).then(onfulfilled as any, onrejected);\n    }\n  }\n\n  /**\n   * Execute the query and return rows as arrays of values (Bun-style).\n   * Each row is an array where values are in column order.\n   *\n   * @example\n   * ```ts\n   * const rows = await sql`SELECT name, age FROM users`.values();\n   * // Returns: [[\"Alice\", 30], [\"Bob\", 25]]\n   * ```\n   */\n  async values(): Promise<any[][]> {\n    const statement = await this.database.prepareAsync(this.source);\n    try {\n      const result = await statement.executeForRawResultAsync(this.params);\n      return await result.getAllAsync();\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n\n  /**\n   * Execute the query and return the first row only.\n   * Returns null if no rows match.\n   *\n   * @example\n   * ```ts\n   * const user = await sql`SELECT * FROM users WHERE id = ${1}`.first();\n   * ```\n   */\n  async first(): Promise<T | null> {\n    return this.database.getFirstAsync<T>(this.source, this.params);\n  }\n\n  /**\n   * Execute the query and return an async iterator over the rows.\n   *\n   * @example\n   * ```ts\n   * for await (const user of sql`SELECT * FROM users`.each()) {\n   *   console.log(user.name);\n   * }\n   * ```\n   */\n  each(): AsyncIterableIterator<T> {\n    return this.database.getEachAsync<T>(this.source, this.params);\n  }\n\n  // Synchronous variants\n\n  /**\n   * Execute the query synchronously - returns rows or metadata based on query type.\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   */\n  allSync(): SQLiteTaggedQueryResult<T> {\n    if (this.parsedInfo.canReturnRows) {\n      // SELECT, PRAGMA, WITH, EXPLAIN, or has RETURNING clause\n      return this.database.getAllSync<T>(this.source, this.params) as SQLiteTaggedQueryResult<T>;\n    } else {\n      // INSERT, UPDATE, DELETE without RETURNING\n      return this.database.runSync(this.source, this.params) as SQLiteTaggedQueryResult<T>;\n    }\n  }\n\n  /**\n   * Execute the query synchronously and return rows as arrays of values.\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   */\n  valuesSync(): any[][] {\n    const statement = this.database.prepareSync(this.source);\n    try {\n      const result = statement.executeForRawResultSync(this.params);\n      return result.getAllSync();\n    } finally {\n      statement.finalizeSync();\n    }\n  }\n\n  /**\n   * Execute the query synchronously and return the first row.\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   */\n  firstSync(): T | null {\n    return this.database.getFirstSync<T>(this.source, this.params);\n  }\n\n  /**\n   * Execute the query synchronously and return an iterator.\n   * > **Note:** Running heavy tasks with this function can block the JavaScript thread and affect performance.\n   */\n  eachSync(): IterableIterator<T> {\n    return this.database.getEachSync<T>(this.source, this.params);\n  }\n}\n"]}