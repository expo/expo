{"version":3,"file":"InAppPurchases.js","sourceRoot":"","sources":["../src/InAppPurchases.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, EventEmitter, Subscription } from 'expo-modules-core';\nimport { Platform } from 'react-native';\n\nimport ExpoInAppPurchases from './ExpoInAppPurchases';\nimport {\n  IAPErrorCode,\n  IAPItemType,\n  IAPQueryResponse,\n  IAPResponseCode,\n  InAppPurchase,\n  InAppPurchaseState,\n  IAPItemDetails,\n  IAPPurchaseHistoryOptions,\n  QueryResult,\n  IAPPurchaseItemOptions,\n} from './InAppPurchases.types';\n\nexport {\n  InAppPurchase,\n  InAppPurchaseState,\n  IAPResponseCode,\n  IAPErrorCode,\n  IAPItemType,\n  IAPQueryResponse,\n  IAPItemDetails,\n  IAPPurchaseHistoryOptions,\n  QueryResult,\n  IAPPurchaseItemOptions,\n};\n\nconst errors = {\n  ALREADY_CONNECTED: 'Already connected to App Store',\n  ALREADY_DISCONNECTED: 'Already disconnected from App Store',\n  NOT_CONNECTED: 'Must be connected to App Store',\n};\n\nconst PURCHASES_UPDATED_EVENT = 'Expo.purchasesUpdated';\nconst eventEmitter = new EventEmitter(ExpoInAppPurchases);\n\nlet connected = false;\nlet purchaseUpdatedSubscription: Subscription;\n\n// @needsAudit\n/**\n * Connects to the app store and performs all of the necessary initialization to prepare the module\n * to accept payments. This method must be called before anything else, otherwise an error will be\n * thrown.\n * @return Returns a Promise that fulfills when connection is established.\n */\nexport async function connectAsync(): Promise<void> {\n  if (connected) {\n    throw new ConnectionError(errors.ALREADY_CONNECTED);\n  }\n\n  await ExpoInAppPurchases.connectAsync();\n  connected = true;\n}\n\n// @needsAudit\n/**\n * Retrieves the product details (price, description, title, etc) for each item that you inputted in\n * the Google Play Console and App Store Connect. These products are associated with your app's\n * specific Application/Bundle ID and cannot be retrieved from other apps. This queries both in-app\n * products and subscriptions so there's no need to pass those in separately.\n *\n * You must retrieve an item's details before you attempt to purchase it via `purchaseItemAsync`.\n * This is a prerequisite to buying a product even if you have the item details bundled in your app\n * or on your own servers.\n *\n * If any of the product IDs passed in are invalid and don't exist, you will not receive an\n * `IAPItemDetails` object corresponding to that ID. For example, if you pass in four product IDs in\n * but one of them has a typo, you will only get three response objects back.\n *\n * @param itemList The list of product IDs whose details you want to query from the app store.\n * @return Returns a Promise that resolves with an `IAPQueryResponse` containing `IAPItemDetails`\n * objects in the `results` array.\n *\n * @example\n * ```ts\n * // These product IDs must match the item entries you created in the App Store Connect and Google Play Console.\n * // If you want to add more or edit their attributes you can do so there.\n *\n * const items = Platform.select({\n *   ios: [\n *     'dev.products.gas',\n *     'dev.products.premium',\n *     'dev.products.gold_monthly',\n *     'dev.products.gold_yearly',\n *   ],\n *   android: ['gas', 'premium', 'gold_monthly', 'gold_yearly'],\n * });\n *\n *  // Retrieve product details\n * const { responseCode, results } = await getProductsAsync(items);\n * if (responseCode === IAPResponseCode.OK) {\n *   this.setState({ items: results });\n * }\n * ```\n */\nexport async function getProductsAsync(\n  itemList: string[]\n): Promise<IAPQueryResponse<IAPItemDetails>> {\n  if (!connected) {\n    throw new ConnectionError(errors.NOT_CONNECTED);\n  }\n\n  return await ExpoInAppPurchases.getProductsAsync(itemList);\n}\n\n// @needsAudit\n/**\n * Retrieves the user's purchase history.\n *\n * Please note that on iOS, StoreKit actually creates a new transaction object every time you\n * restore completed transactions, therefore the `purchaseTime` and `orderId` may be inaccurate if\n * it's a restored purchase. If you need the original transaction's information you can use\n * `originalPurchaseTime` and `originalOrderId`, but those will be 0 and an empty string\n * respectively if it is the original transaction.\n *\n * You should not call this method on launch because restoring purchases on iOS prompts for the\n * userâ€™s App Store credentials, which could interrupt the flow of your app.\n *\n * @param options An optional `PurchaseHistoryOptions` object.\n * @return Returns a `Promise` that fulfills with an `IAPQueryResponse` that contains an array of\n * `InAppPurchase` objects.\n */\nexport async function getPurchaseHistoryAsync(\n  options: IAPPurchaseHistoryOptions = { useGooglePlayCache: true }\n): Promise<IAPQueryResponse<InAppPurchase>> {\n  if (!connected) {\n    throw new ConnectionError(errors.NOT_CONNECTED);\n  }\n\n  if (Platform.OS === 'android') {\n    return await ExpoInAppPurchases.getPurchaseHistoryAsync(options);\n  } else {\n    return await ExpoInAppPurchases.getPurchaseHistoryAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Initiates the purchase flow to buy the item associated with this `productId`. This will display a\n * prompt to the user that will allow them to either buy the item or cancel the purchase. When the\n * purchase completes, the result must be handled in the callback that you passed in to\n * [`setPurchaseListener`](#setpurchaselistener).\n *\n * Remember, you have to query an item's details via `getProductsAsync` and set the purchase\n * listener before you attempt to buy an item.\n *\n * [Apple](https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers)\n * and [Google](https://developer.android.com/google/play/billing/subscriptions) both have\n * their own workflows for dealing with subscriptions. In general, you can deal with them in the\n * same way you do one-time purchases but there are caveats including if a user decides to cancel\n * before the expiration date. To check the status of a subscription, you can use the [Google Play\n * Developer](https://developers.google.com/android-publisher/api-ref/rest/v3/purchases.subscriptions/get)\n * API on Android and the [Status Update\n * Notifications](https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/subscriptions_and_offers/enabling_app_store_server_notifications)\n * service on iOS.\n *\n * @param itemId The product ID of the item you want to buy.\n * @param details __Android Only.__ Details for billing flow.\n * @return Returns a `Promise` that resolves when the purchase is done processing. To get the actual\n * result of the purchase, you must handle purchase events inside the `setPurchaseListener`\n * callback.\n */\nexport async function purchaseItemAsync(\n  itemId: string,\n  details?: IAPPurchaseItemOptions\n): Promise<void> {\n  if (!connected) {\n    throw new ConnectionError(errors.NOT_CONNECTED);\n  }\n\n  await ExpoInAppPurchases.purchaseItemAsync(itemId, details);\n}\n\n// @needsAudit\n/**\n * Sets a callback that handles incoming purchases. This must be done before any calls to\n * `purchaseItemAsync` are made, otherwise those transactions will be lost. You should **set the\n * purchase listener globally**, and not inside a specific screen, to ensure that you receive\n * incomplete transactions, subscriptions, and deferred transactions.\n *\n * Purchases can either be instantiated by the user (via `purchaseItemAsync`) or they can come from\n * subscription renewals or unfinished transactions on iOS (e.g. if your app exits before\n * `finishTransactionAsync` was called).\n *\n * Note that on iOS, the results array will only contain one item: the one that was just\n * purchased. On Android, it will return both finished and unfinished purchases, hence the array\n * return type. This is because the Google Play Billing API detects purchase updates but doesn't\n * differentiate which item was just purchased, therefore there's no good way to tell but in general\n * it will be whichever purchase has `acknowledged` set to `false`, so those are the ones that you\n * have to handle in the response. Consumed items will not be returned however, so if you consume an\n * item that record will be gone and no longer appear in the results array when a new purchase is\n * made.\n *\n * @example\n * ```ts\n * // Set purchase listener\n *  setPurchaseListener(({ responseCode, results, errorCode }) => {\n *   // Purchase was successful\n *   if (responseCode === IAPResponseCode.OK) {\n *     results.forEach(purchase => {\n *       if (!purchase.acknowledged) {\n *         console.log(`Successfully purchased ${purchase.productId}`);\n *         // Process transaction here and unlock content...\n *\n *         // Then when you're done\n *         finishTransactionAsync(purchase, true);\n *       }\n *     });\n *   } else if (responseCode === IAPResponseCode.USER_CANCELED) {\n *     console.log('User canceled the transaction');\n *   } else if (responseCode === IAPResponseCode.DEFERRED) {\n *     console.log('User does not have permissions to buy but requested parental approval (iOS only)');\n *   } else {\n *     console.warn(`Something went wrong with the purchase. Received errorCode ${errorCode}`);\n *   }\n * });\n * ```\n * @param callback The callback function you want to run when there is an update to the purchases.\n */\nexport function setPurchaseListener(\n  callback: (result: IAPQueryResponse<InAppPurchase>) => void\n): void {\n  if (purchaseUpdatedSubscription) {\n    purchaseUpdatedSubscription.remove();\n  }\n\n  purchaseUpdatedSubscription = eventEmitter.addListener<IAPQueryResponse<InAppPurchase>>(\n    PURCHASES_UPDATED_EVENT,\n    (result) => {\n      callback(result);\n    }\n  );\n}\n\n// @needsAudit\n/**\n * Marks a transaction as completed. This _must_ be called on successful purchases only after you\n * have verified the transaction and unlocked the functionality purchased by the user.\n *\n * On Android, this will either \"acknowledge\" or \"consume\" the purchase depending on the value of\n * `consumeItem`. Acknowledging indicates that this is a one time purchase (e.g. premium upgrade),\n * whereas consuming a purchase allows it to be bought more than once. You cannot buy an item again\n * until it's consumed. Both consuming and acknowledging let Google know that you are done\n * processing the transaction. If you do not acknowledge or consume a purchase within three days,\n * the user automatically receives a refund, and Google Play revokes the purchase.\n *\n * On iOS, this will [mark the transaction as\n * finished](https://developer.apple.com/documentation/storekit/skpaymentqueue/1506003-finishtransaction)\n * and prevent it from reappearing in the purchase listener callback. It will also let the user know\n * their purchase was successful.\n *\n * `consumeItem` is ignored on iOS because you must specify whether an item is a consumable or\n * non-consumable in its product entry in App Store Connect, whereas on Android you indicate an item\n * is consumable at runtime.\n *\n * > Make sure that you verify each purchase to prevent faulty transactions and protect against\n * > fraud _before_ you call `finishTransactionAsync`. On iOS, you can validate the purchase's\n * > `transactionReceipt` with the App Store as described\n * > [here](https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/validating_receipts_with_the_app_store?language=objc).\n * > On Android, you can verify your purchase using the Google Play Developer API as described\n * > [here](https://developer.android.com/google/play/billing/security#validating-purchase).\n *\n * @example\n * ```ts\n * if (!purchase.acknowledged) {\n *   await finishTransactionAsync(purchase, false); // or true for consumables\n * }\n * ```\n * @param purchase The purchase you want to mark as completed.\n * @param consumeItem __Android Only.__ A boolean indicating whether or not the item is a\n * consumable.\n */\nexport async function finishTransactionAsync(\n  purchase: InAppPurchase,\n  consumeItem: boolean\n): Promise<void> {\n  if (!connected) {\n    throw new ConnectionError(errors.NOT_CONNECTED);\n  }\n  if (purchase.acknowledged) return;\n\n  if (Platform.OS === 'android') {\n    await ExpoInAppPurchases.finishTransactionAsync(purchase.purchaseToken, consumeItem);\n  } else {\n    await ExpoInAppPurchases.finishTransactionAsync(purchase.orderId);\n  }\n}\n\n// @needsAudit\n/**\n * Returns the last response code. This is more descriptive on Android since there is native support\n * for retrieving the billing response code.\n *\n * On Android, this will return `IAPResponseCode.ERROR` if you are not connected or one of the\n * billing response codes found\n * [here](https://developer.android.com/reference/com/android/billingclient/api/BillingClient.BillingResponseCode)\n * if you are.\n *\n * On iOS, this will return `IAPResponseCode.OK` if you are connected or `IAPResponseCode.ERROR` if\n * you are not. Therefore, it's a good way to test whether or not you are connected and it's safe to\n * use the other methods.\n *\n * @return Returns a Promise that fulfils with an number representing the `IAPResponseCode`.\n *\n * @example\n * ```ts\n * const responseCode = await getBillingResponseCodeAsync();\n *  if (responseCode !== IAPResponseCode.OK) {\n *   // Either we're not connected or the last response returned an error (Android)\n * }\n * ```\n */\nexport async function getBillingResponseCodeAsync(): Promise<IAPResponseCode> {\n  if (!connected) {\n    return IAPResponseCode.ERROR;\n  }\n  if (!ExpoInAppPurchases.getBillingResponseCodeAsync) {\n    return IAPResponseCode.OK;\n  }\n\n  return await ExpoInAppPurchases.getBillingResponseCodeAsync();\n}\n\n// @needsAudit\n/**\n * Disconnects from the app store and cleans up memory internally. Call this when you are done using\n * the In-App Purchases API in your app.\n *\n * No other methods can be used until the next time you call `connectAsync`.\n *\n *@return Returns a Promise that fulfils when disconnecting process is finished.\n */\nexport async function disconnectAsync(): Promise<void> {\n  if (!connected) {\n    throw new ConnectionError(errors.ALREADY_DISCONNECTED);\n  }\n  await ExpoInAppPurchases.disconnectAsync();\n  connected = false;\n}\n\nclass ConnectionError extends CodedError {\n  constructor(message: string) {\n    super('ERR_IN_APP_PURCHASES_CONNECTION', message);\n  }\n}\n"]}