import { fs } from 'memfs';
import path from 'path';
import temporary from 'tempy';

import * as GitIgnore from '../mergeGitIgnorePaths';
import { removeFromGitIgnore, upsertGitIgnoreContents } from '../mergeGitIgnorePaths';

const testRoot = temporary.directory();
beforeAll(async () => {
  await fs.promises.mkdir(testRoot, { recursive: true });
});
afterAll(async () => {
  await fs.promises.rm(testRoot, { recursive: true, force: true });
});

const gitignore1 = `
# hello world
*/foo

ios/

/android 
## bar

`;

// A gitignore with an old generated section
const gitignore2 = `a
b
${GitIgnore.createGeneratedHeaderComment('...')}
foo
bar
${GitIgnore.generatedFooterComment}
c
d`;

// A broken generated section
const gitignore3 = `a
b
${GitIgnore.createGeneratedHeaderComment('...')}
foo
bar
c
d`;

// Footer is before header
const gitignore4 = `a
b
${GitIgnore.generatedFooterComment}
foo
bar
${GitIgnore.createGeneratedHeaderComment('...')}
c
d`;

it(`sanitizes comments, new lines, and sort order`, () => {
  expect(GitIgnore.getSanitizedGitIgnoreLines(gitignore1)).toStrictEqual([
    '*/foo',
    '/android ',
    'ios/',
  ]);
});

describe('removeGeneratedGitIgnoreContents', () => {
  it(`removes a generated gitignore`, () => {
    expect(GitIgnore.removeGeneratedGitIgnoreContents(gitignore2)?.split('\n')).toStrictEqual([
      'a',
      'b',
      'c',
      'd',
    ]);
  });
  it(`removes nothing from a regular gitignore`, () => {
    expect(GitIgnore.removeGeneratedGitIgnoreContents(gitignore1)).toBe(null);
  });
  it(`removes nothing when the generated footer is missing`, () => {
    expect(GitIgnore.removeGeneratedGitIgnoreContents(gitignore3)).toBe(null);
  });
  it(`removes nothing when the footer precede the header`, () => {
    expect(GitIgnore.removeGeneratedGitIgnoreContents(gitignore4)).toBe(null);
  });
});

describe('mergeGitIgnore', () => {
  it(`skips merging if the target file is missing`, async () => {
    // fs
    const projectRoot = path.join(testRoot, 'merge-git-ignore-skip-when-target-missing');
    await fs.promises.mkdir(projectRoot, { recursive: true });
    // Setup

    const targetGitIgnorePath = path.join(projectRoot, '.gitignore');
    // Skip writing a gitignore

    const sourceGitIgnorePath = path.join(projectRoot, '.gitignore-other');
    await fs.promises.writeFile(
      sourceGitIgnorePath,
      [
        'alpha',
        'beta',
        // in the future we may want to merge this value with the existing matching value
        // or maybe we could keep the code simple and not do that :]
        'bar',
      ].join('\n')
    );

    expect(GitIgnore.mergeGitIgnorePaths(targetGitIgnorePath, sourceGitIgnorePath)).toBe(null);
    expect(fs.existsSync(targetGitIgnorePath)).toBe(false);
  });
  it(`merges two git ignore files in the filesystem`, async () => {
    // fs
    const projectRoot = path.join(testRoot, 'merge-git-ignore-works');
    await fs.promises.mkdir(projectRoot, { recursive: true });
    // Setup
    const targetGitIgnorePath = path.join(projectRoot, '.gitignore');
    await fs.promises.writeFile(
      targetGitIgnorePath,
      [
        'foo',
        // Test a duplicate value
        'bar',
      ].join('\n')
    );

    const sourceGitIgnorePath = path.join(projectRoot, '.gitignore-other');
    await fs.promises.writeFile(
      sourceGitIgnorePath,
      [
        'alpha',
        'beta',
        // in the future we may want to merge this value with the existing matching value
        // or maybe we could keep the code simple and not do that :]
        'bar',
      ].join('\n')
    );

    const results = GitIgnore.mergeGitIgnorePaths(targetGitIgnorePath, sourceGitIgnorePath);
    expect(results).not.toBe(null);
    expect(results?.contents).toMatch(
      /generated expo-cli sync-69a5afdba5ff28bbd11618f94ae2dc4bfdfd7cae/
    );
    expect(results?.contents).toMatch(/foo/);
    expect(results?.contents).toMatch(/alpha/);
    expect(results?.didMerge).toBe(true);

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(results?.contents);
  });
});

describe(removeFromGitIgnore, () => {
  it('can remove a line from gitignore', async () => {
    const targetGitIgnorePath = path.join(testRoot, './removeFromGitIgnore');
    await fs.promises.writeFile(targetGitIgnorePath, gitignore1);
    removeFromGitIgnore(targetGitIgnorePath, '*/foo');

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(`
# hello world

ios/

/android 
## bar

`);
  });

  it('will remove the generated section if it is empty', async () => {
    const targetGitIgnorePath = path.join(testRoot, './removeFromGitIgnore-remove-generated');
    await fs.promises.writeFile(
      targetGitIgnorePath,
      `
# hello world
*/foo

ios/

/android 
## bar


# @generated expo-cli sync-4f49d69613b186e71104c7ca1b26c1e5b78c9193
# The following patterns were generated by expo-cli

test-string
# @end expo-cli`
    );
    removeFromGitIgnore(targetGitIgnorePath, 'test-string');

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(`
# hello world
*/foo

ios/

/android 
## bar


`);
  });
});

describe(upsertGitIgnoreContents, () => {
  it('can create a new gitignore file', async () => {
    const targetGitIgnorePath = path.join(testRoot, './upsertGitIgnoreContents-create');
    const results = upsertGitIgnoreContents(targetGitIgnorePath, 'test-string');

    expect(results?.contents).toBe(`
# @generated expo-cli sync-4f49d69613b186e71104c7ca1b26c1e5b78c9193
# The following patterns were generated by expo-cli

test-string
# @end expo-cli`);

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(results?.contents);
  });

  it('can update an existing gitignore file', async () => {
    const targetGitIgnorePath = path.join(testRoot, './upsertGitIgnoreContents-update');
    await fs.promises.writeFile(targetGitIgnorePath, gitignore1);

    const results = upsertGitIgnoreContents(targetGitIgnorePath, 'test-string');

    expect(results?.contents).toBe(`
# hello world
*/foo

ios/

/android 
## bar


# @generated expo-cli sync-4f49d69613b186e71104c7ca1b26c1e5b78c9193
# The following patterns were generated by expo-cli

test-string
# @end expo-cli`);

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(results?.contents);
  });

  it('can append an existing gitignore file', async () => {
    const targetGitIgnorePath = path.join(testRoot, './upsertGitIgnoreContents-merge');
    await fs.promises.writeFile(
      targetGitIgnorePath,
      `# hello world
*/foo

ios/

/android 
## bar


# @generated expo-cli sync-4f49d69613b186e71104c7ca1b26c1e5b78c9193
# The following patterns were generated by expo-cli

test-string
# @end expo-cli`
    );

    const results = upsertGitIgnoreContents(targetGitIgnorePath, 'another-test-string');

    expect(results?.contents).toBe(`# hello world
*/foo

ios/

/android 
## bar


# @generated expo-cli sync-f479b6a00a92ff9cb6fa390e462eed9d41287dc1
# The following patterns were generated by expo-cli

test-string
another-test-string
# @end expo-cli`);

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(results?.contents);
  });

  it('will ignore the update if it already exists', async () => {
    const targetGitIgnorePath = path.join(testRoot, './upsertGitIgnoreContents-ignore');
    await fs.promises.writeFile(
      targetGitIgnorePath,
      `# hello world
*/foo

ios/

/android 
## bar


# @generated expo-cli sync-4f49d69613b186e71104c7ca1b26c1e5b78c9193
# The following patterns were generated by expo-cli

test-string
# @end expo-cli`
    );

    const results = upsertGitIgnoreContents(targetGitIgnorePath, 'test-string');

    expect(results).toBeNull();
  });
});
