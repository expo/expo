{"version":3,"file":"LogBoxData.js","sourceRoot":"","sources":["../../../src/error-overlay/Data/LogBoxData.tsx"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 650 Industries.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from 'react';\n\nimport { LogBoxLog, StackType } from './LogBoxLog';\nimport type { LogLevel } from './LogBoxLog';\nimport { LogContext } from './LogContext';\nimport { parseLogBoxException } from './parseLogBoxLog';\nimport type { Message, Category, ComponentStack, ExtendedExceptionData } from './parseLogBoxLog';\nimport NativeLogBox from '../modules/NativeLogBox';\nimport parseErrorStack from '../modules/parseErrorStack';\n\nexport type LogBoxLogs = Set<LogBoxLog>;\n\nexport type LogData = {\n  level: LogLevel;\n  message: Message;\n  category: Category;\n  componentStack: ComponentStack;\n};\n\ntype ExtendedError = any;\n\nexport type Observer = (options: {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  selectedLogIndex: number;\n}) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\nexport type WarningInfo = {\n  finalFormat: string;\n  forceDialogImmediately: boolean;\n  suppressDialog_LEGACY: boolean;\n  suppressCompletely: boolean;\n  monitorEvent: string | null;\n  monitorListVersion: number;\n  monitorSampleRate: number;\n};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype Props = object;\n\ntype State = {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  hasError: boolean;\n  selectedLogIndex: number;\n};\n\nconst observers: Set<{ observer: Observer } & any> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout: null | ReturnType<typeof setImmediate> | ReturnType<typeof setTimeout> = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nconst LOGBOX_ERROR_MESSAGE =\n  'An error was thrown when attempting to render log messages via LogBox.';\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(error: ExtendedError, componentStack?: string): void {\n  const ExceptionsManager = require('../modules/ExceptionsManager').default;\n\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error);\n}\n\nexport function reportUnexpectedLogBoxError(error: ExtendedError, componentStack?: string): void {\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  return reportLogBoxError(error, componentStack);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === 'string' && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction setImmediateShim(callback: () => void) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n  return global.setImmediate(callback);\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({ observer }) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog: LogBoxLog): void {\n  // Don't want store these logs because they trigger a\n  // state update when we add them to the store.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then roll it up into the last log in the list by incrementing\n  // the count (similar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === 'fatal') {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // symbolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog: null | (() => void) = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    // TODO: HANDLE THIS\n    newLog.symbolicate('component');\n\n    newLog.symbolicate('stack', (status) => {\n      if (addPendingLog && status !== 'PENDING') {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== 'PENDING') {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === 'syntax') {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(errorForStackTrace?.stack);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        })\n      );\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.retrySymbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type);\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === 'syntax') {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter((log) => log.level !== 'warn');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter((log) => log.level !== 'error' && log.level !== 'fatal');\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function getIgnorePatterns(): IgnorePattern[] {\n  return Array.from(ignorePatterns);\n}\n\nexport function addIgnorePatterns(patterns: IgnorePattern[]): void {\n  const existingSize = ignorePatterns.size;\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  patterns.forEach((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  // We need to recheck all of the existing logs.\n  // This allows adding an ignore pattern anywhere in the codebase.\n  // Without this, if you ignore a pattern after the a log is created,\n  // then we would keep showing the log.\n  logs = new Set(Array.from(logs).filter((log) => !isMessageIgnored(log.message.content)));\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = { observer };\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\nexport function withSubscription(WrappedComponent: React.FC<object>): React.Component<object> {\n  class LogBoxStateSubscription extends React.Component<React.PropsWithChildren<Props>, State> {\n    static getDerivedStateFromError() {\n      return { hasError: true };\n    }\n\n    componentDidCatch(err: Error, errorInfo: { componentStack: string } & any) {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription?: Subscription;\n\n    state = {\n      logs: new Set<LogBoxLog>(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    render() {\n      if (this.state.hasError) {\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\n        // We can't show any fallback UI here, because the error may be with <View> or <Text>.\n        return null;\n      }\n\n      return (\n        <LogContext.Provider\n          value={{\n            selectedLogIndex: this.state.selectedLogIndex,\n            isDisabled: this.state.isDisabled,\n            logs: Array.from(this.state.logs),\n          }}>\n          {this.props.children}\n          <WrappedComponent />\n        </LogContext.Provider>\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe((data) => {\n        this.setState(data);\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const { selectedLogIndex, logs: stateLogs } = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  // @ts-expect-error\n  return LogBoxStateSubscription;\n}\n"]}