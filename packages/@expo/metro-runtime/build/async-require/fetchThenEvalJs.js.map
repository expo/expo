{"version":3,"file":"fetchThenEvalJs.js","sourceRoot":"","sources":["../../src/async-require/fetchThenEvalJs.ts"],"names":[],"mappings":";;;AAAA;;;;;GAKG;AACH,6CAA0C;AAM1C;;;;GAIG;AACH,SAAgB,kBAAkB,CAAC,GAAW;IAC5C,OAAO,IAAA,uBAAU,EAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE;QACxD,IACE,OAAO,EAAE,GAAG,EAAE,CAAC,cAAc,CAAC,IAAI,IAAI;YACtC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAE,CAAC,QAAQ,CAAC,kBAAkB,CAAC,EACzD;YACA,+BAA+B;YAC/B,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,2BAA2B,GAAG,GAAG,CAAC,CAAC;SAChF;QAED,IAAI,MAAM,KAAK,GAAG,EAAE;YAClB,oEAAoE;YACpE,qEAAqE;YACrE,IAAI,MAAM,CAAC,uBAAuB,EAAE;gBAClC,OAAO,MAAM,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;aAClD;iBAAM;gBACL,mCAAmC;gBACnC,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;aACnB;SACF;aAAM;YACL,mCAAmC;YACnC,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa,EAAE;gBAC1C,0DAA0D;gBAC1D,kKAAkK;gBAClK,MAAM,KAAK,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;gBACtC,IAAI,KAAK,EAAE;oBACT,+GAA+G;oBAC/G,wIAAwI;oBACxI,IAAI,SAAS,IAAI,KAAK,EAAE;wBACtB,MAAM,IAAI,KAAK,CACb,yCAAyC;4BACvC,GAAG;4BACH,2CAA2C;4BAC3C,KAAK,CAAC,OAAO;4BACb,GAAG,CACN,CAAC;qBACH;iBACF;aACF;YAED,MAAM,IAAI,KAAK,CACb,0CAA0C,GAAG,qCAAqC,IAAI,EAAE,CACzF,CAAC;SACH;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AA7CD,gDA6CC;AAED,SAAS,iBAAiB,CAAC,IAAY;IACrC,IAAI;QACF,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACzB;IAAC,MAAM;QACN,OAAO,IAAI,CAAC;KACb;AACH,CAAC","sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { fetchAsync } from './fetchAsync';\n\ndeclare let global: {\n  globalEvalWithSourceUrl?: any;\n};\n\n/**\n * Load a bundle for a URL using fetch + eval on native and script tag injection on web.\n *\n * @param bundlePath Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon`.\n */\nexport function fetchThenEvalAsync(url: string): Promise<void> {\n  return fetchAsync(url).then(({ body, status, headers }) => {\n    if (\n      headers?.has?.('Content-Type') != null &&\n      headers.get('Content-Type')!.includes('application/json')\n    ) {\n      // Errors are returned as JSON.\n      throw new Error(JSON.parse(body).message || `Unknown error fetching '${url}'`);\n    }\n\n    if (status === 200) {\n      // Some engines do not support `sourceURL` as a comment. We expose a\n      // `globalEvalWithSourceUrl` function to handle updates in that case.\n      if (global.globalEvalWithSourceUrl) {\n        return global.globalEvalWithSourceUrl(body, url);\n      } else {\n        // eslint-disable-next-line no-eval\n        return eval(body);\n      }\n    } else {\n      // Format Metro errors if possible.\n      if (process.env.NODE_ENV === 'development') {\n        // body can be an error from Metro if a module is missing.\n        // {\"originModulePath\":\"/Users/evanbacon/Documents/GitHub/expo/.\",\"targetModuleName\":\"./http://localhost:8081/node_modules/react-native/index.js\",\"message\":\"...\"}\n        const error = jsonParseOptional(body);\n        if (error) {\n          // TODO: This is essentially like the Metro native red box errors. We should do a better job formatting them so\n          // the user experience doesn't feel bad. This can be tested by loading a split bundle that results in a missing module error from Metro.\n          if ('message' in error) {\n            throw new Error(\n              'Failed to load split bundle from Metro ' +\n                url +\n                ' (check terminal for more info).\\n(load: ' +\n                error.message +\n                ')'\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        `Failed to load split bundle from Metro ${url} (check terminal for more info).\\n${body}`\n      );\n    }\n  });\n}\n\nfunction jsonParseOptional(json: string): any {\n  try {\n    return JSON.parse(json);\n  } catch {\n    return null;\n  }\n}\n"]}