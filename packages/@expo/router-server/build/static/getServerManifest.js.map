{"version":3,"file":"getServerManifest.js","sourceRoot":"","sources":["../../src/static/getServerManifest.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;AAoBH,0EAkBC;AAGD,kCAgBC;AAvDD,2CAAuC;AACvC,0DAIsC;AAGtC,4DAAyD;AACzD,oEAAiE;AAEjE;;;;;;GAMG;AACI,KAAK,UAAU,+BAA+B,CACnD,UAA4B,EAAE;IAE9B,MAAM,SAAS,GAAG,IAAA,mBAAS,EAAC,UAAG,EAAE;QAC/B,QAAQ,EAAE,KAAK;QACf,GAAG,OAAO;KACX,CAAC,CAAC;IAEH,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED,oFAAoF;IACpF,IAAI,CAAC,OAAO,CAAC,gBAAgB,EAAE,CAAC;QAC9B,MAAM,IAAA,6CAAqB,EAAC,SAAS,CAAC,CAAC;IACzC,CAAC;IAED,OAAO,IAAA,qCAAiB,EAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AAC/C,CAAC;AAED,uDAAuD;AAChD,KAAK,UAAU,WAAW,CAAC,UAA4B,EAAE;IAC9D,MAAM,SAAS,GAAG,IAAA,mBAAS,EAAC,UAAG,EAAE;QAC/B,iBAAiB,EAAE,IAAI;QACvB,2BAA2B,EAAE,IAAI;QACjC,QAAQ,EAAE,KAAK;QACf,GAAG,OAAO;KACX,CAAC,CAAC;IAEH,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED,6BAA6B;IAC7B,MAAM,IAAA,6CAAqB,EAAC,SAAS,CAAC,CAAC;IAEvC,OAAO,IAAA,kCAAwB,EAAC,SAAS,EAAE,KAAK,CAAC,CAAC;AACpD,CAAC","sourcesContent":["/**\n * Copyright Â© 2024 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { ctx } from 'expo-router/_ctx';\nimport {\n  getReactNavigationConfig,\n  getRoutes,\n  type GetRoutesOptions,\n} from 'expo-router/internal/routing';\nimport { type RoutesManifest } from 'expo-server/private';\n\nimport { getServerManifest } from '../getServerManifest';\nimport { loadStaticParamsAsync } from '../loadStaticParamsAsync';\n\n/**\n * Get the server manifest with all dynamic routes loaded with `generateStaticParams`.\n * Unlike the `@expo/router-server/src/routes-manifest.ts` method, this requires loading the entire app in-memory, which\n * takes substantially longer and requires Metro bundling.\n *\n * This is used for the production manifest where we pre-render certain pages and should no longer treat them as dynamic.\n */\nexport async function getBuildTimeServerManifestAsync(\n  options: GetRoutesOptions = {}\n): Promise<RoutesManifest<string>> {\n  const routeTree = getRoutes(ctx, {\n    platform: 'web',\n    ...options,\n  });\n\n  if (!routeTree) {\n    throw new Error('No routes found');\n  }\n\n  // Evaluate all static params; skip for SSR mode where routes are matched at runtime\n  if (!options.skipStaticParams) {\n    await loadStaticParamsAsync(routeTree);\n  }\n\n  return getServerManifest(routeTree, options);\n}\n\n/** Get the linking manifest from a Node.js process. */\nexport async function getManifest(options: GetRoutesOptions = {}) {\n  const routeTree = getRoutes(ctx, {\n    preserveApiRoutes: true,\n    preserveRedirectAndRewrites: true,\n    platform: 'web',\n    ...options,\n  });\n\n  if (!routeTree) {\n    throw new Error('No routes found');\n  }\n\n  // Evaluate all static params\n  await loadStaticParamsAsync(routeTree);\n\n  return getReactNavigationConfig(routeTree, false);\n}\n"]}