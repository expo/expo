{"version":3,"sources":["../src/evalConfig.ts"],"names":["evalConfig","configFile","request","contents","result","code","filePath","transforms","error","location","extractLocationFromSyntaxError","codeFrameColumns","require","codeFrame","start","loc","highlightCode","message","importantStack","extractImportantStackFromNodeError","resolveConfigExport","line","lineNumber","column","columnNumber","isSyntaxError","traces","stack","split","filter","startsWith","length","pop","join","SyntaxError","constructor","name","default","exportedObjectType","Promise","ConfigError","expo","config"],"mappings":"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","sourcesContent":["import { readFileSync } from 'fs';\nimport requireString from 'require-from-string';\nimport { transform } from 'sucrase';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const contents = readFileSync(configFile, 'utf8');\n  let result: any;\n  try {\n    const { code } = transform(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports'],\n    });\n\n    result = requireString(code, configFile);\n  } catch (error: any) {\n    const location = extractLocationFromSyntaxError(error);\n\n    // Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\n    if (location) {\n      const { codeFrameColumns } = require('@babel/code-frame');\n      const codeFrame = codeFrameColumns(contents, { start: error.loc }, { highlightCode: true });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      const importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(\n  error: Error | any\n): { line: number; column?: number } | null {\n  // sucrase provides the `loc` object\n  if (error.loc) {\n    return error.loc;\n  }\n\n  // `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return { line: error.lineNumber, column: error.columnNumber };\n  }\n\n  return null;\n}\n\n// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error: any): string | null {\n  if (isSyntaxError(error)) {\n    const traces = error.stack?.split('\\n').filter(line => !line.startsWith('    at '));\n    if (!traces) return null;\n\n    // Remove redundant line\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\n\nfunction isSyntaxError(error: any): error is SyntaxError {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"],"file":"evalConfig.js"}