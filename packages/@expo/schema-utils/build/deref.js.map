{"version":3,"file":"deref.js","names":["getRef","node","$ref","undefined","parseRefMaybe","ref","props","startIndex","index","char","length","charCodeAt","prop","slice","push","NOT_FOUND_SYMBOL","Symbol","getValueAtPath","input","part","findRefsRec","refs","path","Array","isArray","l","value","targetRef","set","pop","record","key","isSelfReferencingRefEntry","target","source","getSortedRefEntries","entries","sort","a","b","filter","entry","deref","Map","output","nextRef","inputNode","outputNode","targetIndex","sourceValue","rootTargetRef","title","description"],"sources":["../src/deref.ts"],"sourcesContent":["type RefPath = readonly (string | number)[];\n\ninterface NodeRef {\n  $ref: string;\n}\n\n/** Return JSON schema ref if input is of `NodeRef` type */\nconst getRef = (node: NodeRef | unknown): string | undefined =>\n  node != null && typeof node === 'object' && '$ref' in node && typeof node.$ref === 'string'\n    ? node.$ref\n    : undefined;\n\n/** Parse a JSON schema ref into a path array, or return undefined */\nconst parseRefMaybe = (ref: string | undefined): RefPath | undefined => {\n  if (ref == null || ref[0] !== '#') {\n    return undefined;\n  }\n  const props = [];\n  let startIndex = 1;\n  let index = 1;\n  let char: number;\n  while (index < ref.length) {\n    while ((char = ref.charCodeAt(index++)) && char !== 47 /*'/'*/);\n    const prop = ref.slice(startIndex, index - 1);\n    startIndex = index;\n    if (prop) props.push(prop);\n  }\n  return props.length ? props : undefined;\n};\n\nconst NOT_FOUND_SYMBOL = Symbol();\n\n/** Get value at given JSON schema path or return `NOT_FOUND_SYMBOL` */\nconst getValueAtPath = (input: unknown, ref: RefPath): unknown | typeof NOT_FOUND_SYMBOL => {\n  let node = input;\n  for (let index = 0; index < ref.length; index++) {\n    const part = ref[index];\n    if (node != null && typeof node === 'object' && part in node) {\n      node = (node as Record<string, unknown>)[part];\n    } else {\n      node = NOT_FOUND_SYMBOL;\n      break;\n    }\n  }\n  return node;\n};\n\n/** Find all JSON schema refs recursively and add them to `refs` Map */\nconst findRefsRec = (\n  node: unknown,\n  refs: Map<RefPath, RefPath>,\n  path: (string | number)[]\n): void => {\n  if (node == null || typeof node !== 'object') {\n  } else if (Array.isArray(node)) {\n    for (let index = 0, l = node.length; index < l; index++) {\n      const value = node[index];\n      const ref = getRef(value);\n      if (ref) {\n        const targetRef = parseRefMaybe(ref);\n        if (targetRef) refs.set([...path, index], targetRef);\n      } else if (value != null && typeof value === 'object') {\n        path.push(index);\n        findRefsRec(value, refs, path);\n        path.pop();\n      }\n    }\n  } else {\n    const record = node as Record<string, unknown>;\n    for (const key in record) {\n      const value = record[key];\n      const ref = getRef(value);\n      if (ref) {\n        const targetRef = parseRefMaybe(ref);\n        if (targetRef) refs.set([...path, key], targetRef);\n      } else if (value != null && typeof value === 'object') {\n        path.push(key);\n        findRefsRec(value, refs, path);\n        path.pop();\n      }\n    }\n  }\n};\n\n/** Detect whether target (where we set the source value) is a nested path inside the source path */\nconst isSelfReferencingRefEntry = (target: RefPath, source: RefPath) => {\n  for (let index = 0; index < source.length; index++) {\n    if (source[index] !== target[index]) return false;\n  }\n  return true;\n};\n\n/** Return sorted refs entries. Longest target paths will be returned first */\nconst getSortedRefEntries = (refs: Map<RefPath, RefPath>): readonly [RefPath, RefPath][] => {\n  const entries = [...refs.entries()].sort((a, b) => b[1].length - a[1].length);\n  // Filter out self-referenceing paths. If we set nested targets to source values, we'd\n  // create unserializable circular references\n  return entries.filter((entry) => !isSelfReferencingRefEntry(entry[0], entry[1]));\n};\n\n/** Dereference JSON schema pointers.\n *\n * @remarks\n * This is a minimal reimplementation of `json-schema-deref-sync` without\n * file reference, URL/web reference, and loader support.\n *\n * @see https://github.com/cvent/json-schema-deref-sync\n */\nexport function deref(input: any): any {\n  const refs = new Map<RefPath, RefPath>();\n  // Find all JSON schema refs paths\n  findRefsRec(input, refs, []);\n  // Shallow copy output\n  const output = { ...input };\n  // Process all ref entries with deepest targets first\n  nextRef: for (const [target, source] of getSortedRefEntries(refs)) {\n    let inputNode = input;\n    let outputNode = output;\n    let targetIndex = 0;\n    // For each path part on the target, traverse the output and clone the input\n    // to not pollute it\n    for (; targetIndex < target.length - 1; targetIndex++) {\n      const part = target[targetIndex];\n      if (inputNode == null || typeof inputNode !== 'object' || !(part in inputNode)) {\n        // If the part doesn't exist, we abort\n        break;\n      } else if (outputNode[part] === inputNode[part]) {\n        // Copy the input on the output if references are equal\n        outputNode[part] = Array.isArray(inputNode[part])\n          ? [...inputNode[part]]\n          : { ...inputNode[part] };\n        inputNode = inputNode[part];\n        outputNode = outputNode[part];\n      } else {\n        // If this part has already been copied, abort\n        break;\n      }\n    }\n    // For each remaining part on the target, continue traversing the output\n    for (; targetIndex < target.length - 1; targetIndex++) {\n      const part = target[targetIndex];\n      if (outputNode == null || typeof outputNode !== 'object' || !(part in outputNode)) {\n        // If the part doesn't exist, skip the entire ref\n        continue nextRef;\n      } else {\n        outputNode = outputNode[part];\n      }\n    }\n    // Get value from output\n    let sourceValue = getValueAtPath(output, source);\n    if (sourceValue === NOT_FOUND_SYMBOL) {\n      // If no value was found, try to get a value from the input instead\n      sourceValue = getValueAtPath(input, source);\n      // Otherwise, skip this ref\n      if (sourceValue === NOT_FOUND_SYMBOL) continue;\n    }\n    // Set the source value on the target path\n    // The for-loops prior have made sure that the output has already been deeply\n    // cloned and traversed for the entire path\n    outputNode[target[target.length - 1]] = sourceValue;\n  }\n  // Handle root refs last\n  const rootTargetRef = parseRefMaybe(getRef(input));\n  if (rootTargetRef) {\n    // Get value from output\n    let sourceValue = getValueAtPath(output, rootTargetRef);\n    // If no value was found, try to get a value from the input instead\n    if (sourceValue === NOT_FOUND_SYMBOL) {\n      sourceValue = getValueAtPath(input, rootTargetRef);\n    }\n    // Assign the target object to the output\n    if (sourceValue !== NOT_FOUND_SYMBOL && sourceValue != null) {\n      return typeof sourceValue === 'object'\n        ? {\n            ...sourceValue,\n            title: output.title,\n            description: output.description,\n          }\n        : sourceValue;\n    }\n  }\n  // Return the output with resolved refs\n  return output;\n}\n"],"mappings":"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","ignoreList":[]}