<!-- Title -->
<h1 align="center">
ðŸ‘‹ Welcome to <br><code>@expo/schemer</code>
</h1>

<p align="center">A Schema validation library for Expo.</p>

<!-- Body -->

Details can be found here:
* https://paper.dropbox.com/doc/Expo-Schema-Validation-Library-mQU07rRejSnEe4Vf5dkcS

## Usage

### Usage with XDL

```javascript
import { getConfig } from '@expo/config';
import Schemer from '@expo/schemer';

const { exp } = getConfig(projectRoot);
const schema = await getSchemaAsync(exp.sdkVersion);
const validator = new Schemer(require('schema.json'));

validator.validateName('Wilson Zhao');
validator.validateAssets(exp);
```

### Schema-only validation

```javascript
const validator = new Schemer(require('schema.json'));
try {
  await validator.validateSchemaAsync(require('data.json'));
} catch (e) {
  console.error(e);
}
```

### Validating a property

```javascript
const validator = new Schemer(require('schema.json'));
await validator.validateName('Wilson Zhao');
```

## Description

Schemer takes in a custom JSON Schema and uses it to validate various data.

Under the hood, it uses Ajv (https://github.com/epoberezkin/ajv) as the Javascript engine for basic schema validation.
However, each subschema also contains a custom meta tag, which can be parsed for further "manual" validation. As of now, Schemer supports manual validation for assets:

```javascript
{
  meta:
  {
    asset,
    contentType, //mime type
    dimensions: {width, height},
    square,

    // For custom error messages and docs
    regexHuman,
    autogenerated,
    notHuman
  }
}
```

All errors can be accessed in `this.errors`, which has a getter function that combines Ajv JSON Schema errors with custom meta/asset validation errors into a unified array of `ValidationErrors`.
If they exist, the errors are thrown at the end of each public-facing function.

All public-facing functions are async functions because asset validation has to be async (accessing the file-system or making a web request).

## API

#### new Schemer(Object JSON Schema, Object options) -> Object

#### .validateSchemaAsync(Object data) -> Promise

Returns a promise that resolve to `true` if the data is conforms to the schema. Otherwise, it rejects and throws an array of `ValidationError`s.

#### .validateAssetsAsync(Object data) -> Promise

Returns a promise that resolve to `true` if the data is conforms to the additional validation steps found in each meta tag. For example, it will download an asset and read the header of the file to see if it is a certain content type.
Otherwise, it rejects and throws an array of `ValidationError`s.

#### .validateAll(Object data) -> Promise

Runs both `.validateSchemaAsync` and `.validateAssetsAsync`.
Returns a promise that resolve to `true` if the data passes both functions. Otherwise, it rejects and throws an array of `ValidationError`s.

#### .validateProperty(String fieldPath, Object data) -> Promise

Extracts the subSchema for the given field path and validates the data against it. Also checks for the meta tag.
Returns a promise that resolve to `true` if the data conforms to the subschema. Otherwise, it rejects and throws an array of `ValidationError`s.

#### .errors

Contains an array of ValidationErrors

#### new ValidationError({errorCode, fieldPath, message, data, meta}) -> Object
