{"version":3,"file":"Image.js","sourceRoot":"","sources":["../src/Image.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Platform, createSnapshotFriendlyRef } from 'expo-modules-core';\nimport React from 'react';\nimport { StyleSheet } from 'react-native';\n\nimport ExpoImage, { ExpoImageModule } from './ExpoImage';\nimport { ImagePrefetchOptions, ImageProps } from './Image.types';\nimport { resolveContentFit, resolveContentPosition, resolveTransition } from './utils';\nimport { resolveSources } from './utils/resolveSources';\n\nlet loggedDefaultSourceDeprecationWarning = false;\n\nexport class Image extends React.PureComponent<ImageProps> {\n  nativeViewRef;\n  containerViewRef;\n  constructor(props) {\n    super(props);\n    this.nativeViewRef = createSnapshotFriendlyRef();\n    this.containerViewRef = createSnapshotFriendlyRef();\n  }\n\n  // Reanimated support on web\n  getAnimatableRef = () => {\n    if (Platform.OS === 'web') {\n      return this.containerViewRef.current;\n    } else {\n      return this;\n    }\n  };\n\n  /**\n   * Preloads images at the given URLs that can be later used in the image view.\n   * Preloaded images are cached to the memory and disk by default, so make sure\n   * to use `disk` (default) or `memory-disk` [cache policy](#cachepolicy).\n   * @param urls - A URL string or an array of URLs of images to prefetch.\n   * @param {ImagePrefetchOptions['cachePolicy']} cachePolicy - The cache policy for prefetched images.\n   * @return A promise resolving to `true` as soon as all images have been\n   * successfully prefetched. If an image fails to be prefetched, the promise\n   * will immediately resolve to `false` regardless of whether other images have\n   * finished prefetching.\n   */\n  static async prefetch(\n    urls: string | string[],\n    cachePolicy?: ImagePrefetchOptions['cachePolicy']\n  ): Promise<boolean>;\n  /**\n   * Preloads images at the given URLs that can be later used in the image view.\n   * Preloaded images are cached to the memory and disk by default, so make sure\n   * to use `disk` (default) or `memory-disk` [cache policy](#cachepolicy).\n   * @param urls - A URL string or an array of URLs of images to prefetch.\n   * @param options - Options for prefetching images.\n   * @return A promise resolving to `true` as soon as all images have been\n   * successfully prefetched. If an image fails to be prefetched, the promise\n   * will immediately resolve to `false` regardless of whether other images have\n   * finished prefetching.\n   */\n  static async prefetch(urls: string | string[], options?: ImagePrefetchOptions): Promise<boolean>;\n  static async prefetch(\n    urls: string | string[],\n    options?: ImagePrefetchOptions['cachePolicy'] | ImagePrefetchOptions\n  ): Promise<boolean> {\n    let cachePolicy: ImagePrefetchOptions['cachePolicy'] = 'memory-disk';\n    let headers: ImagePrefetchOptions['headers'];\n    switch (typeof options) {\n      case 'string':\n        cachePolicy = options;\n        break;\n      case 'object':\n        cachePolicy = options.cachePolicy ?? cachePolicy;\n        headers = options.headers;\n        break;\n    }\n\n    return ExpoImageModule.prefetch(Array.isArray(urls) ? urls : [urls], cachePolicy, headers);\n  }\n\n  /**\n   * Asynchronously clears all images stored in memory.\n   * @platform android\n   * @platform ios\n   * @return A promise resolving to `true` when the operation succeeds.\n   * It may resolve to `false` on Android when the activity is no longer available.\n   * Resolves to `false` on Web.\n   */\n  static async clearMemoryCache(): Promise<boolean> {\n    return await ExpoImageModule.clearMemoryCache();\n  }\n\n  /**\n   * Asynchronously clears all images from the disk cache.\n   * @platform android\n   * @platform ios\n   * @return A promise resolving to `true` when the operation succeeds.\n   * It may resolve to `false` on Android when the activity is no longer available.\n   * Resolves to `false` on Web.\n   */\n  static async clearDiskCache(): Promise<boolean> {\n    return await ExpoImageModule.clearDiskCache();\n  }\n\n  /**\n   * Asynchronously checks if an image exists in the disk cache and resolves to\n   * the path of the cached image if it does.\n   * @param cacheKey - The cache key for the requested image. Unless you have set\n   * a custom cache key, this will be the source URL of the image.\n   * @platform android\n   * @platform ios\n   * @return A promise resolving to the path of the cached image. It will resolve\n   * to `null` if the image does not exist in the cache.\n   */\n  static async getCachePathAsync(cacheKey: string): Promise<string | null> {\n    return await ExpoImageModule.getCachePathAsync(cacheKey);\n  }\n\n  /**\n   * Asynchronously generates a [Blurhash](https://blurha.sh) from an image.\n   * @param url - The URL of the image to generate a blurhash from.\n   * @param numberOfComponents - The number of components to encode the blurhash with.\n   * Must be between 1 and 9. Defaults to `[4, 3]`.\n   * @platform ios\n   * @return A promise resolving to the blurhash string.\n   */\n  static async generateBlurhashAsync(\n    url: string,\n    numberOfComponents: [number, number] | { width: number; height: number }\n  ): Promise<string | null> {\n    return await ExpoImageModule.generateBlurhashAsync(url, numberOfComponents);\n  }\n\n  /**\n   * Asynchronously starts playback of the view's image if it is animated.\n   * @platform android\n   * @platform ios\n   */\n  async startAnimating(): Promise<void> {\n    await this.nativeViewRef.current.startAnimating();\n  }\n\n  /**\n   * Asynchronously stops the playback of the view's image if it is animated.\n   * @platform android\n   * @platform ios\n   */\n  async stopAnimating(): Promise<void> {\n    await this.nativeViewRef.current.stopAnimating();\n  }\n\n  render() {\n    const {\n      style,\n      source,\n      placeholder,\n      contentFit,\n      contentPosition,\n      transition,\n      fadeDuration,\n      resizeMode: resizeModeProp,\n      defaultSource,\n      loadingIndicatorSource,\n      ...restProps\n    } = this.props;\n\n    const { resizeMode: resizeModeStyle, ...restStyle } = StyleSheet.flatten(style) || {};\n    const resizeMode = resizeModeProp ?? resizeModeStyle;\n\n    if ((defaultSource || loadingIndicatorSource) && !loggedDefaultSourceDeprecationWarning) {\n      console.warn(\n        '[expo-image]: `defaultSource` and `loadingIndicatorSource` props are deprecated, use `placeholder` instead'\n      );\n      loggedDefaultSourceDeprecationWarning = true;\n    }\n\n    return (\n      <ExpoImage\n        {...restProps}\n        style={restStyle}\n        source={resolveSources(source)}\n        placeholder={resolveSources(placeholder ?? defaultSource ?? loadingIndicatorSource)}\n        contentFit={resolveContentFit(contentFit, resizeMode)}\n        contentPosition={resolveContentPosition(contentPosition)}\n        transition={resolveTransition(transition, fadeDuration)}\n        nativeViewRef={this.nativeViewRef}\n        containerViewRef={this.containerViewRef}\n      />\n    );\n  }\n}\n"]}