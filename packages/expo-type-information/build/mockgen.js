#!/usr/bin/env node
'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTSMockForModule = generateTSMockForModule;
exports.generateMocks = generateMocks;
exports.getAllExpoModulesInWorkingDirectory = getAllExpoModulesInWorkingDirectory;
const fs_1 = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const typeInformation_1 = require("./typeInformation");
const typescriptGeneration_1 = require("./typescriptGeneration");
const directoryPath = process.cwd();
const prefix = `Automatically generated by expo-type-information.

This autogenerated file provides a mock for native Expo module,
and works out of the box with the expo jest preset.
`;
const newlineIdentifier = typescript_1.default.factory.createIdentifier('\n\n');
function maybeWrapWithReturnStatement(type, fileTypeInformation) {
    if (type.kind === typeInformation_1.TypeKind.BASIC) {
        const basicType = type.type;
        if (basicType === typeInformation_1.BasicType.VOID || basicType === typeInformation_1.BasicType.ANY) {
            return [];
        }
    }
    // TODO Maybe add a fallback similar to original, when we cannot provide return statement
    return [typescript_1.default.factory.createReturnStatement(getMockedValueForType(type, fileTypeInformation))];
}
function getPrefix() {
    return [typescript_1.default.factory.createJSDocComment(prefix)];
}
function getBasicTypeMockLiteral(type) {
    switch (type) {
        case typeInformation_1.BasicType.STRING:
            return typescript_1.default.factory.createStringLiteral('');
        case typeInformation_1.BasicType.BOOLEAN:
            return typescript_1.default.factory.createFalse();
        case typeInformation_1.BasicType.NUMBER:
            return typescript_1.default.factory.createNumericLiteral(0);
        case typeInformation_1.BasicType.VOID:
        case typeInformation_1.BasicType.UNDEFINED:
        case typeInformation_1.BasicType.ANY:
        default:
            return undefined;
    }
}
function getBasicTypeFromString(basicType) {
    switch (basicType) {
        case 'any':
            return typeInformation_1.BasicType.ANY;
        case 'number':
            return typeInformation_1.BasicType.NUMBER;
        case 'string':
            return typeInformation_1.BasicType.STRING;
        case 'boolean':
            return typeInformation_1.BasicType.BOOLEAN;
    }
    return undefined;
}
function getMockedEnumInstance(enumType) {
    if (enumType.cases.length === 0) {
        return undefined;
    }
    return typescript_1.default.factory.createPropertyAccessExpression(typescript_1.default.factory.createRegularExpressionLiteral(enumType.name), enumType.cases[0]);
}
function getMockedRecordInstance(recordType, fileTypeInformation) {
    return typescript_1.default.factory.createObjectLiteralExpression(recordType.fields.map((f) => typescript_1.default.factory.createPropertyAssignment(f.name, getMockedValueForType(f.type, fileTypeInformation) ?? typescript_1.default.factory.createNull())));
}
function getMockValueForIdentifier(identifier, fileTypeInformation) {
    if (!fileTypeInformation.typeIdentifierDefinitionMap.has(identifier)) {
        return undefined;
    }
    const typeDefinition = fileTypeInformation.typeIdentifierDefinitionMap.get(identifier);
    switch (typeDefinition?.kind) {
        case typeInformation_1.IdentifierKind.BASIC: {
            const basicType = getBasicTypeFromString(typeDefinition.definition);
            if (basicType) {
                return getBasicTypeMockLiteral(basicType);
            }
            return undefined;
        }
        case typeInformation_1.IdentifierKind.ENUM:
            return getMockedEnumInstance(typeDefinition.definition);
        case typeInformation_1.IdentifierKind.RECORD:
            return getMockedRecordInstance(typeDefinition.definition, fileTypeInformation);
    }
    return undefined;
}
function getMockedValueForType(type, fileTypeInformation) {
    switch (type.kind) {
        case typeInformation_1.TypeKind.BASIC:
            return getBasicTypeMockLiteral(type.type);
        case typeInformation_1.TypeKind.IDENTIFIER:
            return getMockValueForIdentifier(type.type, fileTypeInformation);
        case typeInformation_1.TypeKind.SUM:
            return getMockedValueForType(type.type.types[0], fileTypeInformation);
        case typeInformation_1.TypeKind.PARAMETRIZED:
            return typescript_1.default.factory.createNull();
        case typeInformation_1.TypeKind.OPTIONAL:
            return getMockedValueForType(type.type, fileTypeInformation);
        case typeInformation_1.TypeKind.ARRAY:
            return typescript_1.default.factory.createArrayLiteralExpression();
        case typeInformation_1.TypeKind.DICTIONARY:
            return typescript_1.default.factory.createObjectLiteralExpression();
    }
}
function getFunctionReturnBlock(functionDeclaration, fileTypeInformation) {
    return maybeWrapWithReturnStatement(functionDeclaration.returnType, fileTypeInformation);
}
function getMockedFunctionDeclaration(functionDeclaration, fileTypeInformation, async, exported) {
    return (0, typescriptGeneration_1.getTsFunction)(functionDeclaration, async, false, exported, false, maybeWrapWithReturnStatement(functionDeclaration.returnType, fileTypeInformation));
}
function getMockedClass(classDeclaration, fileTypeInformation) {
    return (0, typescriptGeneration_1.getTsClass)(classDeclaration, fileTypeInformation, true, false, getFunctionReturnBlock);
}
function getMockedView(viewDeclaration) {
    const propsTypeName = (0, typescriptGeneration_1.getViewPropsTypeName)(viewDeclaration);
    const propsType = (0, typescriptGeneration_1.getPropsTypeDeclaration)(propsTypeName, viewDeclaration.props, viewDeclaration.events);
    const propsParameter = typescript_1.default.factory.createParameterDeclaration(undefined, undefined, 'props', undefined, typescript_1.default.factory.createTypeReferenceNode(propsTypeName, undefined), undefined);
    const viewFunction = typescript_1.default.factory.createFunctionDeclaration([typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], undefined, (viewDeclaration.name?.length ?? 0) > 0 ? viewDeclaration.name : 'View', undefined, [propsParameter], undefined, typescript_1.default.factory.createBlock([]));
    return [...propsType, viewFunction];
}
function getMockForModule(module, fileTypeInformation) {
    const undeclaredTypeIdentifiers = fileTypeInformation.usedTypeIdentifiers
        .difference(fileTypeInformation.declaredTypeIdentifiers)
        .difference((0, typescriptGeneration_1.basicTypesIdentifiers)());
    return []
        .concat(getPrefix(), newlineIdentifier, [...undeclaredTypeIdentifiers].map((identifier) => (0, typescriptGeneration_1.getIdentifierUnknownDeclaration)(identifier, fileTypeInformation.typeParametersCount)), newlineIdentifier, fileTypeInformation.records.flatMap(typescriptGeneration_1.getRecordDeclaration), newlineIdentifier, fileTypeInformation.enums.flatMap(typescriptGeneration_1.getEnumDeclaration), newlineIdentifier, module.functions.map((f) => getMockedFunctionDeclaration(f, fileTypeInformation, false, true)), module.asyncFunctions.map((f) => getMockedFunctionDeclaration(f, fileTypeInformation, true, true)), module.classes.map((c) => getMockedClass(c, fileTypeInformation)), module.views.map((v) => getMockedView(v)).flat())
        .flat();
}
function generateTSMockForModule(module, fileTypeInformation, includeTypes) {
    const mockFileName = module.name + (includeTypes ? '.ts' : '.js');
    const mock = typescript_1.default.factory.createNodeArray(getMockForModule(module, fileTypeInformation));
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    // get ts nodearray from getMockForModule(m) array
    const resultFile = typescript_1.default.createSourceFile(mockFileName, '', typescript_1.default.ScriptTarget.Latest, false, typescript_1.default.ScriptKind.TSX);
    const printedTs = printer.printList(typescript_1.default.ListFormat.MultiLine + typescript_1.default.ListFormat.PreserveLines, mock, resultFile);
    if (includeTypes) {
        return printedTs;
    }
    return typescript_1.default.transpileModule(printedTs, {
        compilerOptions: {
            module: typescript_1.default.ModuleKind.ESNext,
            target: typescript_1.default.ScriptTarget.ESNext,
        },
    }).outputText;
}
async function generateMocks(files, outputLanguage = 'javascript') {
    if (files.length > 0) {
        fs_1.default.mkdirSync(path_1.default.join(directoryPath, 'mocks'), { recursive: true });
    }
    for (const file of files) {
        for (const module of file.moduleClasses) {
            const mockFileName = module.name + (outputLanguage === 'typescript' ? '.ts' : '.js');
            const mockFilePath = path_1.default.join(directoryPath, 'mocks', mockFileName);
            const printedCode = generateTSMockForModule(module, file, outputLanguage === 'typescript');
            if (outputLanguage === 'javascript') {
                const prettifiedJs = await (0, typescriptGeneration_1.prettifyCode)(printedCode);
                fs_1.default.writeFileSync(mockFilePath, prettifiedJs);
            }
            else {
                const prettifiedTs = await (0, typescriptGeneration_1.prettifyCode)(printedCode, 'typescript');
                fs_1.default.writeFileSync(mockFilePath, prettifiedTs);
            }
        }
    }
}
const rootDir = process.cwd();
const pattern = `${rootDir}/**/*.swift`;
function getAllExpoModulesInWorkingDirectory() {
    const files = (0, fs_1.globSync)(pattern);
    return files
        .map((file) => (0, typeInformation_1.getFileTypeInformation)(fs_1.default.realpathSync(file)))
        .filter((f) => f);
}
//# sourceMappingURL=mockgen.js.map