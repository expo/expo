{"version":3,"file":"typeInformation.js","sourceRoot":"","sources":["../src/typeInformation.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\n\nimport {\n  getSwiftFileTypeInformation,\n  preprocessSwiftFile,\n} from './swift/sourcekittenTypeInformation';\n\nexport enum IdentifierKind {\n  BASIC,\n  ENUM,\n  RECORD,\n  CLASS,\n}\n\nexport type ParametrizedType = {\n  name: TypeIdentifier;\n  types: Type[];\n};\n\nexport type Argument = { name: string | undefined; type: Type };\nexport type Field = Argument;\n\nexport type RecordType = {\n  name: string;\n  fields: Field[];\n};\n\nexport type EnumCase = string;\n\nexport type EnumType = {\n  name: string;\n  cases: EnumCase[];\n};\n\nexport type SumType = {\n  types: Type[];\n};\n\nexport type DictionaryType = {\n  key: Type;\n  value: Type;\n};\n\nexport type OptionalType = Type;\nexport type ArrayType = Type;\nexport type TypeIdentifier = string;\nexport type AnonymousType = ParametrizedType | SumType | OptionalType | DictionaryType | ArrayType;\n\nexport enum TypeKind {\n  BASIC,\n  IDENTIFIER,\n  SUM,\n  PARAMETRIZED,\n  OPTIONAL,\n  ARRAY,\n  DICTIONARY,\n}\n\nexport enum BasicType {\n  ANY,\n  STRING,\n  NUMBER,\n  BOOLEAN,\n  VOID,\n  UNDEFINED,\n  UNRESOLVED,\n}\n\nexport type Type = {\n  kind: TypeKind;\n  type: BasicType | TypeIdentifier | AnonymousType;\n};\n\nexport type PropertyDeclaration = ConstantDeclaration;\nexport type ViewDeclaration = ModuleClassDeclaration;\nexport type EventDeclaration = string;\n\nexport type ConstantDeclaration = {\n  name: string;\n  type: Type;\n};\n\nexport type FunctionDeclaration = {\n  name: string;\n  returnType: Type;\n  arguments: Argument[];\n  parameters: Type[];\n};\n\nexport type PropDeclaration = {\n  name: string;\n  arguments: Argument[];\n};\n\nexport type ConstructorDeclaration = {\n  arguments: Argument[];\n};\n\nexport type ClassDeclaration = {\n  name: string;\n  constructor: ConstructorDeclaration | null;\n  methods: FunctionDeclaration[];\n  asyncMethods: FunctionDeclaration[];\n  properties: PropertyDeclaration[];\n};\n\nexport type ModuleClassDeclaration = {\n  name: string;\n  constructor: ConstructorDeclaration | null;\n  constants: ConstantDeclaration[];\n  classes: ClassDeclaration[];\n  functions: FunctionDeclaration[];\n  asyncFunctions: FunctionDeclaration[];\n  properties: PropertyDeclaration[];\n  props: PropDeclaration[];\n  views: ViewDeclaration[];\n  events: EventDeclaration[];\n};\n\nexport type TypeIdentifierDefinitionMap = Map<\n  string,\n  { kind: IdentifierKind; definition: string | RecordType | EnumType | ClassDeclaration }\n>;\n\nexport type TypeIdentifierDefinitionList = [\n  string,\n  { kind: IdentifierKind; definition: string | RecordType | EnumType | ClassDeclaration },\n][];\n\nexport type FileTypeInformationSerialized = {\n  usedTypeIdentifiersList: string[];\n  declaredTypeIdentifiersList: string[];\n  inferredTypeParametersCountList: [string, number][];\n  typeIdentifierDefinitionList: TypeIdentifierDefinitionList;\n  moduleClasses: ModuleClassDeclaration[];\n  records: RecordType[];\n  enums: EnumType[];\n};\n\n/**\n * FileTypeInformation object abstracts over type related information in a file.\n * The abstraction is closely related to Typescript and expo NativeModules (both to be independent of the actual native side\n * and to give accurate information about what and how we can use the given module).\n */\nexport type FileTypeInformation = {\n  /**\n   * @field Set of all type identifiers declared and used in the file.\n   */\n  usedTypeIdentifiers: Set<string>;\n  /**\n   * @field Set of all type identifiers declared in the file.\n   */\n  declaredTypeIdentifiers: Set<string>;\n  /**\n   * @field For parametrized types it is the maximum number of parameters this type is used with.\n   * This map is useful if we want to infer how many parameters a type declared in other file has.\n   *\n   * For example if `Set<string>` exists in a file then inferredTypeParametersCount['Set'] == 1.\n   * If `Map<number, string>` exists then inferredTypeParametersCount['Map'] == 2.\n   * If you use both `SomeParametrizedType<Type1, Type2>` and `SomeParametrizedType<Type3>` then inferredTypeParametersCount['SomeParametrizedType'] == 2.\n   */\n  inferredTypeParametersCount: Map<string, number>;\n  /**\n   * @field Maps string identifier to the appropriate declaration object. For now only enum and records identifiers are mapped.\n   */\n  typeIdentifierDefinitionMap: TypeIdentifierDefinitionMap;\n  /**\n   * @field Array of all module classes declared in the given file.\n   */\n  moduleClasses: ModuleClassDeclaration[];\n  /**\n   * @field Array of all record classes declared in the given file.\n   */\n  records: RecordType[];\n  /**\n   * @field Array of all enums declared in the given file.\n   */\n  enums: EnumType[];\n};\n\n/**\n * Used for testing purposes, maps Sets and Maps to Arrays and returns FileTypeInformationSerialized object which can be written to a JSON.\n * @param param0 FileTypeInformation object to serialize.\n * @returns FileTypeInformationSerialized object.\n */\nexport function serializeTypeInformation({\n  usedTypeIdentifiers,\n  declaredTypeIdentifiers,\n  inferredTypeParametersCount,\n  typeIdentifierDefinitionMap,\n  moduleClasses,\n  records,\n  enums,\n}: FileTypeInformation): FileTypeInformationSerialized {\n  return {\n    usedTypeIdentifiersList: [...usedTypeIdentifiers.keys()].sort(),\n    declaredTypeIdentifiersList: [...declaredTypeIdentifiers.keys()].sort(),\n    inferredTypeParametersCountList: [...inferredTypeParametersCount.entries()].sort(),\n    typeIdentifierDefinitionList: [...typeIdentifierDefinitionMap.entries()].sort(),\n    moduleClasses,\n    records,\n    enums,\n  };\n}\n\n/**\n * Used for testing purposes, maps Arrays to Sets and Maps depending on the field and returns FileTypeInformation object.\n * @param param0 FileTypeInformationSerialized object to deserialize.\n * @returns FileTypeInformation object.\n */\nexport function deserializeTypeInformation({\n  usedTypeIdentifiersList,\n  declaredTypeIdentifiersList,\n  inferredTypeParametersCountList,\n  typeIdentifierDefinitionList,\n  moduleClasses,\n  records,\n  enums,\n}: FileTypeInformationSerialized): FileTypeInformation {\n  return {\n    usedTypeIdentifiers: new Set<string>(usedTypeIdentifiersList),\n    declaredTypeIdentifiers: new Set<string>(declaredTypeIdentifiersList),\n    inferredTypeParametersCount: new Map<string, number>(inferredTypeParametersCountList),\n    typeIdentifierDefinitionMap: new Map(typeIdentifierDefinitionList),\n    moduleClasses,\n    records,\n    enums,\n  };\n}\n\n/**\n * This function reads and extracts FileTypeInformation from a given file.\n * @param absoluteFilePath Absolute path to a Swift/Kotlin file.\n * @param preprocessFile If this flag is set to true and Swift file is provided, then the file is preprocessed so that more type information can be inferred.\n *  For now this option is slow so it's not enabled by default.\n * @returns FileTypeInformation object if the file provided was .swift file and it was parsed successfully. Otherwise it returns null.\n */\nexport function getFileTypeInformation(\n  absoluteFilePath: string,\n  preprocessFile: boolean = false\n): FileTypeInformation | null {\n  if (absoluteFilePath.endsWith('.swift')) {\n    if (preprocessFile) {\n      return getFileTypeInformationForString(\n        fs.readFileSync(absoluteFilePath, 'utf-8'),\n        'Swift',\n        true\n      );\n    }\n    return getSwiftFileTypeInformation(absoluteFilePath);\n  }\n  return null;\n}\n\n/**\n * This function creates a temporary file with the provided content and extracts FileTypeInformation from it.\n * @param content Swift code.\n * @param language For now only Swift is supported.\n * @param preprocessFile If this flag is set to true and Swift file is provided, then the file is preprocessed so that more type information can be inferred.\n *  For now this option is slow so it's not enabled by default.\n * @returns FileTypeInformation object if the content provided was Swift and was parsed successfully. Otherwise it returns null.\n */\nexport function getFileTypeInformationForString(\n  content: string,\n  language: 'Swift',\n  preprocessFile: boolean = false\n): FileTypeInformation | null {\n  if (language === 'Swift') {\n    const tmp = os.tmpdir();\n    const filePath = path.resolve(tmp, 'TypeInformationTemporaryFile.swift');\n    const preprocessedContent = preprocessFile ? preprocessSwiftFile(content) : content;\n    fs.writeFileSync(filePath, preprocessedContent, 'utf8');\n    const fileTypeInfo = getFileTypeInformation(filePath);\n    fs.rmSync(filePath);\n    return fileTypeInfo;\n  }\n  return null;\n}\n"]}