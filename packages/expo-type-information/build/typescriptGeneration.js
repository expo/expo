'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPropsTypeDeclaration = getPropsTypeDeclaration;
exports.wrapWithPromise = wrapWithPromise;
exports.getArgumentDeclaration = getArgumentDeclaration;
exports.getTsFunction = getTsFunction;
exports.mapTypeToTsTypeNode = mapTypeToTsTypeNode;
exports.getClassConstructorDeclaration = getClassConstructorDeclaration;
exports.getTsClass = getTsClass;
exports.getIdentifierUnknownDeclaration = getIdentifierUnknownDeclaration;
exports.getTypeAliasDeclaration = getTypeAliasDeclaration;
exports.getRecordDeclaration = getRecordDeclaration;
exports.getEnumDeclaration = getEnumDeclaration;
exports.getViewPropsTypeName = getViewPropsTypeName;
exports.prettifyCode = prettifyCode;
exports.basicTypesIdentifiers = basicTypesIdentifiers;
exports.getGeneratedViewTypesFileContent = getGeneratedViewTypesFileContent;
exports.getGeneratedModuleTypesFileContent = getGeneratedModuleTypesFileContent;
const prettier_1 = __importDefault(require("prettier"));
const typescript_1 = __importDefault(require("typescript"));
const path_1 = __importDefault(require("path"));
const typeInformation_1 = require("./typeInformation");
const prefix = `Automatically generated by expo-type-information.

This autogenerated file provides TS types for native Expo module or view,
and works out of the box with inline modules.
`;
function getPrefix() {
    return [typescript_1.default.factory.createJSDocComment(prefix)];
}
function getUnresolvedTypesNamespaceNameForFile(filePath) {
    const fileNameWithExtension = path_1.default.basename(filePath);
    return fileNameWithExtension.slice(0, fileNameWithExtension.lastIndexOf('.')) + 'Types';
}
const newlineIdentifier = typescript_1.default.factory.createIdentifier('\n\n');
function getOneNamedImport(importedName, importFromName) {
    return typescript_1.default.factory.createImportDeclaration(undefined, typescript_1.default.factory.createImportClause(undefined, undefined, typescript_1.default.factory.createNamedImports([
        typescript_1.default.factory.createImportSpecifier(false, undefined, typescript_1.default.factory.createIdentifier(importedName)),
    ])), typescript_1.default.factory.createStringLiteral(importFromName), undefined);
}
function getPropEventElementDeclaration(eventDeclaration) {
    return typescript_1.default.factory.createPropertySignature(undefined, eventDeclaration, undefined, typescript_1.default.factory.createFunctionTypeNode(undefined, [
        typescript_1.default.factory.createParameterDeclaration(undefined, undefined, 'event', undefined, typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword)),
    ], typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.VoidKeyword)));
}
function getPropTypeElementDeclaration(propDeclaration) {
    if (!propDeclaration || !propDeclaration.arguments || propDeclaration.arguments.length < 2) {
        return undefined;
    }
    return typescript_1.default.factory.createPropertySignature(undefined, propDeclaration.name, undefined, mapTypeToTsTypeNode(propDeclaration.arguments[1].type));
}
function getPropsTypeDeclaration(propsTypeName, propsDeclaration, events, exported = true) {
    return [].concat(typescript_1.default.factory.createTypeAliasDeclaration(exported ? [typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)] : [], propsTypeName, undefined, typescript_1.default.factory.createTypeLiteralNode([
        ...propsDeclaration
            .map(getPropTypeElementDeclaration)
            .filter((p) => p),
        ...events.map(getPropEventElementDeclaration),
    ])));
}
function wrapWithPromise(typeNode) {
    return typescript_1.default.factory.createTypeReferenceNode('Promise', [typeNode]);
}
function getClassPropertyDeclaration(declaration) {
    return typescript_1.default.factory.createPropertyDeclaration([typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ReadonlyKeyword)], declaration.name, undefined, mapTypeToTsTypeNode(declaration.type), undefined);
}
function getClassDeclarationInModule(classDeclaration) {
    return typescript_1.default.factory.createPropertyDeclaration(undefined, classDeclaration.name, undefined, 
    // TODO that's a hack, but I couldn't find a proper way to do this
    // The problem is that declare class semantics seem somewhat different than class semantics.
    typescript_1.default.factory.createTypeReferenceNode('typeof ' + classDeclaration.name), undefined);
}
function getExportDeclareModifiers() {
    return [
        typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword),
        typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.DeclareKeyword),
    ];
}
function getExportedModuleDeclaration(moduleClassDeclaration) {
    return [
        typescript_1.default.factory.createClassDeclaration(getExportDeclareModifiers(), moduleClassDeclaration.name, undefined, [
            typescript_1.default.factory.createHeritageClause(typescript_1.default.SyntaxKind.ExtendsKeyword, [
                typescript_1.default.factory.createExpressionWithTypeArguments(typescript_1.default.factory.createIdentifier('NativeModule'), undefined),
            ]),
        ], [].concat(moduleClassDeclaration.constants.map(getClassPropertyDeclaration), moduleClassDeclaration.properties.map(getClassPropertyDeclaration), moduleClassDeclaration.functions.map(getSyncMethodDeclaration), moduleClassDeclaration.asyncFunctions.map(getAsyncMethodDeclaration), moduleClassDeclaration.classes.map(getClassDeclarationInModule))),
    ];
}
function getArgumentDeclaration(arg) {
    const optional = arg.type.kind === typeInformation_1.TypeKind.OPTIONAL;
    const argType = optional ? arg.type.type : arg.type;
    return typescript_1.default.factory.createParameterDeclaration(undefined, undefined, arg.name, optional ? typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken) : undefined, mapTypeToTsTypeNode(argType), undefined);
}
function getAsyncMethodDeclaration(functionDeclaration) {
    return getTsFunction(functionDeclaration, true, true, false, true);
}
function getSyncMethodDeclaration(functionDeclaration) {
    return getTsFunction(functionDeclaration, false, true, false, true);
}
function getTsFunction(functionDeclaration, async, method, exported, declaration, returnStatement) {
    const functionModifiers = [];
    const customReturn = !!returnStatement;
    let returnTypeNode = mapTypeToTsTypeNode(functionDeclaration.returnType);
    if (exported) {
        functionModifiers.push(typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword));
    }
    if (async) {
        returnTypeNode = wrapWithPromise(returnTypeNode);
        if (!declaration) {
            functionModifiers.push(typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.AsyncKeyword));
        }
    }
    if (method) {
        return typescript_1.default.factory.createMethodDeclaration(functionModifiers, undefined, functionDeclaration.name, undefined, undefined, functionDeclaration.arguments.map(getArgumentDeclaration), returnTypeNode, declaration ? undefined : typescript_1.default.factory.createBlock(customReturn ? returnStatement : []));
    }
    return typescript_1.default.factory.createFunctionDeclaration(functionModifiers, undefined, functionDeclaration.name, undefined, functionDeclaration.arguments.map(getArgumentDeclaration), returnTypeNode, declaration ? undefined : typescript_1.default.factory.createBlock(customReturn ? returnStatement : []));
}
function mapBasicTypeToTsNode(basicType) {
    if (basicType === typeInformation_1.BasicType.UNRESOLVED) {
        return typescript_1.default.addSyntheticTrailingComment(typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UnknownKeyword), typescript_1.default.SyntaxKind.MultiLineCommentTrivia, "The type couldn't be resolved automatically.");
    }
    return typescript_1.default.factory.createKeywordTypeNode((() => {
        switch (basicType) {
            case typeInformation_1.BasicType.ANY:
                return typescript_1.default.SyntaxKind.AnyKeyword;
            case typeInformation_1.BasicType.BOOLEAN:
                return typescript_1.default.SyntaxKind.BooleanKeyword;
            case typeInformation_1.BasicType.NUMBER:
                return typescript_1.default.SyntaxKind.NumberKeyword;
            case typeInformation_1.BasicType.STRING:
                return typescript_1.default.SyntaxKind.StringKeyword;
            case typeInformation_1.BasicType.VOID:
                return typescript_1.default.SyntaxKind.VoidKeyword;
            case typeInformation_1.BasicType.UNDEFINED:
                return typescript_1.default.SyntaxKind.UndefinedKeyword;
        }
    })());
}
function createDictionaryTypeNode(type) {
    return typescript_1.default.factory.createTypeLiteralNode([
        typescript_1.default.factory.createIndexSignature(undefined, [
            typescript_1.default.factory.createParameterDeclaration(undefined, undefined, 'key', undefined, mapTypeToTsTypeNode(type.key), undefined),
        ], mapTypeToTsTypeNode(type.value)),
    ]);
}
function mapTypeToTsTypeNode(type) {
    switch (type.kind) {
        case typeInformation_1.TypeKind.BASIC:
            return mapBasicTypeToTsNode(type.type);
        case typeInformation_1.TypeKind.IDENTIFIER:
            return typescript_1.default.factory.createTypeReferenceNode(type.type);
        case typeInformation_1.TypeKind.SUM:
            return typescript_1.default.factory.createUnionTypeNode(type.type.types.map(mapTypeToTsTypeNode));
        case typeInformation_1.TypeKind.ARRAY:
            return typescript_1.default.factory.createArrayTypeNode(mapTypeToTsTypeNode(type.type));
        case typeInformation_1.TypeKind.DICTIONARY:
            return createDictionaryTypeNode(type.type);
        // Technically this one should only be the top one and it should be handled somewhere else
        // for example when creating arguemnt adding the '?' token.
        //
        // However we can just make it (type | undefined) in here.
        // TODO Maybe also need null?
        case typeInformation_1.TypeKind.OPTIONAL:
            return typescript_1.default.factory.createUnionTypeNode([
                mapTypeToTsTypeNode(type.type),
                mapBasicTypeToTsNode(typeInformation_1.BasicType.UNDEFINED),
            ]);
        case typeInformation_1.TypeKind.PARAMETRIZED:
            return typescript_1.default.factory.createTypeReferenceNode(type.type.name, type.type.types.map(mapTypeToTsTypeNode));
    }
    return mapBasicTypeToTsNode(typeInformation_1.BasicType.UNRESOLVED);
}
function getClassConstructorDeclaration(constructor, declaration = true) {
    return typescript_1.default.factory.createConstructorDeclaration(undefined, constructor.arguments.map(getArgumentDeclaration), declaration ? undefined : typescript_1.default.factory.createBlock([]));
}
// TODO figure out what about inheritance, should or should not inherit SharedObject
function getTsClass(classDeclaration, fileTypeInformation, exported, declaration, getFunctionReturnBlock) {
    const classModifiers = [];
    if (exported) {
        classModifiers.push(typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword));
    }
    if (declaration) {
        classModifiers.push(typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.DeclareKeyword));
    }
    const constructorDeclaration = classDeclaration.constructor
        ? getClassConstructorDeclaration(classDeclaration.constructor, declaration)
        : undefined;
    return typescript_1.default.factory.createClassDeclaration(classModifiers, typescript_1.default.factory.createIdentifier(classDeclaration.name), undefined, [], 
    // [
    //   ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
    //     ts.factory.createExpressionWithTypeArguments(
    //       ts.factory.createIdentifier('SharedObject'),
    //       undefined
    //     ),
    //   ]),
    // ],
    []
        .concat(classDeclaration.methods.map((method) => getTsFunction(method, false, true, false, declaration, !declaration && getFunctionReturnBlock
        ? getFunctionReturnBlock(method, fileTypeInformation)
        : null)), classDeclaration.asyncMethods.map((method) => getTsFunction(method, true, true, false, declaration, !declaration && getFunctionReturnBlock
        ? getFunctionReturnBlock(method, fileTypeInformation)
        : null)), declaration ? classDeclaration.properties.map(getClassPropertyDeclaration) : [], constructorDeclaration)
        .filter((v) => !!v));
}
function getExportedClassDeclaration(classDeclaration, fileTypeInformation) {
    return getTsClass(classDeclaration, fileTypeInformation, true, true, null);
}
function getModuleDefaultValueExport(defaultValueTypename) {
    return [].concat(typescript_1.default.factory.createParameterDeclaration([typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ConstKeyword)], undefined, '_default', undefined, typescript_1.default.factory.createTypeReferenceNode(defaultValueTypename), undefined), typescript_1.default.factory.createExportDefault(typescript_1.default.factory.createIdentifier('_default')));
}
function getNParameters(n) {
    const params = [];
    for (let i = 0; i < n; i += 1) {
        params.push(typescript_1.default.factory.createTypeParameterDeclaration(undefined, 'T' + i));
    }
    return params;
}
function getIdentifierUnknownDeclaration(identifier, typeParametersCount) {
    return getTypeAliasDeclaration(identifier, typescript_1.default.factory.createKeywordTypeNode(typescript_1.default.SyntaxKind.UnknownKeyword), typeParametersCount.get(identifier));
}
function getTypeAliasDeclaration(alias, typeIdentifier, paramCount) {
    return typescript_1.default.factory.createTypeAliasDeclaration(undefined, alias, paramCount === undefined ? undefined : getNParameters(paramCount), typeIdentifier);
}
function getRecordDeclaration(recordType) {
    return typescript_1.default.factory.createTypeAliasDeclaration(undefined, recordType.name, undefined, typescript_1.default.factory.createTypeLiteralNode(recordType.fields.map((field) => {
        const optional = field.type.kind === typeInformation_1.TypeKind.OPTIONAL;
        const argType = optional ? field.type.type : field.type;
        return typescript_1.default.factory.createPropertySignature(undefined, field.name, optional ? typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken) : undefined, mapTypeToTsTypeNode(argType));
    })));
}
function getEnumDeclaration(enumType) {
    return typescript_1.default.factory.createEnumDeclaration(undefined, enumType.name, enumType.cases.map((enumcase) => typescript_1.default.factory.createEnumMember(enumcase)));
}
function getUndeclaredIdentifiersDeclaration(fileTypeInformation, undeclaredTypeIdentifiers, unresolvedTypesNamespace) {
    return [].concat([
        typescript_1.default.factory.createModuleDeclaration([typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)], typescript_1.default.factory.createIdentifier(unresolvedTypesNamespace), typescript_1.default.factory.createModuleBlock([...undeclaredTypeIdentifiers].map((identifier) => getIdentifierUnknownDeclaration(identifier, fileTypeInformation.typeParametersCount))), typescript_1.default.NodeFlags.Namespace),
    ], [...undeclaredTypeIdentifiers].map((undeclaredTypeIdentifier) => getTypeAliasDeclaration(undeclaredTypeIdentifier, typescript_1.default.factory.createTypeReferenceNode(typescript_1.default.factory.createQualifiedName(typescript_1.default.factory.createIdentifier(unresolvedTypesNamespace), undeclaredTypeIdentifier)), fileTypeInformation.typeParametersCount.get(undeclaredTypeIdentifier))));
}
function getModuleTypesDeclarationsForModule(moduleClassDeclaration, fileTypeInformation, recordTypes, enumTypes, undeclaredTypeIdentifiers, unresolvedTypesNamespace) {
    return [].concat(getPrefix(), newlineIdentifier, getOneNamedImport('NativeModule', 'expo'), newlineIdentifier, getUndeclaredIdentifiersDeclaration(fileTypeInformation, undeclaredTypeIdentifiers, unresolvedTypesNamespace), newlineIdentifier, recordTypes.flatMap(getRecordDeclaration), newlineIdentifier, enumTypes.flatMap(getEnumDeclaration), newlineIdentifier, moduleClassDeclaration.classes.map((c) => getExportedClassDeclaration(c, fileTypeInformation)), newlineIdentifier, getExportedModuleDeclaration(moduleClassDeclaration), newlineIdentifier, getModuleDefaultValueExport(moduleClassDeclaration.name));
}
function getViewDefaultValueExport(view) {
    return [].concat(typescript_1.default.factory.createParameterDeclaration([typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ConstKeyword)], undefined, '_default', undefined, typescript_1.default.factory.createTypeReferenceNode('React.JSXElementConstructor', [
        typescript_1.default.factory.createTypeReferenceNode(getViewPropsTypeName(view)),
    ]), undefined), typescript_1.default.factory.createExportDefault(typescript_1.default.factory.createIdentifier('_default')));
}
function getViewPropsTypeName(view) {
    return view.name + (view.name.endsWith('View') ? 'Props' : 'ViewProps');
}
function getViewTypesDeclarationsForModule(moduleClassDeclaration, fileTypeInformation) {
    if (moduleClassDeclaration.views.length === 0) {
        return [];
    }
    const mainView = moduleClassDeclaration.views[0];
    const undeclaredTypeIdentifiers = fileTypeInformation.usedTypeIdentifiers
        .difference(fileTypeInformation.declaredTypeIdentifiers)
        .difference(basicTypesIdentifiers());
    return [].concat(getPrefix(), newlineIdentifier, getOneNamedImport('SharedObject', 'expo'), newlineIdentifier, getOneNamedImport('ViewProps', 'react-native'), newlineIdentifier, [...undeclaredTypeIdentifiers].map((identifier) => getIdentifierUnknownDeclaration(identifier, fileTypeInformation.typeParametersCount)), newlineIdentifier, getPropsTypeDeclaration(getViewPropsTypeName(mainView), mainView.props, mainView.events, false), newlineIdentifier, getViewDefaultValueExport(moduleClassDeclaration.views[0]));
}
async function prettifyCode(text, parser = 'babel') {
    return await prettier_1.default.format(text, {
        parser,
        tabWidth: 2,
        printWidth: 100,
        trailingComma: 'none',
        singleQuote: true,
    });
}
async function prettyPrintTSNodesToString(file, elements) {
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    const resultFile = typescript_1.default.createSourceFile(file, '', typescript_1.default.ScriptTarget.Latest, false, typescript_1.default.ScriptKind.TSX);
    const viewTypes = typescript_1.default.factory.createNodeArray(elements);
    const printedTs = printer.printList(typescript_1.default.ListFormat.MultiLine + typescript_1.default.ListFormat.PreserveLines, viewTypes, resultFile);
    return await prettifyCode(printedTs, 'typescript');
}
function basicTypesIdentifiers() {
    return new Set(['any', 'number', 'string', 'undefined', 'null', 'Map', 'Set']);
}
async function getGeneratedViewTypesFileContent(file, fileTypeInformation) {
    const outputModuleDefinition = fileTypeInformation.moduleClasses[0];
    return prettyPrintTSNodesToString(file, getViewTypesDeclarationsForModule(outputModuleDefinition, fileTypeInformation));
}
async function getGeneratedModuleTypesFileContent(file, fileTypeInformation) {
    const moduleClassDeclaration = fileTypeInformation.moduleClasses.at(0) ?? {
        name: 'EmptyModule',
        asyncFunctions: [],
        functions: [],
        properties: [],
        classes: [],
        views: [],
        constants: [],
        props: [],
        events: [],
    };
    return prettyPrintTSNodesToString(file, getModuleTypesDeclarationsForModule(moduleClassDeclaration, fileTypeInformation, fileTypeInformation.records, fileTypeInformation.enums, fileTypeInformation.usedTypeIdentifiers
        .difference(fileTypeInformation.declaredTypeIdentifiers)
        .difference(basicTypesIdentifiers()), getUnresolvedTypesNamespaceNameForFile(file)));
}
//# sourceMappingURL=typescriptGeneration.js.map