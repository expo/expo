{"version":3,"file":"sourcekittenTypeInformation.js","sourceRoot":"","sources":["../../src/swift/sourcekittenTypeInformation.ts"],"names":[],"mappings":"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","sourcesContent":["import { execSync } from 'child_process';\nimport fs from 'fs';\nimport YAML from 'yaml';\n\nimport {\n  Argument,\n  BasicType,\n  ClassDeclaration,\n  ConstantDeclaration,\n  ConstructorDeclaration,\n  DictionaryType,\n  EnumType,\n  Field,\n  FileTypeInformation,\n  FunctionDeclaration,\n  IdentifierKind,\n  ModuleClassDeclaration,\n  ParametrizedType,\n  PropDeclaration,\n  RecordType,\n  SumType,\n  Type,\n  TypeIdentifier,\n  TypeIdentifierDefinitionMap,\n  TypeKind,\n  ViewDeclaration,\n} from '../typeInformation';\nimport { Attribute, FileType, Structure } from '../types';\n\nfunction isSwiftDictionary(type: string): boolean {\n  return (\n    type.startsWith('[') &&\n    type.endsWith(']') &&\n    findRootColonInDictionary(type.substring(1, type.length - 1)) >= 0\n  );\n}\n\nfunction isSwiftArray(type: string) {\n  // This can also be an object, but we check that first, so if it's not an object and is wrapped with [] it's an array.\n  return type.startsWith('[') && type.endsWith(']');\n}\n\nfunction isSwiftOptional(type: string): boolean {\n  return type.endsWith('?');\n}\n\nfunction isParametrizedType(type: string): boolean {\n  return type.endsWith('>');\n}\n\nfunction isEitherTypeIdentifier(typeIdentifier: string): boolean {\n  return (\n    typeIdentifier === 'Either' ||\n    typeIdentifier === 'EitherOfThree' ||\n    typeIdentifier === 'EitherOfFour'\n  );\n}\n\nfunction isEnumStructure(structure: Structure): boolean {\n  return structure['key.kind'] === 'source.lang.swift.decl.enum';\n}\n\nfunction isRecordStructure(structure: Structure): boolean {\n  return (\n    (structure['key.kind'] === 'source.lang.swift.decl.struct' ||\n      structure['key.kind'] === 'source.lang.swift.decl.class') &&\n    structure['key.inheritedtypes'] &&\n    structure['key.inheritedtypes'].find((type) => {\n      return type['key.name'] === 'Record';\n    }) !== undefined\n  );\n}\n\nfunction isModuleStructure(structure: Structure): boolean {\n  return structure['key.typename'] === 'ModuleDefinition';\n}\n\nfunction unwrapSwiftArray(type: string): Type {\n  const innerType = type.substring(1, type.length - 1);\n  return mapSwiftTypeToTsType(innerType.trim());\n}\n\nfunction unwrapParametrizedType(type: string): ParametrizedType {\n  let openBracketCount = 0;\n  let start = 0;\n  const innerTypes: Type[] = [];\n  let name: string = '';\n  for (let i = 0; i < type.length; i += 1) {\n    if (type[i] === '<') {\n      openBracketCount += 1;\n      if (openBracketCount === 1) {\n        name = type.substring(0, i);\n        start = i + 1;\n      }\n    } else if (type[i] === '>') {\n      openBracketCount -= 1;\n      if (openBracketCount === 0) {\n        innerTypes.push(mapSwiftTypeToTsType(type.substring(start, i).trim()));\n        start = i + 1;\n      }\n    } else if (type[i] === ',' && openBracketCount === 1) {\n      innerTypes.push(mapSwiftTypeToTsType(type.substring(start, i).trim()));\n      start = i + 1;\n    }\n  }\n  return { name, types: innerTypes };\n}\n\nfunction unwrapSwiftDictionary(type: string) {\n  const innerType = type.substring(1, type.length - 1);\n  const colonPosition = findRootColonInDictionary(innerType);\n  return {\n    key: innerType.slice(0, colonPosition).trim(),\n    value: innerType.slice(colonPosition + 1).trim(),\n  };\n}\n\n/*\nThe Swift object type can have nested objects as the type of it's values (or maybe even keys).\n[String: [String: Any]]\n\nWe can't use regex to find the root colon, so this is the safest way – by counting brackets.\n*/\nfunction findRootColonInDictionary(type: string) {\n  let colonIndex = -1;\n  let openBracketsCount = 0;\n  for (let i = 0; i < type.length; i++) {\n    if (type[i] === '[') {\n      openBracketsCount++;\n    } else if (type[i] === ']') {\n      openBracketsCount--;\n    } else if (type[i] === ':' && openBracketsCount === 0) {\n      colonIndex = i;\n      break;\n    }\n  }\n  return colonIndex;\n}\n\nfunction mapSwiftTypeToTsType(type?: string): Type {\n  if (!type) {\n    return { kind: TypeKind.BASIC, type: BasicType.UNRESOLVED };\n  }\n  if (isSwiftOptional(type)) {\n    return { kind: TypeKind.OPTIONAL, type: mapSwiftTypeToTsType(type.slice(0, -1).trim()) };\n  }\n  if (isSwiftDictionary(type)) {\n    const { key, value } = unwrapSwiftDictionary(type);\n    const keyType = mapSwiftTypeToTsType(key);\n    const valueType = mapSwiftTypeToTsType(value);\n\n    return {\n      kind: TypeKind.DICTIONARY,\n      type: {\n        key: keyType,\n        value: valueType,\n      },\n    };\n  }\n  if (isSwiftArray(type)) {\n    return {\n      kind: TypeKind.ARRAY,\n      type: unwrapSwiftArray(type),\n    };\n  }\n  if (isParametrizedType(type)) {\n    const parametrizedType = unwrapParametrizedType(type);\n    if (isEitherTypeIdentifier(parametrizedType.name)) {\n      return {\n        kind: TypeKind.SUM,\n        type: parametrizedType as SumType,\n      };\n    }\n    return {\n      kind: TypeKind.PARAMETRIZED,\n      type: parametrizedType,\n    };\n  }\n\n  const returnType: Type = {\n    kind: TypeKind.BASIC,\n    type: BasicType.ANY,\n  };\n\n  switch (type) {\n    case 'unknown':\n    case 'Any':\n      returnType.type = BasicType.ANY;\n      break;\n    case 'String':\n      returnType.type = BasicType.STRING;\n      break;\n    case 'Bool':\n      returnType.type = BasicType.BOOLEAN;\n      break;\n    case 'Int':\n    case 'Float':\n    case 'Double':\n      returnType.type = BasicType.NUMBER;\n      break;\n    case 'Void':\n      returnType.type = BasicType.VOID;\n      break;\n    default:\n      returnType.kind = TypeKind.IDENTIFIER;\n      returnType.type = type;\n  }\n  return returnType;\n}\n\nfunction getStructureFromFile(file: FileType) {\n  const command = 'sourcekitten structure --file ' + file.path;\n\n  try {\n    const output = execSync(command);\n    return JSON.parse(output.toString());\n  } catch (error) {\n    console.error('An error occurred while executing the command:', error);\n  }\n}\n\n// Read string straight from file – needed since we can't get cursorinfo for modulename\nfunction getIdentifierFromOffsetObject(offsetObject: Structure, file: FileType) {\n  // adding 1 and removing 1 to get rid of quotes\n  return file.content\n    .substring(offsetObject['key.offset'], offsetObject['key.offset'] + offsetObject['key.length'])\n    .replaceAll('\"', '');\n}\n\nfunction hasSubstructure(structure: Structure) {\n  return structure?.['key.substructure'] && structure['key.substructure'].length > 0;\n}\n\nfunction findReturnType(structure: Structure, file: FileType): string | null {\n  if (\n    structure['key.kind'] === 'source.lang.swift.decl.var.local' &&\n    structure['key.name'].startsWith('returnValueDeclaration_')\n  ) {\n    return getTypeOfByteOffsetVariable(structure['key.nameoffset'], file);\n  }\n  if (hasSubstructure(structure)) {\n    for (const substructure of structure['key.substructure']) {\n      const returnType = findReturnType(substructure, file);\n      if (returnType) {\n        return returnType;\n      }\n    }\n  }\n  return null;\n}\n\nlet cachedSDKPath: string | null = null;\nfunction getSDKPath(): string {\n  if (cachedSDKPath) {\n    return cachedSDKPath;\n  }\n  const sdkPath = execSync('xcrun --sdk iphoneos --show-sdk-path').toString().trim() as string;\n  cachedSDKPath = sdkPath;\n  return cachedSDKPath;\n}\n\nfunction extractDeclarationType(structure: Structure, file: FileType): Type {\n  if (structure['key.typename']) {\n    return mapSwiftTypeToTsType(structure['key.typename'] as string);\n  }\n  const inferReturn = getTypeOfByteOffsetVariable(structure['key.nameoffset'], file);\n  return mapSwiftTypeToTsType(inferReturn ?? 'Any');\n}\n\n// Read type description with sourcekitten, works only for variables\n// TODO This function is extremely slow and inefficient\n// consider other options\nfunction getTypeOfByteOffsetVariable(byteOffset: number, file: FileType): string | null {\n  const request = {\n    'key.request': 'source.request.cursorinfo',\n    'key.sourcefile': file.path,\n    'key.offset': byteOffset,\n    'key.compilerargs': [file.path, '-target', 'arm64-apple-ios7', '-sdk', getSDKPath()],\n  };\n  const yamlRequest = YAML.stringify(request, {\n    defaultStringType: 'QUOTE_DOUBLE',\n    lineWidth: 0,\n    defaultKeyType: 'PLAIN',\n    // needed since behaviour of sourcekitten is not consistent\n  } as any)\n    .replace('\"source.request.cursorinfo\"', 'source.request.cursorinfo')\n    .replaceAll('\"', '\\\\\"');\n\n  const command = 'sourcekitten request --yaml \"' + yamlRequest + '\"';\n  try {\n    const output = JSON.parse(execSync(command, { stdio: 'pipe' }).toString());\n    const inferredType = output['key.typename'];\n    if (inferredType === '<<error type>>') {\n      return null;\n    }\n    return inferredType;\n  } catch (error) {\n    console.error('An error occurred while executing the command:', error);\n  }\n  return null;\n}\n\nfunction mapSourcekittenParameterToType(parameter: {\n  name: string | undefined;\n  typename: string;\n}): Argument {\n  return {\n    name: parameter.name ?? undefined,\n    type: mapSwiftTypeToTsType(parameter.typename),\n  };\n}\n\nconst parseModulePropertySubstructure = parseModuleConstantSubstructure;\n\nfunction parseClosureTypes(\n  structure: Structure,\n  file: FileType\n): { parameters: { name: string; typename: string }[]; returnType: string | null } {\n  const closure = structure['key.substructure']?.find(\n    (s) => s['key.kind'] === 'source.lang.swift.expr.closure'\n  );\n  if (!closure) {\n    // Try finding the preprocessed return value, if not found we don't know the return type\n    const returnType = findReturnType(structure, file);\n    return { parameters: [], returnType };\n  }\n  const parameters = closure['key.substructure']\n    ?.filter((s) => s['key.kind'] === 'source.lang.swift.decl.var.parameter')\n    .map((p) => ({\n      name: p['key.name'] ?? undefined,\n      typename: p['key.typename'],\n    }));\n\n  const returnType = closure?.['key.typename'] ?? findReturnType(structure, file);\n  return { parameters, returnType };\n}\n\nfunction parseModuleConstructorDeclaration(\n  substructure: Structure,\n  file: FileType\n): ConstructorDeclaration {\n  const definitionParams = substructure['key.substructure'];\n  let types = null;\n\n  // TODO rethink this maybe split based on what closure is expected\n  // Maybe this should be the last substructure\n  if (hasSubstructure(definitionParams[1])) {\n    types = parseClosureTypes(definitionParams[1], file);\n  } else if (hasSubstructure(definitionParams[0])) {\n    types = parseClosureTypes(definitionParams[0], file);\n  } else {\n    // TODO REDO THIS\n    // types = getTypeOfByteOffsetVariable(definitionParams[1]['key.offset'], file);\n  }\n\n  return {\n    arguments: types?.parameters.map(mapSourcekittenParameterToType) ?? [],\n  };\n}\n\nfunction parseModuleConstantSubstructure(\n  substructure: Structure,\n  file: FileType\n): ConstantDeclaration {\n  const definitionParams = substructure['key.substructure'];\n  const name = getIdentifierFromOffsetObject(definitionParams[0], file);\n  let types = null;\n  if (hasSubstructure(definitionParams[1])) {\n    types = parseClosureTypes(definitionParams[1], file);\n  } else {\n    // TODO REDO THIS\n    // types = getTypeOfByteOffsetVariable(definitionParams[1]['key.offset'], file);\n  }\n\n  return {\n    name,\n    type: mapSwiftTypeToTsType(types?.returnType ?? undefined),\n  };\n}\n\nfunction parseModuleClassSubstructure(substructure: Structure, file: FileType): ClassDeclaration {\n  const nestedModuleStructure =\n    substructure['key.substructure']?.[1]?.['key.substructure']?.[0]?.['key.substructure']?.[0]?.[\n      'key.substructure'\n    ];\n\n  const name = getIdentifierFromOffsetObject(substructure['key.substructure']?.[0], file).replace(\n    '.self',\n    ''\n  );\n\n  if (!nestedModuleStructure) {\n    console.warn(name + \" class is empty or couldn't parse its definition!\");\n    return {\n      name,\n      constructor: null,\n      methods: [],\n      asyncMethods: [],\n      properties: [],\n    };\n  }\n\n  const classTypeInfo = parseModuleStructure(\n    nestedModuleStructure,\n    file,\n    'GREPME Does Not Matter :)'\n  );\n  return {\n    name,\n    methods: classTypeInfo.functions,\n    asyncMethods: classTypeInfo.asyncFunctions,\n    properties: classTypeInfo.properties,\n    constructor: classTypeInfo.constructor,\n  };\n}\n\nfunction parseModuleFunctionSubstructure(\n  substructure: Structure,\n  file: FileType\n): FunctionDeclaration {\n  const definitionParams = substructure['key.substructure'];\n  const name = getIdentifierFromOffsetObject(definitionParams[0], file);\n  let types = null;\n  if (hasSubstructure(definitionParams[1])) {\n    types = parseClosureTypes(definitionParams[1], file);\n  } else {\n    // TODO REDO THIS\n    // types = getTypeOfByteOffsetVariable(definitionParams[1]['key.offset'], file);\n  }\n\n  return {\n    name,\n    returnType: mapSwiftTypeToTsType(types?.returnType ?? undefined), // any or void ? Probably any\n    parameters: [], // TODO Module function is not generic. I think so. Check it\n    arguments: types?.parameters?.map(mapSourcekittenParameterToType) ?? [],\n  };\n}\n\nfunction parseModulePropDeclaration(substructure: Structure, file: FileType): PropDeclaration {\n  const definitionParams = substructure['key.substructure'];\n  const name = getIdentifierFromOffsetObject(definitionParams[0], file);\n  let types = null;\n  if (hasSubstructure(definitionParams[1])) {\n    types = parseClosureTypes(definitionParams[1], file);\n  } else {\n    // TODO REDO THIS\n    // types = getTypeOfByteOffsetVariable(definitionParams[1]['key.offset'], file);\n  }\n\n  return {\n    name,\n    arguments: types?.parameters?.map(mapSourcekittenParameterToType) ?? [],\n  };\n}\n\nfunction parseModuleViewDeclaration(substructure: Structure, file: FileType): ViewDeclaration {\n  // The View arguments is a.self for some class a we want.\n  const suffixLength = 5;\n  const name = getIdentifierFromOffsetObject(substructure['key.substructure']?.[0], file).slice(\n    0,\n    -suffixLength\n  );\n\n  return parseModuleStructure(\n    substructure['key.substructure'][1]['key.substructure'][0]['key.substructure'][0][\n      'key.substructure'\n    ],\n    file,\n    name\n  );\n}\n\nfunction parseModuleEventDeclaration(structure: Structure, file: FileType, events: string[]): void {\n  if (!structure) {\n    return;\n  }\n\n  return structure['key.substructure'].forEach((substructure) =>\n    events.push(getIdentifierFromOffsetObject(substructure, file))\n  );\n}\n\nfunction hasFieldAttribute(attributes: Attribute[] | null, file: FileType): boolean {\n  if (!attributes) {\n    return false;\n  }\n  for (const attribute of attributes) {\n    const attributeString = file.content.substring(\n      attribute['key.offset'],\n      attribute['key.offset'] + attribute['key.length']\n    );\n    if (attributeString === '@Field') {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction parseRecordStructure(\n  recordStructure: Structure,\n  usedTypeIdentifiers: Set<string>,\n  inferredTypeParametersCount: Map<string, number>,\n  file: FileType\n): RecordType {\n  const fields: Field[] = [];\n\n  for (const substructure of recordStructure['key.substructure']) {\n    if (\n      substructure['key.kind'] !== 'source.lang.swift.decl.var.instance' ||\n      !hasFieldAttribute(substructure['key.attributes'], file)\n    ) {\n      continue;\n    }\n\n    const type: Type = extractDeclarationType(substructure, file);\n    fields.push({\n      name: substructure['key.name'],\n      type,\n    });\n    collectTypeIdentifiers(type, usedTypeIdentifiers, inferredTypeParametersCount);\n  }\n\n  return {\n    name: recordStructure['key.name'],\n    fields,\n  };\n}\n\nfunction parseEnumStructure(enumStructure: Structure): EnumType {\n  const enumcases: string[] = [];\n  for (const substructure of enumStructure['key.substructure']) {\n    if (substructure['key.kind'] === 'source.lang.swift.decl.enumcase') {\n      for (const caseSubstructure of substructure['key.substructure']) {\n        // enum case in Swift can have values: case somecase(Int, String)\n        // for now we ignore these values\n        enumcases.push(caseSubstructure['key.name'].split('(', 1)[0]);\n      }\n    }\n  }\n\n  return {\n    name: enumStructure['key.name'],\n    cases: enumcases,\n  };\n}\n\nfunction parseModuleStructure(\n  moduleStructure: Structure[],\n  file: FileType,\n  name: string\n): ModuleClassDeclaration {\n  const mcd: ModuleClassDeclaration = {\n    name,\n    constants: [],\n    constructor: null,\n    functions: [],\n    asyncFunctions: [],\n    classes: [],\n    properties: [],\n    props: [],\n    views: [],\n    events: [],\n  };\n\n  for (const md of moduleStructure) {\n    switch (md['key.name']) {\n      case 'Name':\n        mcd.name = getIdentifierFromOffsetObject(md['key.substructure']?.[0], file);\n        break;\n      case 'Function':\n        mcd.functions.push(parseModuleFunctionSubstructure(md, file));\n        break;\n      case 'Constant':\n        mcd.constants.push(parseModuleConstantSubstructure(md, file));\n        break;\n      case 'Class':\n        mcd.classes.push(parseModuleClassSubstructure(md, file));\n        break;\n      case 'Property':\n        mcd.properties.push(parseModulePropertySubstructure(md, file));\n        break;\n      case 'AsyncFunction':\n        mcd.asyncFunctions.push(parseModuleFunctionSubstructure(md, file));\n        break;\n      case 'Constructor':\n        mcd.constructor = parseModuleConstructorDeclaration(md, file);\n        break;\n      case 'Prop':\n        mcd.props.push(parseModulePropDeclaration(md, file));\n        break;\n      case 'View':\n        mcd.views.push(parseModuleViewDeclaration(md, file));\n        break;\n      case 'Events':\n        parseModuleEventDeclaration(md, file, mcd.events);\n        break;\n      default:\n        console.warn('Module substructure not supported');\n    }\n  }\n\n  return mcd;\n}\n\nfunction parseStructure(\n  structure: Structure,\n  name: string,\n  modulesStructures: { structure: Structure; name: string }[],\n  recordsStructures: Structure[],\n  enumsStructures: Structure[]\n) {\n  const substructure = structure['key.substructure'];\n\n  if (isModuleStructure(structure)) {\n    modulesStructures.push({ structure, name });\n  } else if (isRecordStructure(structure)) {\n    recordsStructures.push(structure);\n  } else if (isEnumStructure(structure)) {\n    enumsStructures.push(structure);\n  } else if (Array.isArray(substructure) && substructure.length > 0) {\n    for (const substructure of structure['key.substructure']) {\n      parseStructure(\n        substructure,\n        structure['key.name'] ?? name,\n        modulesStructures,\n        recordsStructures,\n        enumsStructures\n      );\n    }\n  }\n}\n\nfunction getTypeIdentifierDefinitionMap(\n  fileTypeInformation: FileTypeInformation\n): Map<\n  string,\n  { kind: IdentifierKind; definition: string | RecordType | EnumType | ClassDeclaration }\n> {\n  const typeIdentifierDefinitionMap = new Map<\n    string,\n    { kind: IdentifierKind; definition: string | RecordType | EnumType | ClassDeclaration }\n  >([]);\n\n  fileTypeInformation.records.forEach((r) =>\n    typeIdentifierDefinitionMap.set(r.name, { kind: IdentifierKind.RECORD, definition: r })\n  );\n  fileTypeInformation.enums.forEach((e) =>\n    typeIdentifierDefinitionMap.set(e.name, { kind: IdentifierKind.ENUM, definition: e })\n  );\n\n  return typeIdentifierDefinitionMap;\n}\n\nfunction collectTypeIdentifiers(\n  type: Type,\n  typeIdentiers: Set<string>,\n  inferredTypeParametersCount: Map<string, number>\n) {\n  switch (type.kind) {\n    case TypeKind.ARRAY:\n    case TypeKind.OPTIONAL:\n      collectTypeIdentifiers(type.type as Type, typeIdentiers, inferredTypeParametersCount);\n      break;\n    case TypeKind.DICTIONARY:\n      collectTypeIdentifiers(\n        (type.type as DictionaryType).key,\n        typeIdentiers,\n        inferredTypeParametersCount\n      );\n      collectTypeIdentifiers(\n        (type.type as DictionaryType).value,\n        typeIdentiers,\n        inferredTypeParametersCount\n      );\n      break;\n    case TypeKind.SUM:\n      for (const t of (type.type as SumType).types) {\n        collectTypeIdentifiers(t, typeIdentiers, inferredTypeParametersCount);\n      }\n      break;\n    case TypeKind.BASIC:\n      // if ((type.type as BasicType) === BasicType.UNRESOLVED) {\n      //   typeIdentiers.add('UnresolvedType');\n      // }\n      break;\n    case TypeKind.IDENTIFIER:\n      typeIdentiers.add(type.type as TypeIdentifier);\n      break;\n    case TypeKind.PARAMETRIZED: {\n      const parametrizedType: ParametrizedType = type.type as ParametrizedType;\n      const typename = parametrizedType.name;\n      typeIdentiers.add(typename);\n      inferredTypeParametersCount.set(\n        typename,\n        Math.max(inferredTypeParametersCount.get(typename) ?? 0, parametrizedType.types.length)\n      );\n      for (const t of (type.type as ParametrizedType).types) {\n        collectTypeIdentifiers(t, typeIdentiers, inferredTypeParametersCount);\n      }\n      break;\n    }\n  }\n}\n\nfunction collectModuleTypeIdentifiers(\n  moduleClassDeclaration: ModuleClassDeclaration,\n  fileTypeInformation: FileTypeInformation\n) {\n  const collect = (type: Type) => {\n    collectTypeIdentifiers(\n      type,\n      fileTypeInformation.usedTypeIdentifiers,\n      fileTypeInformation.inferredTypeParametersCount\n    );\n  };\n  const collectArg = (arg: Argument) => {\n    collect(arg.type);\n  };\n  const collectFunction = (functionDeclaration: FunctionDeclaration) => {\n    collect(functionDeclaration.returnType);\n    functionDeclaration.arguments.forEach(collectArg);\n    functionDeclaration.parameters.forEach(collect);\n  };\n  moduleClassDeclaration.asyncFunctions.forEach(collectFunction);\n  moduleClassDeclaration.functions.forEach(collectFunction);\n  moduleClassDeclaration.constants.forEach(collectArg);\n  moduleClassDeclaration.properties.forEach(collectArg);\n  moduleClassDeclaration.constructor?.arguments.forEach(collectArg);\n  moduleClassDeclaration.views.forEach((v) => collectModuleTypeIdentifiers(v, fileTypeInformation));\n  moduleClassDeclaration.props.forEach((p) => p.arguments.forEach(collectArg));\n  moduleClassDeclaration.classes.forEach((c) => {\n    fileTypeInformation.declaredTypeIdentifiers.add(c.name);\n    c.asyncMethods.forEach(collectFunction);\n    c.methods.forEach(collectFunction);\n    c.constructor?.arguments.forEach(collectArg);\n    c.properties.forEach(collectArg);\n  });\n}\n\nexport function getSwiftFileTypeInformation(filePath: string): FileTypeInformation | null {\n  const file = { path: filePath, content: fs.readFileSync(filePath, 'utf8') };\n\n  const modulesStructures: { name: string; structure: Structure }[] = [];\n  const recordsStructures: Structure[] = [];\n  const enumsStructures: Structure[] = [];\n  parseStructure(\n    getStructureFromFile(file),\n    '',\n    modulesStructures,\n    recordsStructures,\n    enumsStructures\n  );\n\n  const inferredTypeParametersCount: Map<string, number> = new Map<string, number>();\n  const moduleClasses: ModuleClassDeclaration[] = [];\n  const moduleTypeIdentifiers: Set<string> = new Set<string>();\n  const declaredTypeIdentifiers: Set<string> = new Set<string>();\n  const recordTypeIdentifiers: Set<string> = new Set<string>();\n  const typeIdentifierDefinitionMap: TypeIdentifierDefinitionMap = new Map();\n  const enums: EnumType[] = enumsStructures.map(parseEnumStructure);\n  const recordMap = (rd: Structure) =>\n    parseRecordStructure(rd, recordTypeIdentifiers, inferredTypeParametersCount, file);\n  const records = recordsStructures.map(recordMap);\n\n  enums.forEach(({ name }) => {\n    declaredTypeIdentifiers.add(name);\n  });\n  records.forEach(({ name }) => {\n    declaredTypeIdentifiers.add(name);\n  });\n\n  const fileTypeInformation = {\n    moduleClasses,\n    records,\n    enums,\n    functions: [],\n    usedTypeIdentifiers: moduleTypeIdentifiers.union(recordTypeIdentifiers),\n    declaredTypeIdentifiers,\n    inferredTypeParametersCount,\n    typeIdentifierDefinitionMap,\n  };\n\n  for (const { structure, name } of modulesStructures) {\n    if (!hasSubstructure(structure)) {\n      continue;\n    }\n    const moduleClassDeclaration = parseModuleStructure(structure['key.substructure'], file, name);\n    moduleClasses.push(moduleClassDeclaration);\n    collectModuleTypeIdentifiers(moduleClassDeclaration, fileTypeInformation);\n  }\n\n  fileTypeInformation.typeIdentifierDefinitionMap =\n    getTypeIdentifierDefinitionMap(fileTypeInformation);\n\n  return fileTypeInformation;\n}\n\n// Preprocessing to help sourcekitten functions\n// For now we create a new variable for each return statement,\n// we can find it's type easily with sourcekitten\nfunction removeComments(fileContent: string): string {\n  let multiLineComment = false;\n  let singleLineComment = false;\n  const newFileContent: string[] = [];\n  let start: number = 0;\n\n  for (let i = 0; i < fileContent.length; i += 1) {\n    const char = fileContent[i];\n    const nextChar = i + 1 < fileContent.length ? fileContent[i + 1] : null;\n    switch (char) {\n      case '/': {\n        if (nextChar === '/' && !multiLineComment) {\n          singleLineComment = true;\n          newFileContent.push(fileContent.substring(start, i));\n        } else if (nextChar === '*' && !singleLineComment) {\n          multiLineComment = true;\n          newFileContent.push(fileContent.substring(start, i));\n        }\n        break;\n      }\n      case '*': {\n        if (nextChar === '/' && multiLineComment) {\n          start = i + 2;\n          i += 1;\n          multiLineComment = false;\n        }\n        break;\n      }\n      case '\\n': {\n        if (singleLineComment) {\n          singleLineComment = false;\n          start = i + 1;\n        }\n        break;\n      }\n    }\n  }\n  newFileContent.push(fileContent.substring(start, fileContent.length));\n  return newFileContent.join('');\n}\n\nfunction returnExpressionEnd(fileContent: string, returnIndex: number): number {\n  let inString = false;\n  let escaped = false;\n  let parenCount = 0;\n  let braceCount = 0;\n  // TODO figure out what also changes the typical end of expression\n\n  let i = returnIndex;\n  while (i < fileContent.length) {\n    const char = fileContent[i];\n    let escapedNow = false;\n    switch (char) {\n      case '(':\n        parenCount += 1;\n        break;\n      case ')':\n        parenCount -= 1;\n        break;\n      case '{':\n        braceCount += 1;\n        break;\n      case '}':\n        if (braceCount === 0) {\n          return i;\n        }\n        braceCount -= 1;\n        break;\n      case '\"':\n        if (!escaped) {\n          inString = !inString;\n        }\n        break;\n      case ';':\n        return i;\n      case '\\n':\n      case '\\r':\n        if (!inString && parenCount === 0 && braceCount === 0) {\n          return i;\n        }\n        break;\n      case '\\\\':\n        escapedNow = true;\n    }\n    escaped = escapedNow;\n    i += 1;\n  }\n  return i;\n}\n\nexport function preprocessSwiftFile(originalFileContent: string): string {\n  const newFileContent: string[] = [];\n  const fileContent = removeComments(originalFileContent);\n  const returnPositions: { start: number; end: number }[] = [];\n  let startPos = 0;\n  while (startPos < fileContent.length) {\n    const returnIndex = fileContent.indexOf('return ', startPos);\n    if (returnIndex < 0 || returnIndex >= fileContent.length) {\n      break;\n    }\n    returnPositions.push({\n      start: returnIndex,\n      end: returnExpressionEnd(fileContent, returnIndex),\n    });\n    startPos = returnIndex + 1;\n  }\n\n  let prevEnd = 0;\n\n  for (const { start, end } of returnPositions) {\n    newFileContent.push(fileContent.substring(prevEnd, start));\n    newFileContent.push(\n      `let returnValueDeclaration_${start}_${end} = ${fileContent.substring(start + 6, end)}\\n`\n    );\n    newFileContent.push(`return returnValueDeclaration_${start}_${end}\\n`);\n    prevEnd = end;\n  }\n  newFileContent.push(fileContent.substring(prevEnd, fileContent.length));\n  return newFileContent.join('');\n}\n"]}