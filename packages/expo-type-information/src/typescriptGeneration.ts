'use strict';
import prettier from 'prettier';
import ts, { MethodDeclaration } from 'typescript';

import {
  Argument,
  ArrayType,
  BasicType,
  ClassDeclaration,
  ConstructorDeclaration,
  DictionaryType,
  EnumType,
  EventDeclaration,
  FileTypeInformation,
  FunctionDeclaration,
  ModuleClassDeclaration,
  ParametrizedType,
  PropDeclaration,
  PropertyDeclaration,
  RecordType,
  SumType,
  Type,
  TypeKind,
  ViewDeclaration,
} from './typeInformation';

const prefix = `Automatically generated by expo-type-information.

This autogenerated file provides TS types for native Expo module or view,
and works out of the box with local native modules.
`;

function getPrefix() {
  return [ts.factory.createJSDocComment(prefix)];
}

const newlineIdentifier = ts.factory.createIdentifier('\n\n') as any;

function getOneNamedImport(importedName: string, importFromName: string) {
  return ts.factory.createImportDeclaration(
    undefined,
    ts.factory.createImportClause(
      undefined,
      undefined,
      ts.factory.createNamedImports([
        ts.factory.createImportSpecifier(
          false,
          undefined,
          ts.factory.createIdentifier(importedName)
        ),
      ])
    ),
    ts.factory.createStringLiteral(importFromName),
    undefined
  );
}

function getPropEventElementDeclaration(eventDeclaration: EventDeclaration): ts.TypeElement {
  return ts.factory.createPropertySignature(
    undefined,
    eventDeclaration,
    undefined,
    ts.factory.createFunctionTypeNode(
      undefined,
      [
        ts.factory.createParameterDeclaration(
          undefined,
          undefined,
          'event',
          undefined,
          ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)
        ),
      ],
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword)
    )
  );
}

function getPropTypeElementDeclaration(
  propDeclaration: PropDeclaration
): ts.TypeElement | undefined {
  if (!propDeclaration || !propDeclaration.arguments || propDeclaration.arguments.length < 2) {
    return undefined;
  }
  return ts.factory.createPropertySignature(
    undefined,
    propDeclaration.name,
    undefined,
    mapTypeToTsTypeNode(propDeclaration.arguments[1].type)
  );
}

export function getPropsTypeDeclaration(
  propsTypeName: string,
  propsDeclaration: PropDeclaration[],
  events: EventDeclaration[],
  exported: boolean = true
): ts.Node[] {
  return ([] as ts.Node[]).concat(
    ts.factory.createTypeAliasDeclaration(
      exported ? [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)] : [],
      propsTypeName,
      undefined,
      ts.factory.createTypeLiteralNode([
        ...(propsDeclaration
          .map(getPropTypeElementDeclaration)
          .filter((p) => p) as ts.PropertySignature[]),
        ...events.map(getPropEventElementDeclaration),
      ])
    )
  );
}

export function wrapWithPromise(typeNode: ts.TypeNode): ts.TypeNode {
  return ts.factory.createTypeReferenceNode('Promise', [typeNode]);
}

function getClassPropertyDeclaration(declaration: PropertyDeclaration): ts.PropertyDeclaration {
  return ts.factory.createPropertyDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
    declaration.name,
    undefined,
    mapTypeToTsTypeNode(declaration.type),
    undefined
  );
}

function getClassDeclarationInModule(classDeclaration: ClassDeclaration): ts.ClassElement {
  return ts.factory.createPropertyDeclaration(
    undefined,
    classDeclaration.name,
    undefined,
    // TODO that's a hack, but I couldn't find a proper way to do this
    // The problem is that declare class semantics seem somewhat different than class semantics.
    ts.factory.createTypeReferenceNode('typeof ' + classDeclaration.name),
    undefined
  );
}

function getExportDeclareModifiers(): ts.ModifierLike[] {
  return [
    ts.factory.createModifier(ts.SyntaxKind.ExportKeyword),
    ts.factory.createToken(ts.SyntaxKind.DeclareKeyword),
  ];
}

function getExportedModuleDeclaration(moduleClassDeclaration: ModuleClassDeclaration): ts.Node[] {
  return [
    ts.factory.createClassDeclaration(
      getExportDeclareModifiers(),
      moduleClassDeclaration.name,
      undefined,
      [
        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          ts.factory.createExpressionWithTypeArguments(
            ts.factory.createIdentifier('NativeModule'),
            undefined
          ),
        ]),
      ],
      ([] as ts.ClassElement[]).concat(
        moduleClassDeclaration.constants.map(getClassPropertyDeclaration),
        moduleClassDeclaration.properties.map(getClassPropertyDeclaration),
        moduleClassDeclaration.functions.map(getSyncMethodDeclaration),
        moduleClassDeclaration.asyncFunctions.map(getAsyncMethodDeclaration),
        moduleClassDeclaration.classes.map(getClassDeclarationInModule)
      )
    ),
  ];
}

export function getArgumentDeclaration(arg: Argument): ts.ParameterDeclaration {
  const optional = arg.type.kind === TypeKind.OPTIONAL;
  const argType = optional ? (arg.type.type as Type) : arg.type;

  return ts.factory.createParameterDeclaration(
    undefined,
    undefined,
    arg.name,
    optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,
    mapTypeToTsTypeNode(argType),
    undefined
  );
}

function getAsyncMethodDeclaration(functionDeclaration: FunctionDeclaration): ts.MethodDeclaration {
  return getTsFunction(functionDeclaration, true, true, false, true) as ts.MethodDeclaration;
}

function getSyncMethodDeclaration(functionDeclaration: FunctionDeclaration): ts.MethodDeclaration {
  return getTsFunction(functionDeclaration, false, true, false, true) as MethodDeclaration;
}

export function getTsFunction(
  functionDeclaration: FunctionDeclaration,
  async: boolean,
  method: boolean,
  exported: boolean,
  declaration: boolean,
  returnStatement?: null | ts.ReturnStatement[]
): ts.FunctionDeclaration | ts.MethodDeclaration {
  const functionModifiers: ts.ModifierLike[] = [];
  const customReturn = !!returnStatement;
  let returnTypeNode = mapTypeToTsTypeNode(functionDeclaration.returnType);

  if (exported) {
    functionModifiers.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));
  }

  if (async) {
    returnTypeNode = wrapWithPromise(returnTypeNode);
    if (!declaration) {
      functionModifiers.push(ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword));
    }
  }

  if (method) {
    return ts.factory.createMethodDeclaration(
      functionModifiers,
      undefined,
      functionDeclaration.name,
      undefined,
      undefined,
      functionDeclaration.arguments.map(getArgumentDeclaration),
      returnTypeNode,
      ts.factory.createBlock(customReturn ? returnStatement : [])
    );
  }
  return ts.factory.createFunctionDeclaration(
    functionModifiers,
    undefined,
    functionDeclaration.name,
    undefined,
    functionDeclaration.arguments.map(getArgumentDeclaration),
    returnTypeNode,
    ts.factory.createBlock(customReturn ? returnStatement : [])
  );
}

function mapBasicTypeToTsNode(basicType: BasicType): ts.TypeNode {
  return ts.factory.createKeywordTypeNode(
    (() => {
      switch (basicType) {
        case BasicType.ANY:
          return ts.SyntaxKind.AnyKeyword;
        case BasicType.BOOLEAN:
          return ts.SyntaxKind.BooleanKeyword;
        case BasicType.NUMBER:
          return ts.SyntaxKind.NumberKeyword;
        case BasicType.STRING:
          return ts.SyntaxKind.StringKeyword;
        case BasicType.VOID:
          return ts.SyntaxKind.VoidKeyword;
        case BasicType.UNDEFINED:
          return ts.SyntaxKind.UndefinedKeyword;
      }
    })()
  );
}

function createDictionaryTypeNode(type: DictionaryType): ts.TypeNode {
  return ts.factory.createTypeLiteralNode([
    ts.factory.createIndexSignature(
      undefined,
      [
        ts.factory.createParameterDeclaration(
          undefined,
          undefined,
          'key',
          undefined,
          mapTypeToTsTypeNode(type.key),
          undefined
        ),
      ],
      mapTypeToTsTypeNode(type.value)
    ),
  ]);
}

export function mapTypeToTsTypeNode(type: Type): ts.TypeNode {
  switch (type.kind) {
    case TypeKind.BASIC:
      return mapBasicTypeToTsNode(type.type as BasicType);
    case TypeKind.IDENTIFIER:
      if (type.type === 'unknown') {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
      }
      return ts.factory.createTypeReferenceNode(type.type as string);
    case TypeKind.SUM:
      return ts.factory.createUnionTypeNode((type.type as SumType).types.map(mapTypeToTsTypeNode));
    case TypeKind.ARRAY:
      return ts.factory.createArrayTypeNode(mapTypeToTsTypeNode(type.type as ArrayType));
    case TypeKind.DICTIONARY:
      return createDictionaryTypeNode(type.type as DictionaryType);

    // Technically this one should only be the top one and it should be handled somewhere else
    // for example when creating arguemnt adding the '?' token.
    //
    // However we can just make it (type | undefined) in here.
    // TODO Maybe also need null?
    case TypeKind.OPTIONAL:
      return ts.factory.createUnionTypeNode([
        mapTypeToTsTypeNode(type.type as Type),
        mapBasicTypeToTsNode(BasicType.UNDEFINED),
      ]);
    case TypeKind.PARAMETRIZED:
      return ts.factory.createTypeReferenceNode(
        (type.type as ParametrizedType).name,
        (type.type as ParametrizedType).types.map(mapTypeToTsTypeNode)
      );
  }
  return mapBasicTypeToTsNode(BasicType.ANY);
}

export function getClassConstructorDeclaration(
  constructor: ConstructorDeclaration,
  declaration: boolean = true
): ts.ClassElement {
  return ts.factory.createConstructorDeclaration(
    undefined,
    constructor.arguments.map(getArgumentDeclaration),
    declaration ? undefined : ts.factory.createBlock([])
  );
}

// TODO figure out what about inheritance, should or should not inherit SharedObject
export function getTsClass(
  classDeclaration: ClassDeclaration,
  fileTypeInformation: FileTypeInformation,
  exported: boolean,
  declaration: boolean,
  getFunctionReturnBlock:
    | null
    | ((
        functionDeclaration: FunctionDeclaration,
        fileTypeInformation: FileTypeInformation
      ) => ts.ReturnStatement[])
): ts.ClassDeclaration {
  const classModifiers: ts.ModifierLike[] = [];
  if (exported) {
    classModifiers.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));
  }
  if (declaration) {
    classModifiers.push(ts.factory.createModifier(ts.SyntaxKind.DeclareKeyword));
  }
  const constructorDeclaration = classDeclaration.constructor
    ? getClassConstructorDeclaration(classDeclaration.constructor, declaration)
    : undefined;
  return ts.factory.createClassDeclaration(
    classModifiers,
    ts.factory.createIdentifier(classDeclaration.name),
    undefined,
    [],
    // [
    //   ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
    //     ts.factory.createExpressionWithTypeArguments(
    //       ts.factory.createIdentifier('SharedObject'),
    //       undefined
    //     ),
    //   ]),
    // ],
    ([] as (ts.ClassElement | undefined)[])
      .concat(
        classDeclaration.methods.map(
          (method) =>
            getTsFunction(
              method,
              false,
              true,
              false,
              declaration,
              !declaration && getFunctionReturnBlock
                ? getFunctionReturnBlock(method, fileTypeInformation)
                : null
            ) as ts.MethodDeclaration
        ),
        classDeclaration.asyncMethods.map(
          (method) =>
            getTsFunction(
              method,
              true,
              true,
              false,
              declaration,
              !declaration && getFunctionReturnBlock
                ? getFunctionReturnBlock(method, fileTypeInformation)
                : null
            ) as ts.MethodDeclaration
        ),
        declaration ? classDeclaration.properties.map(getClassPropertyDeclaration) : [],
        constructorDeclaration
      )
      .filter((v) => !!v)
  );
}

function getExportedClassDeclaration(
  classDeclaration: ClassDeclaration,
  fileTypeInformation: FileTypeInformation
): ts.ClassDeclaration {
  return getTsClass(classDeclaration, fileTypeInformation, true, true, null);
}

function getModuleDefaultValueExport(defaultValueTypename: string): ts.Node[] {
  return ([] as ts.Node[]).concat(
    ts.factory.createParameterDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ConstKeyword)],
      undefined,
      '_default',
      undefined,
      ts.factory.createTypeReferenceNode(defaultValueTypename),
      undefined
    ),
    ts.factory.createExportDefault(ts.factory.createIdentifier('_default'))
  );
}

function getNParameters(n: number): ts.TypeParameterDeclaration[] {
  const params: ts.TypeParameterDeclaration[] = [];
  for (let i = 0; i < n; i += 1) {
    params.push(ts.factory.createTypeParameterDeclaration(undefined, 'T' + i));
  }
  return params;
}

export function getIdentifierAnyDeclaration(
  identifier: string,
  typeParametersCount: Map<string, number>
): ts.Node {
  const paramCount = typeParametersCount.get(identifier);
  return ts.factory.createTypeAliasDeclaration(
    undefined,
    identifier,
    paramCount === undefined ? undefined : getNParameters(paramCount),
    ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)
  );
}

export function getRecordDeclaration(recordType: RecordType): ts.Node {
  return ts.factory.createTypeAliasDeclaration(
    undefined,
    recordType.name,
    undefined,
    ts.factory.createTypeLiteralNode(
      recordType.fields.map((field) => {
        const optional = field.type.kind === TypeKind.OPTIONAL;
        const argType = optional ? (field.type.type as Type) : field.type;
        return ts.factory.createPropertySignature(
          undefined,
          field.name,
          optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,
          mapTypeToTsTypeNode(argType)
        );
      })
    )
  );
}

export function getEnumDeclaration(enumType: EnumType): ts.Node {
  return ts.factory.createEnumDeclaration(
    undefined,
    enumType.name,
    enumType.cases.map((enumcase) => ts.factory.createEnumMember(enumcase))
  );
}

function getModuleTypesDeclarationsForModule(
  moduleClassDeclaration: ModuleClassDeclaration,
  fileTypeInformation: FileTypeInformation,
  recordTypes: RecordType[],
  enumTypes: EnumType[],
  undeclaredTypeIdentifiers: Set<string>
): ts.Node[] {
  return ([] as ts.Node[]).concat(
    getPrefix(),
    newlineIdentifier,
    getOneNamedImport('NativeModule', 'expo'),
    newlineIdentifier,
    [...undeclaredTypeIdentifiers].map((identifier) =>
      getIdentifierAnyDeclaration(identifier, fileTypeInformation.typeParametersCount)
    ),
    newlineIdentifier,
    recordTypes.flatMap(getRecordDeclaration),
    newlineIdentifier,
    enumTypes.flatMap(getEnumDeclaration),
    newlineIdentifier,
    moduleClassDeclaration.classes.map((c) => getExportedClassDeclaration(c, fileTypeInformation)),
    newlineIdentifier,
    getExportedModuleDeclaration(moduleClassDeclaration),
    newlineIdentifier,
    getModuleDefaultValueExport(moduleClassDeclaration.name)
  );
}

function getViewDefaultValueExport(view: ViewDeclaration): ts.Node[] {
  return ([] as ts.Node[]).concat(
    ts.factory.createParameterDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ConstKeyword)],
      undefined,
      '_default',
      undefined,
      ts.factory.createTypeReferenceNode('React.JSXElementConstructor', [
        ts.factory.createTypeReferenceNode(getViewPropsTypeName(view)),
      ]),
      undefined
    ),
    ts.factory.createExportDefault(ts.factory.createIdentifier('_default'))
  );
}

export function getViewPropsTypeName(view: ViewDeclaration): string {
  return view.name + (view.name.endsWith('View') ? 'Props' : 'ViewProps');
}

function getViewTypesDeclarationsForModule(
  moduleClassDeclaration: ModuleClassDeclaration,
  fileTypeInformation: FileTypeInformation
): ts.Node[] {
  if (moduleClassDeclaration.views.length === 0) {
    return [];
  }
  const mainView = moduleClassDeclaration.views[0];
  const undeclaredTypeIdentifiers: Set<string> = fileTypeInformation.usedTypeIdentifiers
    .difference(fileTypeInformation.declaredTypeIdentifiers)
    .difference(basicTypesIdentifiers());
  return ([] as ts.Node[]).concat(
    getPrefix(),
    newlineIdentifier,
    getOneNamedImport('SharedObject', 'expo'),
    newlineIdentifier,
    getOneNamedImport('ViewProps', 'react-native'),
    newlineIdentifier,
    [...undeclaredTypeIdentifiers].map((identifier) =>
      getIdentifierAnyDeclaration(identifier, fileTypeInformation.typeParametersCount)
    ),
    newlineIdentifier,
    getPropsTypeDeclaration(getViewPropsTypeName(mainView), mainView.props, mainView.events, false),
    newlineIdentifier,
    getViewDefaultValueExport(moduleClassDeclaration.views[0])
  );
}

async function prettifyCode(text: string, parser: 'babel' | 'typescript' = 'babel') {
  return await prettier.format(text, {
    parser,
    tabWidth: 2,
    printWidth: 100,
    trailingComma: 'none',
    singleQuote: true,
  });
}

async function prettyPrintTSNodesToString(file: string, elements: ts.Node[]) {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const resultFile = ts.createSourceFile(
    file,
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TSX
  );
  const viewTypes = ts.factory.createNodeArray(elements);
  const printedTs = printer.printList(
    ts.ListFormat.MultiLine + ts.ListFormat.PreserveLines,
    viewTypes,
    resultFile
  );
  return await prettifyCode(printedTs, 'typescript');
}

export function basicTypesIdentifiers(): Set<string> {
  return new Set<string>(['any', 'number', 'string', 'undefined', 'null', 'Map', 'Set']);
}

export async function getGeneratedViewTypesFileContent(
  file: string,
  fileTypeInformation: FileTypeInformation
): Promise<string> {
  const outputModuleDefinition = fileTypeInformation.moduleClasses[0];
  return prettyPrintTSNodesToString(
    file,
    getViewTypesDeclarationsForModule(outputModuleDefinition, fileTypeInformation)
  );
}

export async function getGeneratedModuleTypesFileContent(
  file: string,
  fileTypeInformation: FileTypeInformation
): Promise<string> {
  const moduleClassDeclaration: ModuleClassDeclaration = fileTypeInformation.moduleClasses.at(
    0
  ) ?? {
    name: 'EmptyModule',
    asyncFunctions: [],
    functions: [],
    properties: [],
    classes: [],
    views: [],
    constants: [],
    props: [],
    events: [],
  };
  return prettyPrintTSNodesToString(
    file,
    getModuleTypesDeclarationsForModule(
      moduleClassDeclaration,
      fileTypeInformation,
      fileTypeInformation.records,
      fileTypeInformation.enums,
      fileTypeInformation.usedTypeIdentifiers
        .difference(fileTypeInformation.declaredTypeIdentifiers)
        .difference(basicTypesIdentifiers())
    )
  );
}
