#!/usr/bin/env node
'use strict';

import fs, { globSync } from 'fs';
import path from 'path';
// import prettier from 'prettier';
import ts from 'typescript';

import {
  BasicType,
  ClassDeclaration,
  EnumType,
  FileTypeInformation,
  FunctionDeclaration,
  getFileTypeInformation,
  IdentifierKind,
  ModuleClassDeclaration,
  OptionalType,
  RecordType,
  SumType,
  Type,
  TypeKind,
  ViewDeclaration,
} from './typeInformation';
import {
  basicTypesIdentifiers,
  getEnumDeclaration,
  getIdentifierAnyDeclaration,
  getPropsTypeDeclaration,
  getRecordDeclaration,
  getTsClass,
  getTsFunction,
  getViewPropsTypeName,
} from './typescriptGeneration';

const directoryPath = process.cwd();
const prefix = `Automatically generated by expo-type-information.

This autogenerated file provides a mock for native Expo module,
and works out of the box with the expo jest preset.
`;

function getBasicTypeMockLiteral(type: BasicType): ts.PrimaryExpression | undefined {
  switch (type) {
    case BasicType.STRING:
      return ts.factory.createStringLiteral('');
    case BasicType.BOOLEAN:
      return ts.factory.createFalse();
    case BasicType.NUMBER:
      return ts.factory.createNumericLiteral(0);
    case BasicType.VOID:
    case BasicType.UNDEFINED:
    case BasicType.ANY:
    default:
      return undefined;
  }
}

function getBasicTypeFromString(basicType: string): BasicType | undefined {
  switch (basicType) {
    case 'any':
      return BasicType.ANY;
    case 'number':
      return BasicType.NUMBER;
    case 'string':
      return BasicType.STRING;
    case 'boolean':
      return BasicType.BOOLEAN;
  }
  return undefined;
}

function getMockedEnumInstance(enumType: EnumType): ts.Expression | undefined {
  if (enumType.cases.length === 0) {
    return undefined;
  }

  return ts.factory.createPropertyAccessExpression(
    ts.factory.createRegularExpressionLiteral(enumType.name),
    enumType.cases[0]
  );
}

function getMockedRecordInstance(recordType: RecordType, fileTypeInformation: FileTypeInformation) {
  return ts.factory.createObjectLiteralExpression(
    recordType.fields.map((f) =>
      ts.factory.createPropertyAssignment(
        f.name,
        getMockedValueForType(f.type, fileTypeInformation) ?? ts.factory.createNull()
      )
    )
  );
}

function getMockValueForIdentifier(
  identifier: string,
  fileTypeInformation: FileTypeInformation
): ts.Expression | undefined {
  if (!fileTypeInformation.typeIdentifierDefinitionMap.has(identifier)) {
    return undefined;
  }

  const typeDefinition = fileTypeInformation.typeIdentifierDefinitionMap.get(identifier);
  switch (typeDefinition?.kind) {
    case IdentifierKind.BASIC: {
      const basicType = getBasicTypeFromString(typeDefinition.definition as string);
      if (basicType) {
        return getBasicTypeMockLiteral(basicType);
      }
      return undefined;
    }
    case IdentifierKind.ENUM:
      return getMockedEnumInstance(typeDefinition.definition as EnumType);
    case IdentifierKind.RECORD:
      return getMockedRecordInstance(typeDefinition.definition as RecordType, fileTypeInformation);
  }
  return undefined;
}

function getMockedValueForType(
  type: Type,
  fileTypeInformation: FileTypeInformation
): ts.Expression | undefined {
  switch (type.kind) {
    case TypeKind.BASIC:
      return getBasicTypeMockLiteral(type.type as BasicType);
    case TypeKind.IDENTIFIER:
      return getMockValueForIdentifier(type.type as string, fileTypeInformation);
    case TypeKind.SUM:
      return getMockedValueForType((type.type as SumType).types[0], fileTypeInformation);
    case TypeKind.PARAMETRIZED:
      return ts.factory.createNull();
    case TypeKind.OPTIONAL:
      return getMockedValueForType(type.type as OptionalType, fileTypeInformation);
    case TypeKind.ARRAY:
      return ts.factory.createArrayLiteralExpression();
    case TypeKind.DICTIONARY:
      return ts.factory.createObjectLiteralExpression();
  }
}

function maybeWrapWithReturnStatement(
  type: Type,
  fileTypeInformation: FileTypeInformation
): ts.ReturnStatement[] {
  if (type.kind === TypeKind.BASIC) {
    const basicType = type.type as BasicType;
    if (basicType === BasicType.VOID || basicType === BasicType.ANY) {
      return [];
    }
  }
  // TODO Maybe add a fallback similar to original, when we cannot provide return statement
  return [ts.factory.createReturnStatement(getMockedValueForType(type, fileTypeInformation))];
}

function getPrefix() {
  return [ts.factory.createJSDocComment(prefix)];
}

const newlineIdentifier = ts.factory.createIdentifier('\n\n') as any;

function getMockedFunctionDeclaration(
  functionDeclaration: FunctionDeclaration,
  fileTypeInformation: FileTypeInformation,
  async: boolean,
  exported: boolean
): ts.FunctionDeclaration {
  return getTsFunction(
    functionDeclaration,
    async,
    false,
    exported,
    false,
    maybeWrapWithReturnStatement(functionDeclaration.returnType, fileTypeInformation)
  ) as ts.FunctionDeclaration;
}

function getFunctionReturnBlock(
  functionDeclaration: FunctionDeclaration,
  fileTypeInformation: FileTypeInformation
): ts.ReturnStatement[] {
  return maybeWrapWithReturnStatement(functionDeclaration.returnType, fileTypeInformation);
}

function getMockedClass(
  classDeclaration: ClassDeclaration,
  fileTypeInformation: FileTypeInformation
): ts.ClassDeclaration {
  return getTsClass(classDeclaration, fileTypeInformation, true, false, getFunctionReturnBlock);
}

function getMockedView(viewDeclaration: ViewDeclaration): ts.Node[] {
  const propsTypeName = getViewPropsTypeName(viewDeclaration);
  const propsType = getPropsTypeDeclaration(
    propsTypeName,
    viewDeclaration.props,
    viewDeclaration.events
  );
  const propsParameter = ts.factory.createParameterDeclaration(
    undefined,
    undefined,
    'props',
    undefined,
    ts.factory.createTypeReferenceNode(propsTypeName, undefined),
    undefined
  );
  const viewFunction = ts.factory.createFunctionDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    undefined,
    (viewDeclaration.name?.length ?? 0) > 0 ? viewDeclaration.name : 'View',
    undefined,
    [propsParameter],
    undefined,
    ts.factory.createBlock([])
  );
  return [...propsType, viewFunction];
}

function getMockForModule(
  module: ModuleClassDeclaration,
  fileTypeInformation: FileTypeInformation
) {
  const undeclaredTypeIdentifiers: Set<string> = fileTypeInformation.usedTypeIdentifiers
    .difference(fileTypeInformation.declaredTypeIdentifiers)
    .difference(basicTypesIdentifiers());
  return ([] as ts.Node[])
    .concat(
      getPrefix(),
      newlineIdentifier,
      [...undeclaredTypeIdentifiers].map((identifier) =>
        getIdentifierAnyDeclaration(identifier, fileTypeInformation.typeParametersCount)
      ),
      newlineIdentifier,
      fileTypeInformation.records.flatMap(getRecordDeclaration),
      newlineIdentifier,
      fileTypeInformation.enums.flatMap(getEnumDeclaration),
      newlineIdentifier,
      module.functions.map((f) =>
        getMockedFunctionDeclaration(f, fileTypeInformation, false, true)
      ),
      module.asyncFunctions.map((f) =>
        getMockedFunctionDeclaration(f, fileTypeInformation, true, true)
      ),
      module.classes.map((c) => getMockedClass(c, fileTypeInformation)),
      module.views.map((v) => getMockedView(v)).flat()
    )
    .flat();
}

// async function prettifyCode(text: string, parser: 'babel' | 'typescript' = 'babel') {
//   return await prettier.format(text, {
//     parser,
//     tabWidth: 2,
//     printWidth: 100,
//     trailingComma: 'none',
//     singleQuote: true,
//   });
// }

export function generateTSMockForModule(
  module: ModuleClassDeclaration,
  fileTypeInformation: FileTypeInformation,
  includeTypes: boolean
): string {
  const mockFileName = module.name + (includeTypes ? '.ts' : '.js');
  const mock = ts.factory.createNodeArray(getMockForModule(module, fileTypeInformation));

  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  // get ts nodearray from getMockForModule(m) array
  const resultFile = ts.createSourceFile(
    mockFileName,
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TSX
  );
  const printedTs = printer.printList(
    ts.ListFormat.MultiLine + ts.ListFormat.PreserveLines,
    mock,
    resultFile
  );

  if (includeTypes) {
    return printedTs;
  }
  return ts.transpileModule(printedTs, {
    compilerOptions: {
      module: ts.ModuleKind.ESNext,
      target: ts.ScriptTarget.ESNext,
    },
  }).outputText;
}

export async function generateMocks(
  files: FileTypeInformation[],
  outputLanguage: 'javascript' | 'typescript' = 'javascript'
) {
  if (files.length > 0) {
    fs.mkdirSync(path.join(directoryPath, 'mocks'), { recursive: true });
  }

  for (const file of files) {
    for (const module of file.moduleClasses) {
      const mockFileName = module.name + (outputLanguage === 'typescript' ? '.ts' : '.js');
      const mockFilePath = path.join(directoryPath, 'mocks', mockFileName);
      const printedCode = generateTSMockForModule(module, file, outputLanguage === 'typescript');

      if (outputLanguage === 'javascript') {
        // const prettifiedJs = await prettifyCode(printedCode);
        const prettifiedJs = printedCode;
        fs.writeFileSync(mockFilePath, prettifiedJs);
      } else {
        // const prettifiedTs = await prettifyCode(printedCode, 'typescript');
        const prettifiedTs = printedCode;
        fs.writeFileSync(mockFilePath, prettifiedTs);
      }
    }
  }
}

const rootDir = process.cwd();
const pattern = `${rootDir}/**/*.swift`;
export function getAllExpoModulesInWorkingDirectory(): FileTypeInformation[] {
  const files = globSync(pattern);
  return files
    .map((file) => getFileTypeInformation(fs.realpathSync(file)))
    .filter((f) => f) as FileTypeInformation[];
}
