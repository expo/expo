'use strict';
import prettier from 'prettier';
import ts from 'typescript';

import {
  ArrayType,
  BasicType,
  ClassDeclaration,
  ConstructorDeclaration,
  DictionaryType,
  EnumType,
  FileTypeInformation,
  FunctionDeclaration,
  ModuleClassDeclaration,
  ParametrizedType,
  PropDeclaration,
  PropertyDeclaration,
  RecordType,
  SumType,
  Type,
  TypeKind,
  ViewDeclaration,
} from './typeInformation';

const prefix = `Automatically generated by expo-cli.

This autogenerated file provides TS types for native Expo module or view,
and works out of the box with local native modules.
`;

function getPrefix() {
  return [ts.factory.createJSDocComment(prefix)];
}

const newlineIdentifier = ts.factory.createIdentifier('\n\n') as any;

function getOneNamedImport(importedName: string, importFromName: string) {
  return ts.factory.createImportDeclaration(
    undefined,
    ts.factory.createImportClause(
      undefined,
      undefined,
      ts.factory.createNamedImports([
        ts.factory.createImportSpecifier(
          false,
          undefined,
          ts.factory.createIdentifier(importedName)
        ),
      ])
    ),
    ts.factory.createStringLiteral(importFromName),
    undefined
  );
}

function wrapWithPromise(typeNode: ts.TypeNode): ts.TypeNode {
  return ts.factory.createTypeReferenceNode('Promise', [typeNode]);
}

function getClassPropertyDeclaration(declaration: PropertyDeclaration): ts.PropertyDeclaration {
  return ts.factory.createPropertyDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
    declaration.name,
    undefined,
    mapTypeToTsTypeNode(declaration.type),
    undefined
  );
}

function getClassDeclarationInModule(classDeclaration: ClassDeclaration): ts.ClassElement {
  return ts.factory.createPropertyDeclaration(
    undefined,
    classDeclaration.name,
    undefined,
    // TODO that's a hack, but I couldn't find a proper way to do this
    // The problem is that declare class semantics seem somewhat different than class semantics.
    ts.factory.createTypeReferenceNode('typeof ' + classDeclaration.name),
    undefined
  );
}

function getExportDeclareModifiers(): ts.ModifierLike[] {
  return [
    ts.factory.createModifier(ts.SyntaxKind.ExportKeyword),
    ts.factory.createToken(ts.SyntaxKind.DeclareKeyword),
  ];
}

function getExportedModuleDeclaration(moduleClassDeclaration: ModuleClassDeclaration): ts.Node[] {
  return [
    ts.factory.createClassDeclaration(
      getExportDeclareModifiers(),
      moduleClassDeclaration.name,
      undefined,
      [
        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          ts.factory.createExpressionWithTypeArguments(
            ts.factory.createIdentifier('NativeModule'),
            undefined
          ),
        ]),
      ],
      ([] as ts.ClassElement[]).concat(
        moduleClassDeclaration.constants.map(getClassPropertyDeclaration),
        moduleClassDeclaration.properties.map(getClassPropertyDeclaration),
        moduleClassDeclaration.functions.map(getSyncMethodDeclaration),
        moduleClassDeclaration.asyncFunctions.map(getAsyncMethodDeclaration),
        moduleClassDeclaration.classes.map(getClassDeclarationInModule)
      )
    ),
  ];
}

function getArgumentDeclaration(arg: { name: string; type: Type }): ts.ParameterDeclaration {
  const optional = arg.type.kind === TypeKind.OPTIONAL;
  const argType = optional ? (arg.type.type as Type) : arg.type;

  return ts.factory.createParameterDeclaration(
    undefined,
    undefined,
    arg.name,
    optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,
    mapTypeToTsTypeNode(argType),
    undefined
  );
}

function getAsyncMethodDeclaration(functionDeclaration: FunctionDeclaration): ts.MethodDeclaration {
  return getMethodDeclration(functionDeclaration, true);
}

function getSyncMethodDeclaration(functionDeclaration: FunctionDeclaration): ts.MethodDeclaration {
  return getMethodDeclration(functionDeclaration, false);
}

function getMethodDeclration(
  functionDeclaration: FunctionDeclaration,
  async: boolean
): ts.MethodDeclaration {
  let returnTypeNode = mapTypeToTsTypeNode(functionDeclaration.returnType);
  if (async) {
    returnTypeNode = wrapWithPromise(returnTypeNode);
  }
  return ts.factory.createMethodDeclaration(
    [],
    undefined,
    functionDeclaration.name,
    undefined,
    undefined,
    functionDeclaration.arguments.map(getArgumentDeclaration),
    returnTypeNode,
    undefined
  );
}

function mapBasicTypeToTsNode(basicType: BasicType): ts.TypeNode {
  return ts.factory.createKeywordTypeNode(
    (() => {
      switch (basicType) {
        case BasicType.ANY:
          return ts.SyntaxKind.AnyKeyword;
        case BasicType.BOOLEAN:
          return ts.SyntaxKind.BooleanKeyword;
        case BasicType.NUMBER:
          return ts.SyntaxKind.NumberKeyword;
        case BasicType.STRING:
          return ts.SyntaxKind.StringKeyword;
        case BasicType.VOID:
          return ts.SyntaxKind.VoidKeyword;
        case BasicType.UNDEFINED:
          return ts.SyntaxKind.UndefinedKeyword;
      }
    })()
  );
}

function createDictionaryTypeNode(type: DictionaryType): ts.TypeNode {
  return ts.factory.createTypeLiteralNode([
    ts.factory.createIndexSignature(
      undefined,
      [
        ts.factory.createParameterDeclaration(
          undefined,
          undefined,
          'key',
          undefined,
          mapTypeToTsTypeNode(type.key),
          undefined
        ),
      ],
      mapTypeToTsTypeNode(type.value)
    ),
  ]);
}

function mapTypeToTsTypeNode(type: Type): ts.TypeNode {
  switch (type.kind) {
    case TypeKind.BASIC:
      return mapBasicTypeToTsNode(type.type as BasicType);
    case TypeKind.IDENTIFIER:
      if (type.type === 'unknown') {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
      }
      return ts.factory.createTypeReferenceNode(type.type as string);
    case TypeKind.SUM:
      return ts.factory.createUnionTypeNode((type.type as SumType).types.map(mapTypeToTsTypeNode));
    case TypeKind.ARRAY:
      return ts.factory.createArrayTypeNode(mapTypeToTsTypeNode(type.type as ArrayType));
    case TypeKind.DICTIONARY:
      return createDictionaryTypeNode(type.type as DictionaryType);

    // Technically this one should only be the top one and it should be handled somewhere else
    // for example when creating arguemnt adding the '?' token.
    //
    // However we can just make it (type | undefined) in here.
    // TODO Maybe also need null?
    case TypeKind.OPTIONAL:
      return ts.factory.createUnionTypeNode([
        mapTypeToTsTypeNode(type.type as Type),
        mapBasicTypeToTsNode(BasicType.UNDEFINED),
      ]);
    case TypeKind.PARAMETRIZED:
      return ts.factory.createTypeReferenceNode(
        (type.type as ParametrizedType).name,
        (type.type as ParametrizedType).types.map(mapTypeToTsTypeNode)
      );
  }
  return mapBasicTypeToTsNode(BasicType.ANY);
}

function getClassConstructorDeclaration(constructor: ConstructorDeclaration): ts.ClassElement {
  return ts.factory.createConstructorDeclaration(
    undefined,
    constructor.arguments.map(getArgumentDeclaration),
    undefined
  );
}

function getExportedClassDeclaration(classDeclaration: ClassDeclaration): ts.Node[] {
  const constructorDeclaration = classDeclaration.constructor
    ? getClassConstructorDeclaration(classDeclaration.constructor)
    : undefined;
  return ([] as ts.Node[]).concat(
    ts.factory.createClassDeclaration(
      getExportDeclareModifiers(),
      ts.factory.createIdentifier(classDeclaration.name),
      undefined,
      [
        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          ts.factory.createExpressionWithTypeArguments(
            ts.factory.createIdentifier('SharedObject'),
            undefined
          ),
        ]),
      ],
      ([] as (ts.ClassElement | undefined)[])
        .concat(
          classDeclaration.methods.map(getSyncMethodDeclaration),
          classDeclaration.asyncMethods.map(getAsyncMethodDeclaration),
          classDeclaration.properties.map(getClassPropertyDeclaration),
          constructorDeclaration
        )
        .filter((v) => !!v)
    )
  );
}

function getModuleDefaultValueExport(defaultValueTypename: string): ts.Node[] {
  return ([] as ts.Node[]).concat(
    ts.factory.createParameterDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ConstKeyword)],
      undefined,
      '_default',
      undefined,
      ts.factory.createTypeReferenceNode(defaultValueTypename),
      undefined
    ),
    ts.factory.createExportDefault(ts.factory.createIdentifier('_default'))
  );
}

function getIdentifierAnyDeclaration(identifier: string): ts.Node {
  return ts.factory.createTypeAliasDeclaration(
    undefined,
    identifier,
    undefined,
    ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)
  );
}

function getRecordDeclaration(recordType: RecordType): ts.Node {
  return ts.factory.createTypeAliasDeclaration(
    undefined,
    recordType.name,
    undefined,
    ts.factory.createTypeLiteralNode(
      recordType.fields.map((field) => {
        const optional = field.type.kind === TypeKind.OPTIONAL;
        const argType = optional ? (field.type.type as Type) : field.type;
        return ts.factory.createPropertySignature(
          undefined,
          field.name,
          optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,
          mapTypeToTsTypeNode(argType)
        );
      })
    )
  );
}

function getEnumDeclaration(enumType: EnumType): ts.Node {
  return ts.factory.createEnumDeclaration(
    undefined,
    enumType.name,
    enumType.cases.map((enumcase) => ts.factory.createEnumMember(enumcase))
  );
}

function getModuleTypesDeclarationsForModule(
  moduleClassDeclaration: ModuleClassDeclaration,
  recordTypes: RecordType[],
  enumTypes: EnumType[],
  undeclaredTypeIdentifiers: Set<string>
): ts.Node[] {
  return ([] as ts.Node[]).concat(
    getPrefix(),
    newlineIdentifier,
    getOneNamedImport('NativeModule', 'expo'),
    newlineIdentifier,
    [...undeclaredTypeIdentifiers].map(getIdentifierAnyDeclaration),
    newlineIdentifier,
    recordTypes.flatMap(getRecordDeclaration),
    newlineIdentifier,
    enumTypes.flatMap(getEnumDeclaration),
    newlineIdentifier,
    moduleClassDeclaration.classes.flatMap(getExportedClassDeclaration),
    newlineIdentifier,
    getExportedModuleDeclaration(moduleClassDeclaration),
    newlineIdentifier,
    getModuleDefaultValueExport(moduleClassDeclaration.name)
  );
}

function getPropTypeElementDeclaration(propDeclaration: PropDeclaration): ts.TypeElement {
  return ts.factory.createPropertySignature(
    [],
    propDeclaration.name,
    undefined,
    mapTypeToTsTypeNode(propDeclaration.arguments[1].type)
  );
}

function getPropsTypeDeclaration(propsDeclaration: PropDeclaration[]): ts.Node[] {
  return ([] as ts.Node[]).concat(
    ts.factory.createInterfaceDeclaration(
      // [ts.factory.createModifier([ts.SyntaxKind.ExportKeyword])],
      [],
      'Props',
      undefined,
      [
        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          ts.factory.createExpressionWithTypeArguments(
            ts.factory.createIdentifier('ViewProps'),
            []
          ),
        ]),
      ],
      propsDeclaration.map(getPropTypeElementDeclaration)
    )
  );
}

function getViewDefaultValueExport(view: ViewDeclaration): ts.Node[] {
  return ([] as ts.Node[]).concat(
    ts.factory.createParameterDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ConstKeyword)],
      undefined,
      '_default',
      undefined,
      ts.factory.createTypeReferenceNode('React.JSXElementConstructor', [
        ts.factory.createTypeReferenceNode('Props'),
      ]),
      undefined
    ),
    ts.factory.createExportDefault(ts.factory.createIdentifier('_default'))
  );
}

function getViewTypesDeclarationsForModule(
  moduleClassDeclaration: ModuleClassDeclaration,
  usedTypeIdentifiers: Set<string>
): ts.Node[] {
  if (moduleClassDeclaration.views.length === 0) {
    return [];
  }
  return ([] as ts.Node[]).concat(
    getPrefix(),
    newlineIdentifier,
    getOneNamedImport('SharedObject', 'expo'),
    newlineIdentifier,
    getOneNamedImport('ViewProps', 'react-native'),
    newlineIdentifier,
    [...usedTypeIdentifiers].map(getIdentifierAnyDeclaration),
    newlineIdentifier,
    getPropsTypeDeclaration(moduleClassDeclaration.views[0].props),
    newlineIdentifier,
    getViewDefaultValueExport(moduleClassDeclaration.views[0])
  );
}

async function prettifyCode(text: string, parser: 'babel' | 'typescript' = 'babel') {
  return await prettier.format(text, {
    parser,
    tabWidth: 2,
    printWidth: 100,
    trailingComma: 'none',
    singleQuote: true,
  });
}

async function prettyPrintTSNodesToString(file: string, elements: ts.Node[]) {
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const resultFile = ts.createSourceFile(
    file,
    '',
    ts.ScriptTarget.Latest,
    false,
    ts.ScriptKind.TSX
  );
  const viewTypes = ts.factory.createNodeArray(elements);
  const printedTs = printer.printList(
    ts.ListFormat.MultiLine + ts.ListFormat.PreserveLines,
    viewTypes,
    resultFile
  );
  return await prettifyCode(printedTs, 'typescript');
}

export async function getGeneratedViewTypesFileContent(
  file: string,
  fileTypeInformation: FileTypeInformation
): Promise<string> {
  const outputModuleDefinition = fileTypeInformation.moduleClasses[0];
  return prettyPrintTSNodesToString(
    file,
    getViewTypesDeclarationsForModule(
      outputModuleDefinition,
      fileTypeInformation.usedTypeIdentifiers
    )
  );
}

export async function getGeneratedModuleTypesFileContent(
  file: string,
  fileTypeInformation: FileTypeInformation
): Promise<string> {
  const moduleClassDeclaration: ModuleClassDeclaration = fileTypeInformation.moduleClasses.at(
    0
  ) ?? {
    name: 'EmptyModule',
    asyncFunctions: [],
    functions: [],
    properties: [],
    classes: [],
    views: [],
    constants: [],
    props: [],
    events: [],
  };
  return prettyPrintTSNodesToString(
    file,
    getModuleTypesDeclarationsForModule(
      moduleClassDeclaration,
      fileTypeInformation.records,
      fileTypeInformation.enums,
      fileTypeInformation.usedTypeIdentifiers.difference(
        fileTypeInformation.declaredTypeIdentifiers
      )
    )
  );
}
