{"version":3,"file":"BlobModule.js","sourceRoot":"","sources":["../src/BlobModule.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,mBAAmB,EAAE,MAAM,MAAM,CAAC;AAG3C,MAAM,gBAAgB,GAAQ,mBAAmB,CAAC,UAAU,CAAC,CAAC;AAE9D,MAAM,OAAO,QAAS,SAAQ,gBAAgB,CAAC,IAAI;IAClD,YAAY,SAAe,EAAE,OAAyB;QACrD,KAAK,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;IAC3B,CAAC;IAED,KAAK,CAAC,KAAc,EAAE,GAAY,EAAE,WAAoB;QACvD,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE,WAAW,CAAC,CAAC;QACxD,MAAM,OAAO,GAAoB;YAChC,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,OAAO,EAAE,UAAU,CAAC,OAAO;SAC3B,CAAC;QACF,OAAO,IAAI,QAAQ,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC1C,CAAC;IAED,KAAK,CAAC,IAAI;QACT,OAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;IACtC,CAAC;IAED,MAAM;QACL,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC;QAC1B,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;QAClC,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,OAAO,IAAI,cAAc,CAAa;YACrC,IAAI,CAAC,UAAU;gBACd,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;oBAC3B,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;oBAC3C,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;gBACvB,CAAC;qBAAM,CAAC;oBACP,UAAU,CAAC,KAAK,EAAE,CAAC;gBACpB,CAAC;YACF,CAAC;SACD,CAAC,CAAC;IACJ,CAAC;CACD","sourcesContent":["import { requireNativeModule } from \"expo\";\nimport { Blob } from \"./BlobModule.types\";\n\nconst NativeBlobModule: any = requireNativeModule(\"ExpoBlob\");\n\nexport class ExpoBlob extends NativeBlobModule.Blob implements Blob {\n\tconstructor(blobParts?: any, options?: BlobPropertyBag) {\n\t\tsuper(blobParts, options);\n\t}\n\n\tslice(start?: number, end?: number, contentType?: string): Blob {\n\t\tconst slicedBlob = super.slice(start, end, contentType);\n\t\tconst options: BlobPropertyBag = {\n\t\t\ttype: slicedBlob.type,\n\t\t\tendings: slicedBlob.endings,\n\t\t};\n\t\treturn new ExpoBlob(slicedBlob, options);\n\t}\n\n\tasync text(): Promise<string> {\n\t\treturn Promise.resolve(super.text());\n\t}\n\n\tstream(): ReadableStream {\n\t\tconst text = super.text();\n\t\tconst encoder = new TextEncoder();\n\t\tconst uint8 = encoder.encode(text);\n\t\tlet offset = 0;\n\t\treturn new ReadableStream<Uint8Array>({\n\t\t\tpull(controller) {\n\t\t\t\tif (offset < uint8.length) {\n\t\t\t\t\tcontroller.enqueue(uint8.subarray(offset));\n\t\t\t\t\toffset = uint8.length;\n\t\t\t\t} else {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n"]}