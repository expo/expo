{"version":3,"file":"ExpoBlob.js","sourceRoot":"","sources":["../src/ExpoBlob.ts"],"names":[],"mappings":"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","sourcesContent":["import { requireNativeModule } from 'expo';\n\nimport { BlobPart, ExpoBlobModule } from './ExpoBlob.types';\nimport {\n  DEFAULT_CHUNK_SIZE,\n  isTypedArray,\n  normalizedContentType,\n  preprocessOptions,\n} from './utils';\n\nconst inputMapping = (blobPart: BlobPart) => {\n  if (blobPart instanceof ArrayBuffer) {\n    return new Uint8Array(blobPart);\n  }\n  if (blobPart instanceof Blob || isTypedArray(blobPart)) {\n    return blobPart;\n  }\n  return String(blobPart);\n};\n\nconst NativeBlobModule = requireNativeModule<ExpoBlobModule>('ExpoBlob');\n\nexport class Blob extends NativeBlobModule.Blob {\n  constructor(blobParts?: BlobPart[] | Iterable<BlobPart>, options?: BlobPropertyBag) {\n    if (!new.target) {\n      throw new TypeError(\"Blob constructor requires 'new' operator\");\n    }\n\n    const processedBlobParts: BlobPart[] = [];\n\n    if (blobParts === undefined) {\n      super([], preprocessOptions(options));\n    } else if (blobParts === null || typeof blobParts !== 'object') {\n      throw TypeError('Blob constructor requires blobParts to be a non-null object or undefined');\n    } else {\n      for (const blobPart of blobParts) {\n        processedBlobParts.push(inputMapping(blobPart));\n      }\n      super(processedBlobParts, preprocessOptions(options));\n    }\n  }\n\n  slice(start?: number, end?: number, contentType?: string): Blob {\n    const normalizedType = normalizedContentType(contentType);\n    const slicedBlob = super.slice(start, end, normalizedType);\n    Object.setPrototypeOf(slicedBlob, Blob.prototype);\n    return slicedBlob as Blob;\n  }\n\n  stream(): ReadableStream {\n    let getBlobBytes: (() => Promise<Uint8Array>) | null = this.bytes.bind(this);\n    let offset = 0;\n    let cachedBytes: Uint8Array | null = null;\n\n    return new ReadableStream({\n      type: 'bytes',\n      async pull(controller: ReadableByteStreamController) {\n        if (!cachedBytes) {\n          if (!getBlobBytes) {\n            throw new Error('Cannot read from a closed stream');\n          }\n          cachedBytes = await getBlobBytes();\n          getBlobBytes = null;\n        }\n\n        if (offset >= cachedBytes.length) {\n          controller.close();\n          cachedBytes = null;\n          return;\n        }\n\n        if (controller.byobRequest?.view) {\n          const view: Uint8Array = new Uint8Array(\n            controller.byobRequest.view.buffer,\n            controller.byobRequest.view.byteOffset,\n            controller.byobRequest.view.byteLength\n          );\n          const end = Math.min(offset + view.byteLength, cachedBytes.length);\n          const chunk = cachedBytes.subarray(offset, end);\n          view.set(chunk, 0);\n          controller.byobRequest.respond(chunk.length);\n          offset = end;\n          if (offset >= cachedBytes.length) {\n            controller.close();\n            cachedBytes = null;\n          }\n          return;\n        }\n\n        const chunkSize = DEFAULT_CHUNK_SIZE;\n        const end = Math.min(offset + chunkSize, cachedBytes.length);\n        controller.enqueue(cachedBytes.subarray(offset, end) as ArrayBufferView<ArrayBuffer>);\n        offset = end;\n      },\n    });\n  }\n\n  async arrayBuffer(): Promise<ArrayBuffer> {\n    return super.bytes().then(\n      (bytes: Uint8Array) =>\n        // The Blob spec requires we always return a new ArrayBuffer even when its bounds match the TypedArray's\n        bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength) as ArrayBuffer\n    );\n  }\n\n  toString(): string {\n    return '[object Blob]';\n  }\n\n  // Changed the length property to match that of the default js implementation\n  static get length() {\n    return 0;\n  }\n}\n"]}