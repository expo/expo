{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/xml-manipulation/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Element, js2xml, xml2js, Attributes } from 'xml-js';\n\nimport { readFileWithFallback, createDirAndWriteFile } from '../file-helpers';\n\ntype ExplicitNewValue<T> = { newValue: T };\ntype WithExplicitNewValue<T> = T | ExplicitNewValue<T>;\n\ntype ExpectedElementAttributes = Record<string, WithExplicitNewValue<string | number | undefined>>;\ntype WithExplicitIndex<T> = T & { idx?: number };\n\ntype ExpectedElements = WithExplicitNewValue<WithExplicitIndex<ExpectedElement>[]>;\n\nexport type ExpectedElementType = {\n  name: string;\n  attributes?: ExpectedElementAttributes;\n  elements?: ExpectedElements;\n};\n\nexport type ExpectedElementsType = {\n  elements: ExpectedElements;\n};\n\nexport type ExpectedCommentType = {\n  comment: string;\n};\n\nexport type ExpectedTextType = {\n  text: string | number | boolean;\n};\n\nexport type ExpectedElement =\n  | ExpectedElementType\n  | ExpectedElementsType\n  | ExpectedCommentType\n  | ExpectedTextType;\n\nfunction isElementType(el: ExpectedElement): el is ExpectedElementType {\n  return (el as ExpectedElementType).name !== undefined;\n}\n\nfunction isElementsType(el: ExpectedElement): el is ExpectedElementsType {\n  return !(el as ExpectedElementType).name && Boolean((el as ExpectedElementsType).elements);\n}\n\nfunction isCommentType(el: ExpectedElement): el is ExpectedCommentType {\n  return (el as ExpectedCommentType).comment !== undefined;\n}\n\nfunction isTextType(el: ExpectedElement): el is ExpectedTextType {\n  return (el as ExpectedTextType).text !== undefined;\n}\n\nfunction isExplicitNewValue<T>(el: WithExplicitNewValue<T>): el is ExplicitNewValue<T> {\n  // @ts-ignore\n  return typeof el === 'object' && el.hasOwnProperty('newValue');\n}\n\nfunction unboxExplicitNewValue<T>(el: WithExplicitNewValue<T>): T {\n  return isExplicitNewValue(el) ? el.newValue : el;\n}\n\nfunction compareElements(element: Element, expectedElement: ExpectedElement): boolean {\n  if (isTextType(expectedElement)) {\n    return element.type === 'text';\n  }\n\n  if (isCommentType(expectedElement)) {\n    return element.type === 'comment' && element.comment?.trim() === expectedElement.comment.trim();\n  }\n\n  if (isElementType(expectedElement) && element.type === 'element') {\n    if (expectedElement.name !== element.name) {\n      return false;\n    }\n\n    if (!element.attributes) {\n      return true;\n    }\n\n    for (const [key, value] of Object.entries(\n      (expectedElement as ExpectedElementType).attributes || {}\n    )) {\n      if (isExplicitNewValue(value)) {\n        // this attribute has to be overridden\n        continue;\n      }\n      if (element.attributes[key] !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction sortWithExplicitIndex<T>(elements?: WithExplicitIndex<T>[]): T[] | undefined {\n  if (!elements) {\n    return;\n  }\n  const result: T[] = new Array(elements.length);\n  const elementsWithExplicitIndices = elements.filter(({ idx }) => idx !== undefined);\n  const elementsWithoutExplicitIndices = elements.filter(({ idx }) => idx === undefined);\n  elementsWithoutExplicitIndices.forEach((el, idx) => (result[idx] = el));\n  elementsWithExplicitIndices.forEach(({ idx, ...el }, i) => {\n    // @ts-ignore\n    result.splice(idx ?? i, 0, el);\n  });\n  return result;\n}\n\nfunction mergeXmlElementsLists(\n  current?: Element[],\n  expected?: ExpectedElements\n): Element[] | undefined {\n  if (isExplicitNewValue(expected) || !current) {\n    const sortedExpected = sortWithExplicitIndex(unboxExplicitNewValue(expected));\n    return sortedExpected?.map(convertToElement);\n  }\n  if (!expected) {\n    return current;\n  }\n\n  const result: WithExplicitIndex<Element>[] = [];\n\n  for (const currentElement of current) {\n    const idxInExpected = expected.findIndex(el => compareElements(currentElement, el));\n    if (idxInExpected !== -1) {\n      const { idx, ...element } = expected.splice(idxInExpected, 1)[0];\n      result.push({ idx, ...mergeXmlElements(currentElement, element) });\n    } else {\n      result.push(currentElement);\n    }\n  }\n  result.push(...expected.map(({ idx, ...el }) => ({ idx, ...convertToElement(el) })));\n  const sortedResult = sortWithExplicitIndex(result);\n  return sortedResult;\n}\n\nfunction convertToElement(expectedElement: ExpectedElement): Element {\n  if (isCommentType(expectedElement)) {\n    return {\n      ...expectedElement,\n      type: 'comment',\n    };\n  }\n  if (isTextType(expectedElement)) {\n    return {\n      ...expectedElement,\n      type: 'text',\n    };\n  }\n  if (isElementsType(expectedElement)) {\n    return {\n      elements: unboxExplicitNewValue(expectedElement.elements).map(convertToElement),\n      type: 'element',\n    };\n  }\n  const { elements, attributes, ...expectedRest } = expectedElement;\n  const result: Element = {\n    ...expectedRest,\n    type: 'element',\n  };\n  if (attributes) {\n    result.attributes = convertExpectedAttributes(attributes);\n  }\n  if (elements) {\n    result.elements = unboxExplicitNewValue(elements).map(convertToElement);\n  }\n  return result;\n}\n\nfunction convertExpectedAttributes(\n  expectedAttributes?: ExpectedElementAttributes\n): Attributes | undefined {\n  if (expectedAttributes) {\n    const result = Object.entries(expectedAttributes).reduce(\n      (acc, [key, value]) => ({\n        ...acc,\n        [key]: unboxExplicitNewValue(value),\n      }),\n      {}\n    );\n    return result;\n  }\n  return undefined;\n}\n\nfunction mergeAndConvertToElement(\n  { attributes: currentAttributes, ...currentRest }: Omit<Element, 'elements'>,\n  { attributes: expectedAttributes, ...expectedRest }: Omit<ExpectedElementType, 'elements'>\n): Element {\n  const result: Element = {\n    ...currentRest,\n    ...expectedRest,\n  };\n  const attributes = (currentAttributes || expectedAttributes) && {\n    ...currentAttributes,\n    ...convertExpectedAttributes(expectedAttributes),\n  };\n  if (attributes) {\n    result.attributes = attributes;\n  }\n  return result;\n}\n\n/**\n * Assumption is that elements are `equal` semantically\n */\nexport function mergeXmlElements(current: Element, expected: ExpectedElement): Element {\n  if (isCommentType(expected)) {\n    return {\n      ...current,\n      ...expected,\n      type: 'comment',\n    };\n  }\n\n  if (isTextType(expected)) {\n    return {\n      ...current,\n      ...expected,\n      type: 'text',\n    };\n  }\n\n  if (isElementsType(expected)) {\n    const result = {\n      ...current,\n      type: 'element',\n    };\n    const elements = mergeXmlElementsLists(current.elements, expected.elements);\n    if (elements) {\n      result.elements = elements;\n    }\n    return result;\n  }\n\n  const { elements: currentElements, ...currentRest } = current;\n  const { elements: expectedElements, ...expectedRest } = expected;\n\n  const elements = mergeXmlElementsLists(current.elements, expected.elements);\n  const result = {\n    ...mergeAndConvertToElement(currentRest, expectedRest),\n    type: 'element',\n  };\n  if (elements) {\n    result.elements = elements;\n  }\n  return result;\n}\n\nexport async function readXmlFile(\n  filePath: string,\n  fallbackContent: string = `<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n): Promise<Element> {\n  const fileContent = await readFileWithFallback(filePath, fallbackContent);\n  const fileXml = xml2js(fileContent);\n  return fileXml as Element;\n}\n\nexport async function writeXmlFile(filePath: string, xml: Element) {\n  const fileXml = js2xml(xml, { indentAttributes: true, spaces: 2 });\n  const correctedFile = fileXml.replace(\n    /(?<openTag><[^\\s]+)\\n *(?<firstAttribute> [^\\s]+=\".+?\")\\n *((?<secondAttribute> [^\\s]+=\".+?\")\\n *)?(?<closeTag>[/?]?>)/g,\n    '$1$2$4$5'\n  );\n  await createDirAndWriteFile(filePath, `${correctedFile}\\n`);\n}\n"]}