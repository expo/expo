{"version":3,"file":"DevToolsPluginClient.js","sourceRoot":"","sources":["../../src/devtools/DevToolsPluginClient.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAqB,MAAM,WAAW,CAAC;AAG5D,OAAO,KAAK,MAAM,MAAM,UAAU,CAAC;AAEnC,iIAAiI;AACjI,MAAM,CAAC,MAAM,wBAAwB,GAAG,CAAC,CAAC;AAE1C,MAAM,CAAC,MAAM,oBAAoB,GAAG,qBAAqB,CAAC;AAE1D;;;GAGG;AACH,MAAM,OAAgB,oBAAoB;IAGL;IAFzB,YAAY,GAAiB,IAAI,YAAY,EAAE,CAAC;IAE1D,YAAmC,cAA8B;QAA9B,mBAAc,GAAd,cAAc,CAAgB;IAAG,CAAC;IAoBrE;;;;OAIG;IACI,kBAAkB,CAAC,MAAc,EAAE,QAA+B;QACvE,OAAO,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IACzD,CAAC;IAED;;;;OAIG;IACI,sBAAsB,CAAC,MAAc,EAAE,QAA+B;QAC3E,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAC3C,CAAC;IAOS,aAAa,GAAG,CAAC,KAA4B,EAAQ,EAAE;QAC/D,IAAI,OAAO,CAAC;QACZ,IAAI;YACF,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAClC;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC,CAAC,CAAC;YACvC,OAAO;SACR;QAED,IAAI,OAAO,CAAC,OAAO,KAAK,wBAAwB,IAAI,OAAO,CAAC,MAAM,KAAK,oBAAoB,EAAE;YAC3F,OAAO;SACR;QACD,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,KAAK,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE;YAC/E,OAAO;SACR;QAED,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IACvE,CAAC,CAAC;CACH","sourcesContent":["import { EventEmitter, EventSubscription } from 'fbemitter';\n\nimport type { ConnectionInfo } from './devtools.types';\nimport * as logger from './logger';\n\n// This version should be synced with the one in the **createMessageSocketEndpoint.ts** in @react-native-community/cli-server-api\nexport const MESSAGE_PROTOCOL_VERSION = 2;\n\nexport const DevToolsPluginMethod = 'Expo:DevToolsPlugin';\n\n/**\n * This client is for the Expo DevTools Plugins to communicate between the app and the DevTools webpage hosted in a browser.\n * All the code should be both compatible with browsers and React Native.\n */\nexport abstract class DevToolsPluginClient {\n  protected eventEmitter: EventEmitter = new EventEmitter();\n\n  public constructor(public readonly connectionInfo: ConnectionInfo) {}\n\n  /**\n   * Initialize the connection.\n   * @hidden\n   */\n  public abstract initAsync(): Promise<void>;\n\n  /**\n   * Close the connection.\n   */\n  public abstract closeAsync(): Promise<void>;\n\n  /**\n   * Send a message to the other end of DevTools.\n   * @param method A method name.\n   * @param params any extra payload.\n   */\n  public abstract sendMessage(method: string, params: any): void;\n\n  /**\n   * Subscribe to a message from the other end of DevTools.\n   * @param method Subscribe to a message with a method name.\n   * @param listener Listener to be called when a message is received.\n   */\n  public addMessageListener(method: string, listener: (params: any) => void): EventSubscription {\n    return this.eventEmitter.addListener(method, listener);\n  }\n\n  /**\n   * Subscribe to a message from the other end of DevTools just once.\n   * @param method Subscribe to a message with a method name.\n   * @param listener Listener to be called when a message is received.\n   */\n  public addMessageListenerOnce(method: string, listener: (params: any) => void): void {\n    this.eventEmitter.once(method, listener);\n  }\n\n  /**\n   * Returns whether the client is connected to the server.\n   */\n  public abstract isConnected(): boolean;\n\n  protected handleMessage = (event: WebSocketMessageEvent): void => {\n    let payload;\n    try {\n      payload = JSON.parse(event.data);\n    } catch (e) {\n      logger.info('Failed to parse JSON', e);\n      return;\n    }\n\n    if (payload.version !== MESSAGE_PROTOCOL_VERSION || payload.method !== DevToolsPluginMethod) {\n      return;\n    }\n    if (payload.pluginName && payload.pluginName !== this.connectionInfo.pluginName) {\n      return;\n    }\n\n    this.eventEmitter.emit(payload.params.method, payload.params.params);\n  };\n}\n"]}