{"version":3,"file":"useIncomingShare.js","sourceRoot":"","sources":["../../src/useIncomingShare.ts"],"names":[],"mappings":"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","sourcesContent":["import { useEffect, useState, useCallback, useRef } from 'react';\nimport { AppState, AppStateStatus } from 'react-native';\n\nimport { clearSharedPayloads, getResolvedSharedPayloadsAsync, getSharedPayloads } from './Sharing';\nimport { ResolvedSharePayload, SharePayload, UseIncomingShareResult } from './Sharing.types';\n\nfunction sharePayloadsAreEqual(a: SharePayload[], b: SharePayload[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  const counts = new Map<string, number>();\n  const getKey = (item: SharePayload) => `${item.value}|${item.mimeType}|${item.shareType}`;\n\n  for (const item of a) {\n    const key = getKey(item);\n    counts.set(key, (counts.get(key) || 0) + 1);\n  }\n\n  for (const item of b) {\n    const key = getKey(item);\n    const count = counts.get(key);\n\n    if (!count) {\n      return false;\n    }\n\n    counts.set(key, count - 1);\n  }\n\n  return true;\n}\n\n/**\n * Hook, which returns the data shared with the application and updates the data if the shared payload has changed.\n */\nexport function useIncomingShare(): UseIncomingShareResult {\n  const [sharedPayloads, setSharedPayloads] = useState<SharePayload[]>(getSharedPayloads());\n  const [resolvedSharedPayloads, setResolvedSharedPayloads] = useState<ResolvedSharePayload[]>([]);\n  const [isResolving, setIsResolving] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const currentSharedDataRef = useRef<SharePayload[]>([]);\n\n  const refreshSharePayloads = useCallback(async () => {\n    try {\n      const newSharedData: SharePayload[] = getSharedPayloads() || [];\n\n      // Do not run `getResolvedSharedDataAsync` if the data hasn't changed to reduce network usage\n      if (sharePayloadsAreEqual(newSharedData, currentSharedDataRef.current)) {\n        return;\n      }\n\n      currentSharedDataRef.current = newSharedData;\n      setSharedPayloads(newSharedData);\n      setResolvedSharedPayloads([]);\n      setError(null);\n\n      if (newSharedData.length > 0) {\n        setIsResolving(true);\n        try {\n          const resolved = await getResolvedSharedPayloadsAsync();\n          setResolvedSharedPayloads(resolved);\n        } catch (e) {\n          setError(\n            e instanceof Error ? e : new Error('Unknown error during shared payload resolution')\n          );\n        } finally {\n          setIsResolving(false);\n        }\n      }\n    } catch (e) {\n      setError(e instanceof Error ? e : new Error('Failed to resolve data'));\n    }\n  }, []);\n\n  useEffect(() => {\n    refreshSharePayloads();\n\n    const subscription = AppState.addEventListener('change', (nextAppState: AppStateStatus) => {\n      if (nextAppState === 'active') {\n        refreshSharePayloads();\n      }\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, [refreshSharePayloads]);\n\n  return {\n    sharedPayloads,\n    resolvedSharedPayloads,\n    clearSharedPayloads,\n    isResolving,\n    error,\n    refreshSharePayloads,\n  };\n}\n"]}