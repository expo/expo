#!/usr/bin/env node
'use strict';

import crypto from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import { commandRunner } from "../util/commandUtils.js";
import { fileURLToPath } from 'node:url';

export const dirname = path.dirname(fileURLToPath(import.meta.url));

const generateChecksum = (data) => {
  return crypto
    .createHash('md5')
    .update(data, 'utf8')
    .digest('hex');
}

const OPTIONAL_FILES = [
  path.join('scripts', 'with-node.sh')
];

const readDirectory = (sourceDir, onFileRead, nestedDir = '') => {
  const sourceFiles = fs.readdirSync(path.join(sourceDir, nestedDir));
  return sourceFiles.map((file) => {
    const fsPath = path.join(sourceDir, nestedDir, file);
    const fsMeta = fs.lstatSync(fsPath);

    if (fsMeta.isFile()) {
      return onFileRead(fsPath, path.join(nestedDir, file));
    } else if (fsMeta.isDirectory()) {
      return readDirectory(sourceDir, onFileRead, file);
    }
  }).flat();
}

const run = async () => {
  await commandRunner(path.join(dirname, 'expo-module-readme'));

  const templatesDir = path.join(dirname, '..', 'templates');
  const templateFiles = readDirectory(templatesDir, (fullPath, relativePath) => {
    const data = fs.readFileSync(fullPath, { encoding: 'utf8' });
    return {
      path: fullPath,
      relativePath,
      checksum: generateChecksum(data)
    }
  });

  templateFiles.forEach(targetFile => {
    const sourcePath = path.join(process.cwd(), targetFile.relativePath);
    if (fs.existsSync(sourcePath)) {
      const data = fs.readFileSync(path.join(process.cwd(), targetFile.relativePath), { encoding: 'utf8' });
      if (data.includes('@generated')) {
        const checksum = generateChecksum(data);
        if (targetFile.checksum !== checksum) {
          fs.copyFileSync(targetFile.path, sourcePath);
        }
      }
    } else {
      if (!OPTIONAL_FILES.includes(targetFile.relativePath)) {
        fs.copyFileSync(targetFile.path, sourcePath);
      }
    }
  })
}

run();
