{"version":3,"file":"StackClient.js","sourceRoot":"","sources":["../../src/layouts/StackClient.tsx"],"names":[],"mappings":"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","sourcesContent":["'use client';\nimport {\n  CommonNavigationAction,\n  NavigationAction,\n  ParamListBase,\n  PartialRoute,\n  PartialState,\n  Route,\n  RouterConfigOptions,\n  StackRouter as RNStackRouter,\n  StackActionType,\n  StackNavigationState,\n} from '@react-navigation/native';\nimport {\n  NativeStackNavigationEventMap,\n  NativeStackNavigationOptions,\n  createNativeStackNavigator,\n} from '@react-navigation/native-stack';\nimport { ComponentProps } from 'react';\n\nimport { withLayoutContext } from './withLayoutContext';\nimport { UniqueOptions, getUniqueId } from '../useScreens';\n\ntype GetId = NonNullable<RouterConfigOptions['routeGetIdList'][string]>;\n\nconst NativeStackNavigator = createNativeStackNavigator().Navigator;\n\nconst RNStack = withLayoutContext<\n  NativeStackNavigationOptions,\n  typeof NativeStackNavigator,\n  StackNavigationState<ParamListBase>,\n  NativeStackNavigationEventMap\n>(NativeStackNavigator);\n\nfunction isStackAction(\n  action: NavigationAction\n): action is StackActionType | Extract<CommonNavigationAction, { type: 'NAVIGATE' }> {\n  return (\n    action.type === 'PUSH' ||\n    action.type === 'NAVIGATE' ||\n    action.type === 'POP' ||\n    action.type === 'POP_TO_TOP' ||\n    action.type === 'REPLACE'\n  );\n}\n\n/**\n * React Navigation matches a screen by its name or a 'getID' function that uniquely identifies a screen.\n * When a screen has been uniquely identified, the Stack can only have one instance of that screen.\n *\n * Expo Router allows for a screen to be matched by name and path params, a 'getID' function or a unique id.\n *\n * Instead of reimplementing the entire StackRouter, we can override the getStateForAction method to handle the unique screen logic.\n *\n */\nexport const stackRouterOverride: NonNullable<ComponentProps<typeof RNStack>['UNSTABLE_router']> = (\n  original\n) => {\n  return {\n    getStateForAction: (state, action, options) => {\n      if (action.target && action.target !== state.key) {\n        return null;\n      }\n\n      if (!isStackAction(action)) {\n        return original.getStateForAction(state, action, options);\n      }\n\n      // The dynamic getId added to an action, `router.push('screen', { unique: true })`\n      const actionGetId =\n        action.payload && 'unique' in action.payload\n          ? (action.payload.unique as UniqueOptions)\n          : undefined;\n\n      // Handle if 'getID' or 'unique' is set.\n      function getIdFunction(fn?: GetId): GetId | undefined {\n        // Actions can be fired by the user, so we do need to validate their structure.\n        if (\n          !('payload' in action) ||\n          !action.payload ||\n          !('name' in action.payload) ||\n          typeof action.payload.name !== 'string'\n        ) {\n          return;\n        }\n\n        const name = action.payload.name;\n\n        // The static getId added as a prop to `<Screen unique />` or `<Screen getId={} />`\n        const screenGetId = options.routeGetIdList[name];\n\n        // If the navigation action has a unique id function, use it.\n        return getActionUniqueIdFn(actionGetId, name) || screenGetId || fn;\n      }\n\n      switch (action.type) {\n        case 'PUSH': {\n          /**\n           * PUSH should always push\n           *\n           * If 'getID' or 'unique' is set and a match is found, instead of pushing a new screen,\n           * the existing screen will be moved to the HEAD of the stack. If there are multiple matches, the rest will be removed.\n           */\n          const nextState = original.getStateForAction(state, action, {\n            ...options,\n            routeGetIdList: {\n              ...options.routeGetIdList,\n              [action.payload.name]: getIdFunction(),\n            },\n          });\n\n          return actionGetId ? filterUnique(nextState, actionGetId) : nextState;\n        }\n        case 'NAVIGATE': {\n          /**\n           * NAVIGATE should push unless the current name & route params of the current and target screen match.\n           * Search params and hashes should be ignored.\n           *\n           * If the name, route params & search params match, no action is taken.\n           * If both the name and route params match, the screen is replaced.\n           * If the name / route params do not match, the screen is pushed.\n           *\n           * If 'getID' or 'unique' is set and a match is found, instead of pushing a new screen,\n           * the existing screen will be moved to the HEAD of the stack. If there are multiple matches, the rest will be removed.\n           */\n          const nextState = original.getStateForAction(state, action, {\n            ...options,\n            routeGetIdList: {\n              ...options.routeGetIdList,\n              [action.payload.name]: getIdFunction((options) => {\n                return getUniqueId(action.payload.name, options);\n              }),\n            },\n          });\n\n          return actionGetId ? filterUnique(nextState, actionGetId) : nextState;\n        }\n        default: {\n          return original.getStateForAction(state, action, options);\n        }\n      }\n    },\n  };\n};\n\nfunction getActionUniqueIdFn(\n  actionGetId: UniqueOptions | undefined,\n  name: string\n): GetId | undefined {\n  if (typeof actionGetId === 'function') {\n    return (options) => actionGetId(options.params ?? {});\n  } else if (actionGetId === true) {\n    return (options) => getUniqueId(name, options);\n  }\n\n  return undefined;\n}\n\n/**\n * If there is a dynamic unique on an action, then we need to filter the state to only have unique screens.\n * As multiples may have been added before we did the unique navigation.\n */\nfunction filterUnique<\n  T extends\n    | StackNavigationState<ParamListBase>\n    | PartialState<StackNavigationState<ParamListBase>>\n    | null,\n>(state: T, unique: UniqueOptions): T {\n  if (!state || !unique) {\n    return state;\n  }\n\n  if (!state.routes) {\n    return state;\n  }\n\n  const currentIndex = state.index || state.routes.length - 1;\n  const current = state.routes[currentIndex];\n  const name = current.name;\n\n  const getId = getActionUniqueIdFn(unique, name);\n\n  if (!getId) {\n    return state;\n  }\n\n  const id = getId({ params: current.params });\n\n  // TypeScript needs a type assertion here for the filter to work.\n  let routes = state.routes as PartialRoute<Route<string, object | undefined>>[];\n  routes = routes.filter((route, index) => {\n    // If the route is the current route, keep it.\n    if (index === currentIndex) {\n      return true;\n    }\n\n    // Remove all other routes with the same name and id.\n    return name !== route.name || id !== getId({ params: route.params });\n  });\n\n  return {\n    ...state,\n    index: routes.length - 1,\n    routes,\n  };\n}\n\nconst Stack = Object.assign(\n  (props: ComponentProps<typeof RNStack>) => {\n    return <RNStack {...props} UNSTABLE_router={stackRouterOverride} />;\n  },\n  {\n    Screen: RNStack.Screen as (\n      props: ComponentProps<typeof RNStack.Screen> & { unique?: boolean }\n    ) => null,\n  }\n);\n\nexport default Stack;\n\nexport const StackRouter: typeof RNStackRouter = (options) => {\n  const router = RNStackRouter(options);\n  return {\n    ...router,\n    ...stackRouterOverride(router),\n  };\n};\n"]}