{"version":3,"file":"getRoutes.js","sourceRoot":"","sources":["../src/getRoutes.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport EXPO_ROUTER_IMPORT_MODE from './import-mode';\nimport {\n  getNameFromFilePath,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  removeSupportedExtensions,\n  stripGroupSegmentsFromPath,\n  stripInvisibleSegmentsFromPath,\n} from './matchers';\nimport type { RequireContext } from './types';\n\nexport type FileNode = Pick<RouteNode, 'contextKey' | 'loadRoute'> & {\n  /** Like `(tab)/index` */\n  normalizedName: string;\n};\n\ntype TreeNode = {\n  name: string;\n  children: TreeNode[];\n  parents: string[];\n  /** null when there is no file in a folder. */\n  node: FileNode | null;\n};\n\ntype Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n};\n\n/** Convert a flat map of file nodes into a nested tree of files. */\nexport function getRecursiveTree(files: FileNode[]): TreeNode {\n  const tree = {\n    name: '',\n    children: [],\n    parents: [],\n    node: null,\n  };\n\n  for (const file of files) {\n    // ['(tab)', 'settings', '[...another]']\n    const parts = file.normalizedName.split('/');\n    let currentNode: TreeNode = tree;\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n\n      if (i === parts.length - 1 && part === '_layout') {\n        if (currentNode.node) {\n          const overwritten = currentNode.node.contextKey;\n          throw new Error(\n            `Higher priority Layout Route \"${file.contextKey}\" overriding redundant Layout Route \"${overwritten}\". Remove the Layout Route \"${overwritten}\" to fix this.`\n          );\n        }\n        continue;\n      }\n\n      const existing = currentNode.children.find((item) => item.name === part);\n      if (existing) {\n        currentNode = existing;\n      } else {\n        const newNode: TreeNode = {\n          name: part,\n          children: [],\n          parents: [...currentNode.parents, currentNode.name],\n          node: null,\n        };\n        currentNode.children.push(newNode);\n        currentNode = newNode;\n      }\n    }\n    currentNode.node = file;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertDeprecatedFormat(tree);\n  }\n\n  return tree;\n}\n\nfunction assertDeprecatedFormat(tree: TreeNode) {\n  for (const child of tree.children) {\n    if (child.node && child.children.length && !child.node.normalizedName.endsWith('_layout')) {\n      const ext = child.node.contextKey.split('.').pop();\n      throw new Error(\n        `Using deprecated Layout Route format: Move \\`./app/${child.node.normalizedName}.${ext}\\` to \\`./app/${child.node.normalizedName}/_layout.${ext}\\``\n      );\n    }\n    assertDeprecatedFormat(child);\n  }\n}\n\nfunction getTreeNodesAsRouteNodes(nodes: TreeNode[]): RouteNode[] {\n  return nodes\n    .map((node) => treeNodeToRouteNode(node))\n    .flat()\n    .filter(Boolean) as RouteNode[];\n}\n\nexport function generateDynamicFromSegment(name: string): DynamicConvention | null {\n  const deepDynamicName = matchDeepDynamicRouteName(name);\n  const dynamicName = deepDynamicName ?? matchDynamicName(name);\n\n  return dynamicName ? { name: dynamicName, deep: !!deepDynamicName } : null;\n}\n\nexport function generateDynamic(name: string): RouteNode['dynamic'] {\n  const description = name\n    .split('/')\n    .map((segment) => generateDynamicFromSegment(segment))\n    .filter(Boolean) as DynamicConvention[];\n  return description.length === 0 ? null : description;\n}\n\nfunction collapseRouteSegments(route: string) {\n  return stripGroupSegmentsFromPath(route.replace(/\\/index$/, ''));\n}\n\n/**\n * Given a route node and a name representing the group name,\n * find the nearest child matching the name.\n *\n * Doesn't support slashes in the name.\n * Routes like `explore/(something)/index` will be matched against `explore`.\n *\n */\nfunction getDefaultInitialRoute(node: RouteNode, name: string) {\n  return node.children.find((node) => collapseRouteSegments(node.route) === name);\n}\n\nfunction applyDefaultInitialRouteName(node: RouteNode): RouteNode {\n  const groupName = matchGroupName(node.route);\n  if (!node.children?.length) {\n    return node;\n  }\n\n  // Guess at the initial route based on the group name.\n  // TODO(EvanBacon): Perhaps we should attempt to warn when the group doesn't match any child routes.\n  let initialRouteName = groupName ? getDefaultInitialRoute(node, groupName)?.route : undefined;\n  const loaded = node.loadRoute();\n\n  if (loaded?.unstable_settings) {\n    // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n    initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    initialRouteName,\n  };\n}\n\nfunction folderNodeToRouteNode({ name, children }: TreeNode): RouteNode[] | null {\n  // Empty folder, skip it.\n  if (!children.length) {\n    return null;\n  }\n\n  // When there's a directory, but no layout route file (with valid export), the child routes won't be grouped.\n  // This pushes all children into the nearest layout route.\n  return getTreeNodesAsRouteNodes(\n    children.map((child) => {\n      return {\n        ...child,\n        name: [name, child.name].filter(Boolean).join('/'),\n      };\n    })\n  );\n}\n\nfunction fileNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  const { name, node, children } = tree;\n\n  if (!node) throw new Error('node must be defined');\n\n  const dynamic = generateDynamic(name);\n\n  const clones = extrapolateGroupRoutes(name, node.contextKey);\n  clones.delete(name);\n\n  const output = {\n    loadRoute: node.loadRoute,\n    route: name,\n    contextKey: node.contextKey,\n    children: getTreeNodesAsRouteNodes(children),\n    dynamic,\n  };\n\n  if (clones.size) {\n    return [...clones].map((clone) =>\n      applyDefaultInitialRouteName({\n        ...output,\n        contextKey: node.contextKey.replace(output.route, clone),\n        route: clone,\n      })\n    );\n  }\n\n  return [\n    applyDefaultInitialRouteName({\n      loadRoute: node.loadRoute,\n      route: name,\n      contextKey: node.contextKey,\n      children: getTreeNodesAsRouteNodes(children),\n      dynamic,\n    }),\n  ];\n}\n\nfunction extrapolateGroupRoutes(\n  route: string,\n  contextKey: string,\n  routes: Set<string> = new Set()\n): Set<string> {\n  const match = matchGroupName(route);\n\n  if (!match) {\n    routes.add(route);\n    return routes;\n  }\n\n  const groups = match?.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(\n      `Array syntax cannot contain duplicate group name \"${groups}\" in \"${contextKey}\".`\n    );\n  }\n\n  if (groups.length === 1) {\n    routes.add(route);\n    return routes;\n  }\n\n  for (const group of groups) {\n    extrapolateGroupRoutes(route.replace(match, group.trim()), contextKey, routes);\n  }\n\n  return routes;\n}\n\nfunction treeNodeToRouteNode(tree: TreeNode): RouteNode[] | null {\n  if (tree.node) {\n    return fileNodeToRouteNode(tree);\n  }\n\n  return folderNodeToRouteNode(tree);\n}\n\nfunction contextModuleToFileNodes(\n  contextModule: RequireContext,\n  options: Options = {},\n  files: string[] = contextModule.keys()\n): FileNode[] {\n  const nodes = files.map((key) => {\n    // In development, check if the file exports a default component\n    // this helps keep things snappy when creating files. In production we load all screens lazily.\n    try {\n      if (process.env.NODE_ENV === 'development') {\n        // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n        // filter the missing routes.\n        if (EXPO_ROUTER_IMPORT_MODE === 'sync') {\n          const isApi = key.match(/\\+api\\.[jt]sx?$/);\n          if (!isApi && !contextModule(key)?.default) {\n            return null;\n          }\n        }\n      }\n      const node: FileNode = {\n        loadRoute() {\n          if (options.ignoreRequireErrors) {\n            try {\n              return contextModule(key);\n            } catch {\n              return {};\n            }\n          } else {\n            return contextModule(key);\n          }\n        },\n        normalizedName: getNameFromFilePath(key),\n        contextKey: key,\n      };\n\n      return node;\n    } catch (error) {\n      // Probably this won't stop metro from freaking out but it's worth a try.\n      console.warn('Error loading route \"' + key + '\"', error);\n    }\n    return null;\n  });\n\n  return nodes.filter(Boolean) as FileNode[];\n}\n\nfunction hasCustomRootLayoutNode(routes: RouteNode[]) {\n  if (routes.length !== 1) {\n    return false;\n  }\n  // This could either be the root _layout or an app with a single file.\n  const route = routes[0];\n\n  if (route.route === '' && route.contextKey.match(/^\\.\\/_layout\\.([jt]sx?)$/)) {\n    return true;\n  }\n  return false;\n}\n\nfunction treeNodesToRootRoute(treeNode: TreeNode): RouteNode | null {\n  const routes = treeNodeToRouteNode(treeNode);\n  return withOptionalRootLayout(routes);\n}\n\nfunction processKeys(files: string[], options: Options): string[] {\n  const { ignore } = options;\n\n  return files.filter((file) => {\n    return !ignore?.some((pattern) => pattern.test(file));\n  });\n}\n\n/**\n * Asserts if the require.context has files that share the same name but have different extensions. Exposed for testing.\n * @private\n */\nexport function assertDuplicateRoutes(filenames: string[]) {\n  if (process.env.NODE_ENV === 'production') {\n    return;\n  }\n\n  const duplicates = filenames\n    .map((filename) => removeSupportedExtensions(filename))\n    .reduce(\n      (acc, filename) => {\n        acc[filename] = acc[filename] ? acc[filename] + 1 : 1;\n        return acc;\n      },\n      {} as Record<string, number>\n    );\n\n  Object.entries(duplicates).forEach(([filename, count]) => {\n    if (count > 1) {\n      throw new Error(`Multiple files match the route name \"${filename}\".`);\n    }\n  });\n}\n\n/** Given a Metro context module, return an array of nested routes. */\nexport function getRoutes(contextModule: RequireContext, options?: Options): RouteNode | null {\n  const route = getExactRoutes(contextModule, options);\n\n  // If there is no route, return an empty route.\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nexport async function getRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const route = await getExactRoutesAsync(contextModule, options);\n  if (!route) {\n    return null;\n  }\n\n  appendSitemapRoute(route);\n\n  // Auto add not found route if it doesn't exist\n  appendUnmatchedRoute(route);\n\n  return route;\n}\n\nfunction getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\n/** Get routes without unmatched or sitemap. */\nexport function getExactRoutes(contextModule: RequireContext, options?: Options): RouteNode | null {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction contextModuleToTree(contextModule: RequireContext, options?: Options) {\n  const allowed = processKeys(contextModule.keys(), {\n    ...options,\n    ignore: getIgnoreList(options),\n  });\n  assertDuplicateRoutes(allowed);\n  const files = contextModuleToFileNodes(contextModule, options, allowed);\n  return getRecursiveTree(files);\n}\n\nexport async function getExactRoutesAsync(\n  contextModule: RequireContext,\n  options?: Options\n): Promise<RouteNode | null> {\n  const treeNodes = contextModuleToTree(contextModule, options);\n  const route = treeNodesToRootRoute(treeNodes);\n  return route || null;\n}\n\nfunction appendSitemapRoute(routes: RouteNode) {\n  if (\n    !routes.children.length ||\n    // Allow overriding the sitemap route\n    routes.children.some((route) => route.route === '_sitemap')\n  ) {\n    return routes;\n  }\n  routes.children.push({\n    loadRoute() {\n      const { Sitemap, getNavOptions } = require('./views/Sitemap');\n      return { default: Sitemap, getNavOptions };\n    },\n    route: '_sitemap',\n    contextKey: './_sitemap.tsx',\n    generated: true,\n    internal: true,\n    dynamic: null,\n    children: [],\n  });\n  return routes;\n}\n\nfunction appendUnmatchedRoute(routes: RouteNode) {\n  // Auto add not found route if it doesn't exist\n  const userDefinedDynamicRoute = getUserDefinedDeepDynamicRoute(routes);\n  if (!userDefinedDynamicRoute) {\n    routes.children.push({\n      loadRoute() {\n        return { default: require('./views/Unmatched').Unmatched };\n      },\n      route: '[...404]',\n      contextKey: './[...404].tsx',\n      dynamic: [{ name: '404', deep: true }],\n      children: [],\n      generated: true,\n      internal: true,\n    });\n  }\n  return routes;\n}\n\n/**\n * Exposed for testing.\n * @returns a top-level deep dynamic route if it exists, otherwise null.\n */\nexport function getUserDefinedDeepDynamicRoute(routes: RouteNode): RouteNode | null {\n  // Auto add not found route if it doesn't exist\n  for (const route of routes.children ?? []) {\n    if (route.generated) continue;\n    const opaqueRoute = stripInvisibleSegmentsFromPath(route.route);\n    const isDeepDynamic = matchDeepDynamicRouteName(opaqueRoute);\n    if (isDeepDynamic) {\n      return route;\n    }\n    // Recurse through group routes\n    if (matchGroupName(route.route)) {\n      const child = getUserDefinedDeepDynamicRoute(route);\n      if (child) {\n        return child;\n      }\n    }\n  }\n  return null;\n}\n\nfunction withOptionalRootLayout(routes: RouteNode[] | null): RouteNode | null {\n  if (!routes?.length) {\n    return null;\n  }\n\n  if (hasCustomRootLayoutNode(routes)) {\n    return routes[0];\n  }\n\n  return {\n    loadRoute: () => ({\n      default: (require('./views/Navigator') as typeof import('./views/Navigator'))\n        .DefaultNavigator,\n    }),\n    // Generate a fake file name for the directory\n    contextKey: './_layout.tsx',\n    route: '',\n    generated: true,\n    dynamic: null,\n    children: routes,\n  };\n}\n"]}