{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/testing-library/index.tsx"],"names":[],"mappings":"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","sourcesContent":["/// <reference types=\"../../types/jest\" />\nimport './expect';\n\nimport { act, render, RenderResult, screen } from '@testing-library/react-native';\nimport path from 'path';\nimport React from 'react';\n\nimport {\n  FileStub,\n  inMemoryContext,\n  requireContext,\n  requireContextWithOverrides,\n} from './context-stubs';\nimport { setInitialUrl } from './mocks';\nimport { ExpoRoot } from '../ExpoRoot';\nimport getPathFromState from '../fork/getPathFromState';\nimport { getNavigationConfig, stateCache } from '../getLinkingConfig';\nimport { getExactRoutes } from '../getRoutes';\nimport { store } from '../global-state/router-store';\nimport { router } from '../imperative-api';\n\n// re-export everything\nexport * from '@testing-library/react-native';\n\ntype RenderRouterOptions = Parameters<typeof render>[1] & {\n  initialUrl?: any;\n};\n\ntype Result = ReturnType<typeof render> & {\n  getPathname(): string;\n  getPathnameWithParams(): string;\n  getSegments(): string[];\n  getSearchParams(): Record<string, string | string[]>;\n};\n\nfunction isOverrideContext(\n  context: object\n): context is { appDir: string; overrides: Record<string, FileStub> } {\n  return Boolean(typeof context === 'object' && 'appDir' in context);\n}\n\nexport type MockContextConfig =\n  | string // Pathname to a directory\n  | string[] // Array of filenames to mock as empty components, e.g () => null\n  | Record<string, FileStub> // Map of filenames and their exports\n  | {\n      // Directory to load as context\n      appDir: string;\n      // Map of filenames and their exports. Will override contents of files loaded in `appDir\n      overrides: Record<string, FileStub>;\n    };\n\nexport function getMockConfig(context: MockContextConfig) {\n  return getNavigationConfig(getExactRoutes(getMockContext(context))!);\n}\n\nexport function getMockContext(context: MockContextConfig) {\n  if (typeof context === 'string') {\n    return requireContext(path.resolve(process.cwd(), context));\n  } else if (Array.isArray(context)) {\n    return inMemoryContext(\n      Object.fromEntries(context.map((filename) => [filename, { default: () => null }]))\n    );\n  } else if (isOverrideContext(context)) {\n    return requireContextWithOverrides(context.appDir, context.overrides);\n  } else {\n    return inMemoryContext(context);\n  }\n}\n\nexport function renderRouter(\n  context: MockContextConfig = './app',\n  { initialUrl = '/', ...options }: RenderRouterOptions = {}\n): Result {\n  jest.useFakeTimers();\n\n  const mockContext = getMockContext(context);\n\n  // Reset the initial URL\n  setInitialUrl(initialUrl);\n\n  // Force the render to be synchronous\n  process.env.EXPO_ROUTER_IMPORT_MODE = 'sync';\n  stateCache.clear();\n\n  let location: URL | undefined;\n\n  if (typeof initialUrl === 'string') {\n    location = new URL(initialUrl, 'test://');\n  } else if (initialUrl instanceof URL) {\n    location = initialUrl;\n  }\n\n  const result = render(<ExpoRoot context={mockContext} location={location} />, {\n    ...options,\n  });\n\n  return Object.assign(result, {\n    getPathname(this: RenderResult): string {\n      return store.routeInfoSnapshot().pathname;\n    },\n    getSegments(this: RenderResult): string[] {\n      return store.routeInfoSnapshot().segments;\n    },\n    getSearchParams(this: RenderResult): Record<string, string | string[]> {\n      return store.routeInfoSnapshot().params;\n    },\n    getPathnameWithParams(this: RenderResult): string {\n      return getPathFromState(store.rootState!, store.linking!.config);\n    },\n  });\n}\n\nexport const testRouter = {\n  /** Navigate to the provided pathname and the pathname */\n  navigate(path: string) {\n    act(() => router.navigate(path));\n    expect(screen).toHavePathnameWithParams(path);\n  },\n  /** Push the provided pathname and assert the pathname */\n  push(path: string) {\n    act(() => router.push(path));\n    expect(screen).toHavePathnameWithParams(path);\n  },\n  /** Replace with provided pathname and assert the pathname */\n  replace(path: string) {\n    act(() => router.replace(path));\n    expect(screen).toHavePathnameWithParams(path);\n  },\n  /** Go back in history and asset the new pathname */\n  back(path: string) {\n    expect(router.canGoBack()).toBe(true);\n    act(() => router.back());\n    if (path) {\n      expect(screen).toHavePathnameWithParams(path);\n    }\n  },\n  /** If there's history that supports invoking the `back` function. */\n  canGoBack() {\n    return router.canGoBack();\n  },\n  /** Update the current route query params and assert the new pathname */\n  setParams(params?: Record<string, string>) {\n    router.setParams(params);\n    if (path) {\n      expect(screen).toHavePathnameWithParams(path);\n    }\n  },\n};\n"]}