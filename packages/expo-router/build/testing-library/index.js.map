{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/testing-library/index.tsx"],"names":[],"mappings":"AAAA,0CAA0C;AAC1C,OAAO,UAAU,CAAC;AAElB,OAAO,EAAE,MAAM,EAAgB,MAAM,+BAA+B,CAAC;AACrE,OAAO,IAAI,MAAM,MAAM,CAAC;AACxB,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AACvC,OAAO,EAAE,UAAU,EAAE,MAAM,qBAAqB,CAAC;AACjD,OAAO,EAAE,KAAK,EAAE,MAAM,8BAA8B,CAAC;AAErD,OAAO,EAEL,eAAe,EACf,cAAc,EACd,2BAA2B,GAC5B,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AAExC,uBAAuB;AACvB,cAAc,+BAA+B,CAAC;AAY9C,SAAS,iBAAiB,CACxB,OAAe;IAEf,OAAO,OAAO,CAAC,OAAO,OAAO,KAAK,QAAQ,IAAI,QAAQ,IAAI,OAAO,CAAC,CAAC;AACrE,CAAC;AAWD,MAAM,UAAU,YAAY,CAC1B,UAG+B,OAAO,EACtC,EAAE,UAAU,GAAG,GAAG,EAAE,GAAG,OAAO,KAA0B,EAAE;IAE1D,IAAI,CAAC,aAAa,EAAE,CAAC;IAErB,IAAI,GAAmB,CAAC;IAExB,wBAAwB;IACxB,aAAa,CAAC,KAAK,GAAG,UAAiB,CAAC;IAExC,qCAAqC;IACrC,OAAO,CAAC,GAAG,CAAC,2BAA2B,GAAG,MAAM,CAAC;IACjD,OAAO,CAAC,GAAG,CAAC,2BAA2B,GAAG,MAAM,CAAC;IACjD,OAAO,CAAC,GAAG,CAAC,+BAA+B,GAAG,MAAM,CAAC;IAErD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,GAAG,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;KAC5D;SAAM,IAAI,iBAAiB,CAAC,OAAO,CAAC,EAAE;QACrC,GAAG,GAAG,2BAA2B,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;KACtE;SAAM;QACL,GAAG,GAAG,eAAe,CAAC,OAAO,CAAC,CAAC;KAChC;IAED,UAAU,CAAC,KAAK,EAAE,CAAC;IAEnB,IAAI,QAAyB,CAAC;IAE9B,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;QAClC,QAAQ,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;KAC3C;SAAM,IAAI,UAAU,YAAY,GAAG,EAAE;QACpC,QAAQ,GAAG,UAAU,CAAC;KACvB;IAED,MAAM,MAAM,GAAG,MAAM,CAAC,oBAAC,QAAQ,IAAC,OAAO,EAAE,GAAG,EAAE,QAAQ,EAAE,QAAQ,GAAI,EAAE;QACpE,GAAG,OAAO;KACX,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;QAC3B,WAAW;YACT,OAAO,KAAK,CAAC,iBAAiB,EAAE,CAAC,QAAQ,CAAC;QAC5C,CAAC;QACD,WAAW;YACT,OAAO,KAAK,CAAC,iBAAiB,EAAE,CAAC,QAAQ,CAAC;QAC5C,CAAC;QACD,eAAe;YACb,OAAO,KAAK,CAAC,iBAAiB,EAAE,CAAC,MAAM,CAAC;QAC1C,CAAC;KACF,CAAC,CAAC;AACL,CAAC","sourcesContent":["/// <reference types=\"../../types/jest\" />\nimport './expect';\n\nimport { render, RenderResult } from '@testing-library/react-native';\nimport path from 'path';\nimport React from 'react';\n\nimport { ExpoRoot } from '../ExpoRoot';\nimport { stateCache } from '../getLinkingConfig';\nimport { store } from '../global-state/router-store';\nimport { RequireContext } from '../types';\nimport {\n  FileStub,\n  inMemoryContext,\n  requireContext,\n  requireContextWithOverrides,\n} from './context-stubs';\nimport { initialUrlRef } from './mocks';\n\n// re-export everything\nexport * from '@testing-library/react-native';\n\ntype RenderRouterOptions = Parameters<typeof render>[1] & {\n  initialUrl?: any;\n};\n\ntype Result = ReturnType<typeof render> & {\n  getPathname(): string;\n  getSegments(): string[];\n  getSearchParams(): Record<string, string | string[]>;\n};\n\nfunction isOverrideContext(\n  context: object\n): context is { appDir: string; overrides: Record<string, FileStub> } {\n  return Boolean(typeof context === 'object' && 'appDir' in context);\n}\n\nexport function renderRouter(context?: string, options?: RenderRouterOptions): Result;\nexport function renderRouter(\n  context: Record<string, FileStub>,\n  options?: RenderRouterOptions\n): Result;\nexport function renderRouter(\n  context: { appDir: string; overrides: Record<string, FileStub> },\n  options?: RenderRouterOptions\n): Result;\nexport function renderRouter(\n  context:\n    | string\n    | { appDir: string; overrides: Record<string, FileStub> }\n    | Record<string, FileStub> = './app',\n  { initialUrl = '/', ...options }: RenderRouterOptions = {}\n): Result {\n  jest.useFakeTimers();\n\n  let ctx: RequireContext;\n\n  // Reset the initial URL\n  initialUrlRef.value = initialUrl as any;\n\n  // Force the render to be synchronous\n  process.env.EXPO_ROUTER_IMPORT_MODE_WEB = 'sync';\n  process.env.EXPO_ROUTER_IMPORT_MODE_IOS = 'sync';\n  process.env.EXPO_ROUTER_IMPORT_MODE_ANDROID = 'sync';\n\n  if (typeof context === 'string') {\n    ctx = requireContext(path.resolve(process.cwd(), context));\n  } else if (isOverrideContext(context)) {\n    ctx = requireContextWithOverrides(context.appDir, context.overrides);\n  } else {\n    ctx = inMemoryContext(context);\n  }\n\n  stateCache.clear();\n\n  let location: URL | undefined;\n\n  if (typeof initialUrl === 'string') {\n    location = new URL(initialUrl, 'test://');\n  } else if (initialUrl instanceof URL) {\n    location = initialUrl;\n  }\n\n  const result = render(<ExpoRoot context={ctx} location={location} />, {\n    ...options,\n  });\n\n  return Object.assign(result, {\n    getPathname(this: RenderResult): string {\n      return store.routeInfoSnapshot().pathname;\n    },\n    getSegments(this: RenderResult): string[] {\n      return store.routeInfoSnapshot().segments;\n    },\n    getSearchParams(this: RenderResult): Record<string, string | string[]> {\n      return store.routeInfoSnapshot().params;\n    },\n  });\n}\n"]}