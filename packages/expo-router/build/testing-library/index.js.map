{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/testing-library/index.tsx"],"names":[],"mappings":"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","sourcesContent":["import './expect';\nimport './mocks';\n\nimport type { RenderResult } from '@testing-library/react-native';\nimport React from 'react';\n\nimport { MockContextConfig, getMockConfig, getMockContext } from './mock-config';\nimport { ExpoRoot } from '../ExpoRoot';\nimport { ExpoLinkingOptions } from '../getLinkingConfig';\nimport { ReactNavigationState, store } from '../global-state/router-store';\nimport { router } from '../imperative-api';\n\nconst rnTestingLibrary = ((): typeof import('@testing-library/react-native') => {\n  try {\n    return require('@testing-library/react-native');\n  } catch (error: any) {\n    if ('code' in error && error.code === 'MODULE_NOT_FOUND') {\n      const newError = new Error(\n        `[expo-router/testing-library] \"@testing-library/react-native\" failed to import. You need to install it to use expo-router's testing library.`\n      );\n      newError.stack = error.stack;\n      newError.cause = error;\n      throw newError;\n    }\n    throw error;\n  }\n})();\n\nexport type * from '@testing-library/react-native';\n\n// TODO(@kitten): This is for backwards-compatibility. Consider removing this!\nexport declare const {\n  act,\n  cleanup,\n  fireEvent,\n  waitFor,\n  waitForElementToBeRemoved,\n  within,\n  configure,\n  resetToDefaults,\n  isHiddenFromAccessibility,\n  isInaccessible,\n  getDefaultNormalizer,\n  renderHook,\n  userEvent,\n}: typeof rnTestingLibrary;\n\nexport declare let screen: typeof rnTestingLibrary.screen;\n\nObject.assign(exports, rnTestingLibrary);\nObject.defineProperty(exports, 'screen', {\n  get() {\n    return rnTestingLibrary.screen;\n  },\n});\n\nexport type RenderRouterOptions = Parameters<typeof rnTestingLibrary.render>[1] & {\n  initialUrl?: any;\n  linking?: Partial<ExpoLinkingOptions>;\n};\n\ntype Result = ReturnType<typeof rnTestingLibrary.render> & {\n  getPathname(): string;\n  getPathnameWithParams(): string;\n  getSegments(): string[];\n  getSearchParams(): Record<string, string | string[]>;\n  getRouterState(): ReactNavigationState | undefined;\n};\n\nexport { MockContextConfig, getMockConfig, getMockContext };\n\nexport function renderRouter(\n  context: MockContextConfig = './app',\n  { initialUrl = '/', linking, ...options }: RenderRouterOptions = {}\n): Result {\n  jest.useFakeTimers();\n\n  const mockContext = getMockContext(context);\n\n  // Force the render to be synchronous\n  process.env.EXPO_ROUTER_IMPORT_MODE = 'sync';\n\n  const result = rnTestingLibrary.render(\n    <ExpoRoot context={mockContext} location={initialUrl} linking={linking} />,\n    options\n  );\n\n  /**\n   * This is a hack to ensure that React Navigation's state updates are processed before we run assertions.\n   * Some updates are async and we need to wait for them to complete, otherwise will we get a false positive.\n   * (that the app will briefly be in the right state, but then update to an invalid state)\n   */\n  return Object.assign(result, {\n    getPathname(this: RenderResult): string {\n      return store.getRouteInfo().pathname;\n    },\n    getSegments(this: RenderResult): string[] {\n      return store.getRouteInfo().segments;\n    },\n    getSearchParams(this: RenderResult): Record<string, string | string[]> {\n      return store.getRouteInfo().params;\n    },\n    getPathnameWithParams(this: RenderResult): string {\n      return store.getRouteInfo().pathnameWithParams;\n    },\n    getRouterState(this: RenderResult) {\n      return store.state;\n    },\n  });\n}\n\nexport const testRouter = {\n  /** Navigate to the provided pathname and the pathname */\n  navigate(path: string) {\n    rnTestingLibrary.act(() => router.navigate(path));\n    expect(rnTestingLibrary.screen).toHavePathnameWithParams(path);\n  },\n  /** Push the provided pathname and assert the pathname */\n  push(path: string) {\n    rnTestingLibrary.act(() => router.push(path));\n    expect(rnTestingLibrary.screen).toHavePathnameWithParams(path);\n  },\n  /** Replace with provided pathname and assert the pathname */\n  replace(path: string) {\n    rnTestingLibrary.act(() => router.replace(path));\n    expect(rnTestingLibrary.screen).toHavePathnameWithParams(path);\n  },\n  /** Go back in history and asset the new pathname */\n  back(path?: string) {\n    expect(router.canGoBack()).toBe(true);\n    rnTestingLibrary.act(() => router.back());\n    if (path) {\n      expect(rnTestingLibrary.screen).toHavePathnameWithParams(path);\n    }\n  },\n  /** If there's history that supports invoking the `back` function. */\n  canGoBack() {\n    return router.canGoBack();\n  },\n  /** Update the current route query params and assert the new pathname */\n  setParams(params: Record<string, string>, path?: string) {\n    router.setParams(params);\n    if (path) {\n      expect(screen).toHavePathnameWithParams(path);\n    }\n  },\n  /** If there's history that supports invoking the `back` function. */\n  dismissAll() {\n    rnTestingLibrary.act(() => router.dismissAll());\n  },\n};\n"]}