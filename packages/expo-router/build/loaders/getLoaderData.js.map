{"version":3,"file":"getLoaderData.js","sourceRoot":"","sources":["../../src/loaders/getLoaderData.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAMH,sCA6CC;AA7CD,SAAgB,aAAa,CAAI,EAC/B,YAAY,EACZ,KAAK,EACL,OAAO,GAKR;IACC,+EAA+E;IAC/E,4DAA4D;IAC5D,MAAM,WAAW,GAAG,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;IACjD,IAAI,WAAW,EAAE,CAAC;QAChB,MAAM,WAAW,CAAC;IACpB,CAAC;IAED,6BAA6B;IAC7B,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC,OAAO,CAAI,YAAY,CAAM,CAAC;IAC7C,CAAC;IAED,2BAA2B;IAC3B,MAAM,aAAa,GAAG,KAAK,CAAC,UAAU,CAAI,YAAY,CAAC,CAAC;IACxD,IAAI,aAAa,EAAE,CAAC;QAClB,OAAO,aAAa,CAAC;IACvB,CAAC;IAED,MAAM,OAAO,GAAG,OAAO,CAAC,YAAY,CAAC;SAClC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;QACb,KAAK,CAAC,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;QAClC,KAAK,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;QAChC,KAAK,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAClC,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;SACD,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;QACf,MAAM,YAAY,GAAG,IAAI,KAAK,CAAC,yCAAyC,YAAY,EAAE,EAAE;YACtF,KAAK,EAAE,KAAK;SACb,CAAC,CAAC;QACH,KAAK,CAAC,QAAQ,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;QAC3C,KAAK,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAClC,MAAM,YAAY,CAAC;IACrB,CAAC,CAAC,CAAC;IAEL,KAAK,CAAC,UAAU,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;IACxC,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["/**\n * Copyright Â© 2026 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { LoaderCache } from './LoaderCache';\n\ntype LoaderFetcher<T> = (path: string) => Promise<T>;\n\nexport function getLoaderData<T>({\n  resolvedPath,\n  cache,\n  fetcher,\n}: {\n  resolvedPath: string;\n  cache: LoaderCache;\n  fetcher: LoaderFetcher<T>;\n}): T | Promise<T> {\n  // Check error cache first to prevent infinite retry loops when a loader fails.\n  // We throw the cached error instead of starting a new fetch\n  const cachedError = cache.getError(resolvedPath);\n  if (cachedError) {\n    throw cachedError;\n  }\n\n  // Check cache for route data\n  if (cache.hasData(resolvedPath)) {\n    return cache.getData<T>(resolvedPath) as T;\n  }\n\n  // Fetch data if not cached\n  const cachedPromise = cache.getPromise<T>(resolvedPath);\n  if (cachedPromise) {\n    return cachedPromise;\n  }\n\n  const promise = fetcher(resolvedPath)\n    .then((data) => {\n      cache.setData(resolvedPath, data);\n      cache.deleteError(resolvedPath);\n      cache.deletePromise(resolvedPath);\n      return data;\n    })\n    .catch((error) => {\n      const wrappedError = new Error(`Failed to load loader data for route: ${resolvedPath}`, {\n        cause: error,\n      });\n      cache.setError(resolvedPath, wrappedError);\n      cache.deletePromise(resolvedPath);\n      throw wrappedError;\n    });\n\n  cache.setPromise(resolvedPath, promise);\n  return promise;\n}\n"]}