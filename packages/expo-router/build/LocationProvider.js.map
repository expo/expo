{"version":3,"file":"LocationProvider.js","sourceRoot":"","sources":["../src/LocationProvider.tsx"],"names":[],"mappings":";;;AAWA,SAAgB,qBAAqB,CACnC,gBAAkF,EAClF,KAAY;IAEZ,MAAM,EAAE,IAAI,EAAE,GAAG,gBAAgB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAChD,MAAM,SAAS,GAAG,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IAChD,OAAO;QACL,kEAAkE;QAClE,mBAAmB,EAAE,IAAI;QACzB,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;QAC9B,GAAG,sBAAsB,CAAC,SAAS,CAAC;KACrC,CAAC;AACJ,CAAC;AAZD,sDAYC;AAED,mEAAmE;AACnE,SAAgB,sBAAsB,CAAC,EACrC,IAAI,EAAE,SAAS,EACf,MAAM,GAIP;IACC,MAAM,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACxC,OAAO;QACL,gCAAgC;QAChC,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,kBAAkB,CAAC;QACrE,6EAA6E;QAC7E,8CAA8C;QAC9C,MAAM,EAAE,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;YAC3D,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACxB,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;aAC3C;iBAAM;gBACL,IAAI,CAAC,GAAG,CAAC,GAAG,kBAAkB,CAAC,KAAe,CAAC,CAAC;aACjD;YACD,OAAO,IAAI,CAAC;QACd,CAAC,EAAE,EAAkB,CAAC;KACvB,CAAC;AACJ,CAAC;AAtBD,wDAsBC","sourcesContent":["import type { State } from './fork/getPathFromState';\n\ntype SearchParams = Record<string, string | string[]>;\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: SearchParams;\n  segments: string[];\n};\n\nexport function getRouteInfoFromState(\n  getPathFromState: (state: State, asPath: boolean) => { path: string; params: any },\n  state: State\n): UrlObject {\n  const { path } = getPathFromState(state, false);\n  const qualified = getPathFromState(state, true);\n  return {\n    // TODO: This may have a predefined origin attached in the future.\n    unstable_globalHref: path,\n    pathname: path.split('?')['0'],\n    ...getNormalizedStatePath(qualified),\n  };\n}\n\n// TODO: Split up getPathFromState to return all this info at once.\nexport function getNormalizedStatePath({\n  path: statePath,\n  params,\n}: {\n  path: string;\n  params: any;\n}): Pick<UrlObject, 'segments' | 'params'> {\n  const [pathname] = statePath.split('?');\n  return {\n    // Strip empty path at the start\n    segments: pathname.split('/').filter(Boolean).map(decodeURIComponent),\n    // TODO: This is not efficient, we should generate based on the state instead\n    // of converting to string then back to object\n    params: Object.entries(params).reduce((prev, [key, value]) => {\n      if (Array.isArray(value)) {\n        prev[key] = value.map(decodeURIComponent);\n      } else {\n        prev[key] = decodeURIComponent(value as string);\n      }\n      return prev;\n    }, {} as SearchParams),\n  };\n}\n"]}