{"version":3,"file":"getServerManifest.js","sourceRoot":"","sources":["../src/getServerManifest.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright © 2023 650 Industries.\n * Copyright © 2023 Vercel, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Based on https://github.com/vercel/next.js/blob/1df2686bc9964f1a86c444701fa5cbf178669833/packages/next/src/shared/lib/router/utils/route-regex.ts\n */\nimport type { RouteNode } from './Route';\nimport { getContextKey } from './matchers';\nimport { sortRoutes } from './sortRoutes';\n\n// TODO: Share these types across cli, server, router, etc.\nexport type ExpoRouterServerManifestV1Route<TRegex = string> = {\n  file: string;\n  page: string;\n  routeKeys: Record<string, string>;\n  namedRegex: TRegex;\n  generated?: boolean;\n};\n\nexport type ExpoRouterServerManifestV1<TRegex = string> = {\n  apiRoutes: ExpoRouterServerManifestV1Route<TRegex>[];\n  htmlRoutes: ExpoRouterServerManifestV1Route<TRegex>[];\n  notFoundRoutes: ExpoRouterServerManifestV1Route<TRegex>[];\n};\n\nexport interface Group {\n  pos: number;\n  repeat: boolean;\n  optional: boolean;\n}\n\nexport interface RouteRegex {\n  groups: { [groupName: string]: Group };\n  re: RegExp;\n}\n\nfunction isApiRoute(route: RouteNode) {\n  return !route.children.length && !!route.contextKey.match(/\\+api\\.[jt]sx?$/);\n}\n\nfunction isNotFoundRoute(route: RouteNode) {\n  return route.dynamic && route.dynamic[route.dynamic.length - 1].notFound;\n}\n\n// Given a nested route tree, return a flattened array of all routes that can be matched.\nexport function getServerManifest(route: RouteNode): ExpoRouterServerManifestV1 {\n  function getFlatNodes(route: RouteNode): [string, RouteNode][] {\n    if (route.children.length) {\n      return route.children.map((child) => getFlatNodes(child)).flat();\n    }\n\n    const key = getContextKey(route.contextKey).replace(/\\/index$/, '') ?? '/';\n    return [[key, route]];\n  }\n\n  const flat = getFlatNodes(route)\n    .sort(([, a], [, b]) => sortRoutes(b, a))\n    .reverse();\n\n  const apiRoutes = flat.filter(([, route]) => isApiRoute(route));\n  const otherRoutes = flat.filter(([, route]) => !isApiRoute(route));\n  const standardRoutes = otherRoutes.filter(([, route]) => !isNotFoundRoute(route));\n  const notFoundRoutes = otherRoutes.filter(([, route]) => isNotFoundRoute(route));\n\n  return {\n    apiRoutes: getMatchableManifestForPaths(\n      apiRoutes.map(([normalizedRoutePath, node]) => [normalizedRoutePath, node])\n    ),\n    htmlRoutes: getMatchableManifestForPaths(\n      standardRoutes.map(([normalizedRoutePath, node]) => [normalizedRoutePath, node])\n    ),\n    notFoundRoutes: getMatchableManifestForPaths(\n      notFoundRoutes.map(([normalizedRoutePath, node]) => [normalizedRoutePath, node])\n    ),\n  };\n}\n\nfunction getMatchableManifestForPaths(\n  paths: [string, RouteNode][]\n): ExpoRouterServerManifestV1Route[] {\n  return paths.map((normalizedRoutePath) => ({\n    ...getNamedRouteRegex(normalizedRoutePath[0], normalizedRoutePath[1].contextKey),\n    generated: normalizedRoutePath[1].generated,\n  }));\n}\n\nexport function getNamedRouteRegex(\n  normalizedRoute: string,\n  page: string\n): ExpoRouterServerManifestV1Route {\n  const result = getNamedParametrizedRoute(normalizedRoute);\n  return {\n    file: page,\n    page: page.replace(/\\.[jt]sx?$/, ''),\n    namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`,\n    routeKeys: result.routeKeys,\n  };\n}\n\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let currentCharCode = 96; // Starting one before 'a' to make the increment logic simpler\n  let currentLength = 1;\n\n  return () => {\n    let result = '';\n    let incrementNext = true;\n\n    // Iterate from right to left to build the key\n    for (let i = 0; i < currentLength; i++) {\n      if (incrementNext) {\n        currentCharCode++;\n        if (currentCharCode > 122) {\n          currentCharCode = 97; // Reset to 'a'\n          incrementNext = true; // Continue to increment the next character\n        } else {\n          incrementNext = false;\n        }\n      }\n      result = String.fromCharCode(currentCharCode) + result;\n    }\n\n    // If all characters are 'z', increase the length of the key\n    if (incrementNext) {\n      currentLength++;\n      currentCharCode = 96; // This will make the next key start with 'a'\n    }\n\n    return result;\n  };\n}\n\nfunction removeTrailingSlash(route: string): string {\n  return route.replace(/\\/$/, '') || '/';\n}\n\nfunction getNamedParametrizedRoute(route: string) {\n  const segments = removeTrailingSlash(route).slice(1).split('/');\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys: { [named: string]: string } = {};\n  return {\n    namedParameterizedRoute: segments\n      .map((segment, index) => {\n        if (segment === '+not-found' && index === segments.length - 1) {\n          segment = '[...not-found]';\n        }\n        if (/^\\[.*\\]$/.test(segment)) {\n          const { name, optional, repeat } = parseParameter(segment.slice(1, -1));\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = name.replace(/\\W/g, '');\n          let invalidKey = false;\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true;\n          }\n          if (!isNaN(parseInt(cleanedKey.slice(0, 1), 10))) {\n            invalidKey = true;\n          }\n\n          // Prevent duplicates after sanitizing the key\n          if (cleanedKey in routeKeys) {\n            invalidKey = true;\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey();\n          }\n\n          routeKeys[cleanedKey] = name;\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`;\n        } else if (/^\\(.*\\)$/.test(segment)) {\n          // Make section optional\n          return `(?:/${escapeStringRegexp(segment)})?`;\n        } else {\n          return `/${escapeStringRegexp(segment)}`;\n        }\n      })\n      .join(''),\n    routeKeys,\n  };\n}\n\n// regexp is based on https://github.com/sindresorhus/escape-string-regexp\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\n\nfunction escapeStringRegexp(str: string) {\n  // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n  if (reHasRegExp.test(str)) {\n    return str.replace(reReplaceRegExp, '\\\\$&');\n  }\n  return str;\n}\n\nfunction parseParameter(param: string) {\n  let repeat = false;\n  let optional = false;\n  let name = param;\n\n  if (/^\\[.*\\]$/.test(name)) {\n    optional = true;\n    name = name.slice(1, -1);\n  }\n\n  if (/^\\.\\.\\./.test(name)) {\n    repeat = true;\n    name = name.slice(3);\n  }\n\n  return { name, repeat, optional };\n}\n"]}