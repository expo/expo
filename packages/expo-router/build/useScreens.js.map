{"version":3,"file":"useScreens.js","sourceRoot":"","sources":["../src/useScreens.tsx"],"names":[],"mappings":"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","sourcesContent":["import type {\n  EventMapBase,\n  NavigationState,\n  ParamListBase,\n  RouteProp,\n  ScreenListeners,\n} from '@react-navigation/native';\nimport React from 'react';\n\nimport {\n  DynamicConvention,\n  LoadedRoute,\n  Route,\n  RouteNode,\n  sortRoutesWithInitial,\n  useRouteNode,\n} from './Route';\nimport EXPO_ROUTER_IMPORT_MODE from './import-mode';\nimport { Screen } from './primitives';\nimport { EmptyRoute } from './views/EmptyRoute';\nimport { SuspenseFallback } from './views/SuspenseFallback';\nimport { Try } from './views/Try';\n\nexport type ScreenProps<\n  TOptions extends Record<string, any> = Record<string, any>,\n  State extends NavigationState = NavigationState,\n  EventMap extends EventMapBase = EventMapBase,\n> = {\n  /** Name is required when used inside a Layout component. */\n  name?: string;\n  /**\n   * Redirect to the nearest sibling route.\n   * If all children are redirect={true}, the layout will render `null` as there are no children to render.\n   */\n  redirect?: boolean;\n  initialParams?: { [key: string]: any };\n  options?: TOptions;\n\n  listeners?:\n    | ScreenListeners<State, EventMap>\n    | ((prop: {\n        route: RouteProp<ParamListBase, string>;\n        navigation: any;\n      }) => ScreenListeners<State, EventMap>);\n\n  getId?: ({ params }: { params?: Record<string, any> | undefined }) => string | undefined;\n};\n\nfunction getSortedChildren(\n  children: RouteNode[],\n  order?: ScreenProps[],\n  initialRouteName?: string\n): { route: RouteNode; props: Partial<ScreenProps> }[] {\n  if (!order?.length) {\n    return children\n      .sort(sortRoutesWithInitial(initialRouteName))\n      .map((route) => ({ route, props: {} }));\n  }\n  const entries = [...children];\n\n  const ordered = order\n    .map(({ name, redirect, initialParams, listeners, options, getId }) => {\n      if (!entries.length) {\n        console.warn(`[Layout children]: Too many screens defined. Route \"${name}\" is extraneous.`);\n        return null;\n      }\n      const matchIndex = entries.findIndex((child) => child.route === name);\n      if (matchIndex === -1) {\n        console.warn(\n          `[Layout children]: No route named \"${name}\" exists in nested children:`,\n          children.map(({ route }) => route)\n        );\n        return null;\n      } else {\n        // Get match and remove from entries\n        const match = entries[matchIndex];\n        entries.splice(matchIndex, 1);\n\n        // Ensure to return null after removing from entries.\n        if (redirect) {\n          if (typeof redirect === 'string') {\n            throw new Error(`Redirecting to a specific route is not supported yet.`);\n          }\n          return null;\n        }\n\n        return {\n          route: match,\n          props: { initialParams, listeners, options, getId },\n        };\n      }\n    })\n    .filter(Boolean) as {\n    route: RouteNode;\n    props: Partial<ScreenProps>;\n  }[];\n\n  // Add any remaining children\n  ordered.push(\n    ...entries.sort(sortRoutesWithInitial(initialRouteName)).map((route) => ({ route, props: {} }))\n  );\n\n  return ordered;\n}\n\n/**\n * @returns React Navigation screens sorted by the `route` property.\n */\nexport function useSortedScreens(order: ScreenProps[]): React.ReactNode[] {\n  const node = useRouteNode();\n\n  const sorted = node?.children?.length\n    ? getSortedChildren(node.children, order, node.initialRouteName)\n    : [];\n  return React.useMemo(\n    () => sorted.map((value) => routeToScreen(value.route, value.props)),\n    [sorted]\n  );\n}\n\nfunction fromImport({ ErrorBoundary, ...component }: LoadedRoute) {\n  if (ErrorBoundary) {\n    return {\n      default: React.forwardRef((props: any, ref: any) => {\n        const children = React.createElement(component.default || EmptyRoute, {\n          ...props,\n          ref,\n        });\n        return <Try catch={ErrorBoundary}>{children}</Try>;\n      }),\n    };\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (\n      typeof component.default === 'object' &&\n      component.default &&\n      Object.keys(component.default).length === 0\n    ) {\n      return { default: EmptyRoute };\n    }\n  }\n  return { default: component.default || EmptyRoute };\n}\n\nfunction fromLoadedRoute(res: LoadedRoute) {\n  if (!(res instanceof Promise)) {\n    return fromImport(res);\n  }\n\n  return res.then(fromImport);\n}\n\n// TODO: Maybe there's a more React-y way to do this?\n// Without this store, the process enters a recursive loop.\nconst qualifiedStore = new WeakMap<RouteNode, React.ComponentType<any>>();\n\n/** Wrap the component with various enhancements and add access to child routes. */\nexport function getQualifiedRouteComponent(value: RouteNode) {\n  if (qualifiedStore.has(value)) {\n    return qualifiedStore.get(value)!;\n  }\n\n  let getLoadable: (props: any, ref: any) => JSX.Element;\n\n  // TODO: This ensures sync doesn't use React.lazy, but it's not ideal.\n  if (EXPO_ROUTER_IMPORT_MODE === 'lazy') {\n    const AsyncComponent = React.lazy(async () => {\n      const res = value.loadRoute();\n      return fromLoadedRoute(res) as Promise<{\n        default: React.ComponentType<any>;\n      }>;\n    });\n    getLoadable = (props: any, ref: any) => (\n      <React.Suspense fallback={<SuspenseFallback route={value} />}>\n        <AsyncComponent\n          {...{\n            ...props,\n            ref,\n            // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`\n            // the intention is to make it possible to deduce shared routes.\n            segment: value.route,\n          }}\n        />\n      </React.Suspense>\n    );\n  } else {\n    const res = value.loadRoute();\n    const Component = fromImport(res).default;\n    const SyncComponent = React.forwardRef((props, ref) => {\n      return <Component {...props} ref={ref} />;\n    });\n\n    getLoadable = (props: any, ref: any) => (\n      <SyncComponent\n        {...{\n          ...props,\n          ref,\n          // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`\n          // the intention is to make it possible to deduce shared routes.\n          segment: value.route,\n        }}\n      />\n    );\n  }\n\n  const QualifiedRoute = React.forwardRef(\n    (\n      {\n        // Remove these React Navigation props to\n        // enforce usage of expo-router hooks (where the query params are correct).\n        route,\n        navigation,\n\n        // Pass all other props to the component\n        ...props\n      }: any,\n      ref: any\n    ) => {\n      const loadable = getLoadable(props, ref);\n\n      return <Route node={value}>{loadable}</Route>;\n    }\n  );\n\n  QualifiedRoute.displayName = `Route(${value.route})`;\n\n  qualifiedStore.set(value, QualifiedRoute);\n  return QualifiedRoute;\n}\n\n/** @returns a function which provides a screen id that matches the dynamic route name in params. */\nexport function createGetIdForRoute(route: Pick<RouteNode, 'dynamic' | 'route'>) {\n  if (!route.dynamic?.length) {\n    return undefined;\n  }\n  return ({ params }: { params?: Record<string, any> }) => {\n    const getPreferredId = (segment: DynamicConvention) => {\n      // Params can be undefined when there are no params in the route.\n      const preferredId = params?.[segment.name];\n      // If the route has a dynamic segment, use the matching parameter\n      // as the screen id. This enables pushing a screen like `/[user]` multiple times\n      // when the user is different.\n      if (preferredId) {\n        if (!Array.isArray(preferredId)) {\n          return preferredId;\n        } else if (preferredId.length) {\n          // Deep dynamic routes will return as an array, so we'll join them to create a\n          // fully qualified string.\n          return preferredId.join('/');\n        }\n        // Empty arrays...\n      }\n      return segment.deep ? `[...${segment.name}]` : `[${segment.name}]`;\n    };\n    return route.dynamic?.map((segment) => getPreferredId(segment)).join('/');\n  };\n}\n\nfunction routeToScreen(route: RouteNode, { options, ...props }: Partial<ScreenProps> = {}) {\n  return (\n    <Screen\n      // Users can override the screen getId function.\n      getId={createGetIdForRoute(route)}\n      {...props}\n      name={route.route}\n      key={route.route}\n      options={(args) => {\n        // Only eager load generated components\n        const staticOptions = route.generated ? route.loadRoute()?.getNavOptions : null;\n        const staticResult =\n          typeof staticOptions === 'function' ? staticOptions(args) : staticOptions;\n        const dynamicResult = typeof options === 'function' ? options?.(args) : options;\n        const output = {\n          ...staticResult,\n          ...dynamicResult,\n        };\n\n        // Prevent generated screens from showing up in the tab bar.\n        if (route.generated) {\n          output.tabBarButton = () => null;\n          // TODO: React Navigation doesn't provide a way to prevent rendering the drawer item.\n          output.drawerItemStyle = { height: 0, display: 'none' };\n        }\n\n        return output;\n      }}\n      getComponent={() => getQualifiedRouteComponent(route)}\n    />\n  );\n}\n"]}