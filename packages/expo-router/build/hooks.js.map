{"version":3,"file":"hooks.js","sourceRoot":"","sources":["../src/hooks.ts"],"names":[],"mappings":"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","sourcesContent":["import React from 'react';\n\nimport { LocalRouteParamsContext } from './Route';\nimport { store, useStoreRootState, useStoreRouteInfo } from './global-state/router-store';\nimport { Router } from './imperative-api';\nimport { RouteParams, RouteSegments, Routes, UnknownOutputParams } from './types';\n\ntype SearchParams = Record<string, string | string[]>;\nexport function useRootNavigationState() {\n  return useStoreRootState();\n}\n\nexport function useRouteInfo() {\n  return useStoreRouteInfo();\n}\n\n/** @deprecated use `useNavigationContainerRef()` instead, which returns a React ref. */\nexport function useRootNavigation() {\n  return store.navigationRef.current;\n}\n\n/** @return the root `<NavigationContainer />` ref for the app. The `ref.current` may be `null` if the `<NavigationContainer />` hasn't mounted yet. */\nexport function useNavigationContainerRef() {\n  return store.navigationRef;\n}\n\nexport function useRouter(): Router {\n  return React.useMemo(\n    () => ({\n      push: store.push,\n      dismiss: store.dismiss,\n      dismissAll: store.dismissAll,\n      canDismiss: store.canDismiss,\n      back: store.goBack,\n      replace: store.replace,\n      setParams: store.setParams,\n      canGoBack: store.canGoBack,\n      navigate: store.navigate,\n      // TODO(EvanBacon): add `reload`\n    }),\n    []\n  );\n}\n\n/**\n * @private\n * @returns the current global pathname with query params attached. This may change in the future to include the hostname from a predefined universal link, i.e. `/foobar?hey=world` becomes `https://acme.dev/foobar?hey=world`\n */\nexport function useUnstableGlobalHref(): string {\n  return useStoreRouteInfo().unstable_globalHref;\n}\n\n/**\n * Get a list of selected file segments for the currently selected route. Segments are not normalized, so they will be the same as the file path. e.g. /[id]?id=normal -> [\"[id]\"]\n *\n * `useSegments` can be typed using an abstract.\n * Consider the following file structure, and strictly typed `useSegments` function:\n *\n * ```md\n * - app\n *   - [user]\n *     - index.js\n *     - followers.js\n *   - settings.js\n * ```\n * This can be strictly typed using the following abstract:\n *\n * ```ts\n * const [first, second] = useSegments<['settings'] | ['[user]'] | ['[user]', 'followers']>()\n * ```\n */\nexport function useSegments<\n  TSegments extends Routes | RouteSegments<Routes> = Routes,\n>(): TSegments extends string ? RouteSegments<TSegments> : TSegments {\n  return useStoreRouteInfo().segments as TSegments extends string\n    ? RouteSegments<TSegments>\n    : TSegments;\n}\n\n/** @returns global selected pathname without query parameters. */\nexport function usePathname(): string {\n  return useStoreRouteInfo().pathname;\n}\n\n/**\n * Get the globally selected query parameters, including dynamic path segments. This function will update even when the route is not focused.\n * Useful for analytics or other background operations that don't draw to the screen.\n *\n * When querying search params in a stack, opt-towards using `useLocalSearchParams` as these will only\n * update when the route is focused.\n *\n * @see `useLocalSearchParams`\n */\nexport function useGlobalSearchParams<\n  TParams extends SearchParams = UnknownOutputParams,\n>(): RouteParams<TParams>;\nexport function useGlobalSearchParams<\n  TRoute extends Routes,\n  TParams extends SearchParams = UnknownOutputParams,\n>(): RouteParams<TRoute, TParams>;\nexport function useGlobalSearchParams<\n  TParams1 extends SearchParams | Routes = UnknownOutputParams,\n  TParams2 extends SearchParams = UnknownOutputParams,\n>(): RouteParams<TParams1, TParams2> {\n  return useStoreRouteInfo().params as RouteParams<TParams1, TParams2>;\n}\n\n/**\n * Returns the URL parameters for the contextually focused route. e.g. `/acme?foo=bar` -> `{ foo: \"bar\" }`.\n * This is useful for stacks where you may push a new screen that changes the query parameters.\n * For dynamic routes, both the route parameters and the search parameters are returned.\n *\n * To observe updates even when the invoking route is not focused, use `useGlobalSearchParams()`.\n *\n * @see `useGlobalSearchParams`\n */\nexport function useLocalSearchParams<\n  TParams extends SearchParams = UnknownOutputParams,\n>(): RouteParams<TParams>;\nexport function useLocalSearchParams<\n  TRoute extends Routes,\n  TParams extends SearchParams = UnknownOutputParams,\n>(): RouteParams<TRoute, TParams>;\nexport function useLocalSearchParams<\n  TParams1 extends SearchParams | Routes = UnknownOutputParams,\n  TParams2 extends SearchParams = UnknownOutputParams,\n>(): RouteParams<TParams1, TParams2> {\n  const params = React.useContext(LocalRouteParamsContext) ?? {};\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value]) => {\n      if (Array.isArray(value)) {\n        return [\n          key,\n          value.map((v) => {\n            try {\n              return decodeURIComponent(v);\n            } catch {\n              return v;\n            }\n          }),\n        ];\n      } else {\n        try {\n          return [key, decodeURIComponent(value as string)];\n        } catch {\n          return [key, value];\n        }\n      }\n    })\n  ) as RouteParams<TParams1, TParams2>;\n}\n\nexport function useSearchParams({ global = false } = {}): URLSearchParams {\n  const globalRef = React.useRef(global);\n  if (process.env.NODE_ENV !== 'production') {\n    if (global !== globalRef.current) {\n      console.warn(\n        `Detected change in 'global' option of useSearchParams. This value cannot change between renders`\n      );\n    }\n  }\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const params = global ? useGlobalSearchParams() : useLocalSearchParams();\n  const entries = Object.entries(params).flatMap(([key, value]) => {\n    if (global) {\n      if (key === 'params') return [];\n      if (key === 'screen') return [];\n    }\n\n    return Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]];\n  });\n\n  return new ReadOnlyURLSearchParams(entries);\n}\n\nclass ReadOnlyURLSearchParams extends URLSearchParams {\n  set() {\n    throw new Error('The URLSearchParams object return from useSearchParams is read-only');\n  }\n  append() {\n    throw new Error('The URLSearchParams object return from useSearchParams is read-only');\n  }\n  delete() {\n    throw new Error('The URLSearchParams object return from useSearchParams is read-only');\n  }\n}\n"]}