{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/typed-routes/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { EXPO_ROUTER_CTX_IGNORE } from 'expo-router/_ctx-shared';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nimport { getTypedRoutesDeclarationFile } from './generate';\nimport { isTypedRoute } from '../matchers';\nimport requireContext, {\n  RequireContextPonyFill,\n} from '../testing-library/require-context-ponyfill';\n\nconst defaultCtx = requireContext(process.env.EXPO_ROUTER_APP_ROOT, true, EXPO_ROUTER_CTX_IGNORE);\n\nexport type { RequireContextPonyFill } from '../testing-library/require-context-ponyfill';\n\n/**\n * Generate a Metro watch handler that regenerates the typed routes declaration file\n */\nexport function getWatchHandler(\n  outputDir: string,\n  { ctx = defaultCtx, regenerateFn = regenerateDeclarations } = {} // Exposed for testing\n) {\n  const routeFiles = new Set(ctx.keys().filter((key) => isTypedRoute(key)));\n\n  return async function callback({ filePath, type }: { filePath: string; type: string }) {\n    // Sanity check that we are in an Expo Router project\n    if (!process.env.EXPO_ROUTER_APP_ROOT) return;\n\n    let shouldRegenerate = false;\n    let relativePath = path.relative(process.env.EXPO_ROUTER_APP_ROOT, filePath);\n    const isInsideAppRoot = !relativePath.startsWith('../');\n    const basename = path.basename(relativePath);\n\n    if (!isInsideAppRoot) return;\n\n    // require.context paths always start with './' when relative to the root\n    relativePath = `./${relativePath}`;\n\n    if (type === 'delete') {\n      ctx.__delete(relativePath);\n      if (routeFiles.has(relativePath)) {\n        routeFiles.delete(relativePath);\n        shouldRegenerate = true;\n      }\n    } else if (type === 'add') {\n      ctx.__add(relativePath);\n      if (isTypedRoute(basename)) {\n        routeFiles.add(relativePath);\n        shouldRegenerate = true;\n      }\n    } else {\n      shouldRegenerate = routeFiles.has(relativePath);\n    }\n\n    if (shouldRegenerate) {\n      regenerateFn(outputDir, ctx);\n    }\n  };\n}\n\n/**\n * Regenerate the declaration file.\n *\n * This function needs to be debounced due to Metro's handling of renaming folders.\n * For example, if you have the file /(tabs)/route.tsx and you rename the folder to /(tabs,test)/route.tsx\n *\n * Metro will fire 2 filesystem events:\n *  - ADD /(tabs,test)/router.tsx\n *  - DELETE /(tabs)/router.tsx\n *\n * If you process the types after the ADD, then they will crash as you will have conflicting routes\n */\nexport const regenerateDeclarations = debounce(\n  (outputDir: string, ctx: RequireContextPonyFill = defaultCtx) => {\n    // Don't crash the process, just log the error. The user will most likely fix it and continue\n    try {\n      const file = getTypedRoutesDeclarationFile(ctx);\n      if (!file) return;\n      fs.writeFileSync(path.resolve(outputDir, './router.d.ts'), file);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n);\n\n/**\n * Debounce a function to only run once after a period of inactivity\n * If called while waiting, it will reset the timer\n */\nfunction debounce<T extends (...args: any[]) => any>(fn: T, timeout: number = 1000) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn(...args);\n    }, timeout);\n  };\n}\n"]}