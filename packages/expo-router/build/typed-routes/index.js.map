{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/typed-routes/index.ts"],"names":[],"mappings":";;;;;;AAAA,sDAAyB;AACzB,0DAA6B;AAE7B,yCAA2D;AAC3D,mDAA2D;AAC3D,0CAA2C;AAC3C,2GAAyE;AAEzE,MAAM,GAAG,GAAG,IAAA,kCAAc,EAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,IAAI,EAAE,oCAAsB,CAAC,CAAC;AAE3F;;GAEG;AACH,SAAgB,eAAe,CAAC,SAAiB;IAC/C,MAAM,UAAU,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAA,uBAAY,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAE1E,OAAO,KAAK,UAAU,QAAQ,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAsC;QACnF,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAE7B,IAAI,IAAI,KAAK,QAAQ,EAAE;YACrB,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;YACvB,IAAI,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;gBAC5B,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAC5B,gBAAgB,GAAG,IAAI,CAAC;aACzB;SACF;aAAM,IAAI,IAAI,KAAK,KAAK,EAAE;YACzB,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YACpB,gBAAgB,GAAG,IAAA,uBAAY,EAAC,QAAQ,CAAC,CAAC;SAC3C;aAAM;YACL,gBAAgB,GAAG,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;SAC7C;QAED,IAAI,gBAAgB,EAAE;YACpB,IAAA,8BAAsB,EAAC,SAAS,CAAC,CAAC;SACnC;IACH,CAAC,CAAC;AACJ,CAAC;AAvBD,0CAuBC;AAED;;GAEG;AACU,QAAA,sBAAsB,GAAG,QAAQ,CAAC,CAAC,SAAiB,EAAE,EAAE;IACnE,MAAM,IAAI,GAAG,IAAA,wCAA6B,EAAC,GAAG,CAAC,CAAC;IAChD,IAAI,CAAC,IAAI;QAAE,OAAO;IAClB,iBAAE,CAAC,aAAa,CAAC,mBAAI,CAAC,OAAO,CAAC,SAAS,EAAE,eAAe,CAAC,EAAE,IAAI,CAAC,CAAC;AACnE,CAAC,EAAE,GAAG,CAAC,CAAC;AAER;;;GAGG;AACH,SAAS,QAAQ,CAAoC,EAAK,EAAE,QAAgB;IAC1E,IAAI,OAAO,CAAC;IACZ,IAAI,cAAc,GAAG,KAAK,CAAC;IAC3B,OAAO,SAAS,GAAG,CAAC,GAAG,IAAmB;QACxC,IAAI,OAAO,EAAE;YACX,cAAc,GAAG,IAAI,CAAC;SACvB;aAAM;YACL,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YACZ,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;gBACxB,OAAO,GAAG,IAAI,CAAC,CAAC,gDAAgD;gBAChE,IAAI,cAAc,EAAE;oBAClB,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,0BAA0B;iBACzC;YACH,CAAC,EAAE,QAAQ,CAAC,CAAC;SACd;IACH,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import fs from 'node:fs';\nimport path from 'node:path';\n\nimport { getTypedRoutesDeclarationFile } from './generate';\nimport { EXPO_ROUTER_CTX_IGNORE } from '../../_ctx-shared';\nimport { isTypedRoute } from '../matchers';\nimport requireContext from '../testing-library/require-context-ponyfill';\n\nconst ctx = requireContext(process.env.EXPO_ROUTER_APP_ROOT, true, EXPO_ROUTER_CTX_IGNORE);\n\n/**\n * Generate a Metro watch handler that regenerates the typed routes declaration file\n */\nexport function getWatchHandler(outputDir: string) {\n  const routeFiles = new Set(ctx.keys().filter((key) => isTypedRoute(key)));\n\n  return async function callback({ filePath, type }: { filePath: string; type: string }) {\n    let shouldRegenerate = false;\n\n    if (type === 'delete') {\n      ctx.__delete(filePath);\n      if (routeFiles.has(filePath)) {\n        routeFiles.delete(filePath);\n        shouldRegenerate = true;\n      }\n    } else if (type === 'add') {\n      ctx.__add(filePath);\n      shouldRegenerate = isTypedRoute(filePath);\n    } else {\n      shouldRegenerate = routeFiles.has(filePath);\n    }\n\n    if (shouldRegenerate) {\n      regenerateDeclarations(outputDir);\n    }\n  };\n}\n\n/**\n * A throttled function that regenerates the typed routes declaration file\n */\nexport const regenerateDeclarations = throttle((outputDir: string) => {\n  const file = getTypedRoutesDeclarationFile(ctx);\n  if (!file) return;\n  fs.writeFileSync(path.resolve(outputDir, './router.d.ts'), file);\n}, 100);\n\n/**\n * Throttles a function to only run once every `internal` milliseconds.\n * If called while waiting, it will run again after the timer has elapsed.\n */\nfunction throttle<T extends (...args: any[]) => any>(fn: T, interval: number) {\n  let timerId;\n  let shouldRunAgain = false;\n  return function run(...args: Parameters<T>) {\n    if (timerId) {\n      shouldRunAgain = true;\n    } else {\n      fn(...args);\n      timerId = setTimeout(() => {\n        timerId = null; // reset the timer so next call will be executed\n        if (shouldRunAgain) {\n          run(...args); // call the function again\n        }\n      }, interval);\n    }\n  };\n}\n"]}