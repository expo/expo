{"version":3,"file":"generate.js","sourceRoot":"","sources":["../../src/typed-routes/generate.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'node:fs';\nimport path from 'path';\n\nimport { RouteNode } from '../Route';\nimport { getRoutes } from '../getRoutes';\nimport { isTypedRoute, removeSupportedExtensions } from '../matchers';\nimport { RequireContext } from '../types';\n\n// /[...param1]/ - Match [...param1]\nconst CATCH_ALL = /\\[\\.\\.\\..+?\\]/g;\n// /[param1] - Match [param1]\nconst SLUG = /\\[.+?\\]/g;\n\nexport function getTypedRoutesDeclarationFile(ctx: RequireContext) {\n  const staticRoutes = new Set<string>();\n  const dynamicRoutes = new Set<string>();\n  const dynamicRouteContextKeys = new Set<string>();\n\n  walkRouteNode(\n    getRoutes(ctx, {\n      platformRoutes: false, // We don't need to generate platform specific routes\n      ignoreEntryPoints: true,\n      ignoreRequireErrors: true,\n      importMode: 'async',\n    }),\n    staticRoutes,\n    dynamicRoutes,\n    dynamicRouteContextKeys\n  );\n\n  // If the user has expo-router v3+ installed, we can use the types from the package\n  return (\n    fs\n      .readFileSync(path.join(__dirname, '../../types/expo-router.d.ts'), 'utf-8')\n      // Swap from being a namespace to a module\n      .replace('declare namespace ExpoRouter {', `declare module \"expo-router\" {`)\n      // Add the route values\n      .replace(\n        'type StaticRoutes = string;',\n        `type StaticRoutes = ${setToUnionType(staticRoutes)};`\n      )\n      .replace(\n        'type DynamicRoutes<T extends string> = string;',\n        `type DynamicRoutes<T extends string> = ${setToUnionType(dynamicRoutes)};`\n      )\n      .replace(\n        'type DynamicRouteTemplate = never;',\n        `type DynamicRouteTemplate = ${setToUnionType(dynamicRouteContextKeys)};`\n      )\n  );\n}\n\n/**\n * Walks a RouteNode tree and adds the routes to the provided sets\n */\nfunction walkRouteNode(\n  routeNode: RouteNode | null,\n  staticRoutes: Set<string>,\n  dynamicRoutes: Set<string>,\n  dynamicRouteContextKeys: Set<string>\n) {\n  if (!routeNode) return;\n\n  addRouteNode(routeNode, staticRoutes, dynamicRoutes, dynamicRouteContextKeys);\n\n  for (const child of routeNode.children) {\n    walkRouteNode(child, staticRoutes, dynamicRoutes, dynamicRouteContextKeys);\n  }\n}\n\n/**\n * Given a RouteNode, adds the route to the correct sets\n * Modifies the RouteNode.route to be a typed-route string\n */\nfunction addRouteNode(\n  routeNode: RouteNode | null,\n  staticRoutes: Set<string>,\n  dynamicRoutes: Set<string>,\n  dynamicRouteContextKeys: Set<string>\n) {\n  if (!routeNode?.route) return;\n  if (!isTypedRoute(routeNode.route)) return;\n\n  let routePath = `${removeSupportedExtensions(routeNode.route).replace(/\\/?index$/, '')}`; // replace /index with /\n\n  if (!routePath.startsWith('/')) {\n    routePath = `/${routePath}`;\n  }\n\n  if (routeNode.dynamic) {\n    for (const path of generateCombinations(routePath)) {\n      dynamicRouteContextKeys.add(path);\n      dynamicRoutes.add(\n        `${path\n          .replaceAll(CATCH_ALL, '${CatchAllRoutePart<T>}')\n          .replaceAll(SLUG, '${SingleRoutePart<T>}')}`\n      );\n    }\n  } else {\n    for (const combination of generateCombinations(routePath)) {\n      staticRoutes.add(combination);\n    }\n  }\n}\n\n/**\n * Converts a Set to a TypeScript union type\n */\nconst setToUnionType = <T>(set: Set<T>) => {\n  return set.size > 0\n    ? [...set]\n        .sort()\n        .map((s) => `\\`${s}\\``)\n        .join(' | ')\n    : 'never';\n};\n\nfunction generateCombinations(pathname) {\n  const groups = pathname.split('/').filter((part) => part.startsWith('(') && part.endsWith(')'));\n  const combinations: string[] = [];\n\n  function generate(currentIndex, currentPath) {\n    if (currentIndex === groups.length) {\n      combinations.push(currentPath.replace(/\\/{2,}/g, '/'));\n      return;\n    }\n\n    const group = groups[currentIndex];\n    const withoutGroup = currentPath.replace(group, '');\n    generate(currentIndex + 1, withoutGroup);\n    generate(currentIndex + 1, currentPath);\n  }\n\n  generate(0, pathname);\n  return combinations;\n}\n"]}