{"version":3,"file":"generate.js","sourceRoot":"","sources":["../../src/typed-routes/generate.ts"],"names":[],"mappings":"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","sourcesContent":["import { RouteNode } from '../Route';\nimport { getRoutes } from '../getRoutes';\nimport { removeSupportedExtensions } from '../matchers';\nimport { RequireContext } from '../types';\n\n// /[...param1]/ - Match [...param1]\nconst CATCH_ALL = /\\[\\.\\.\\..+?\\]/g;\n// /[param1] - Match [param1]\nconst SLUG = /\\[.+?\\]/g;\n// /(group)/path/(group2)/route - Match [(group), (group2)]\nconst GROUP = /(?:^|\\/)\\(.*?\\)/g;\n\nexport type GetTypedRoutesDeclarationFileOptions = {\n  partialTypedGroups?: boolean;\n  testIgnoreComments?: boolean;\n};\n\nexport function getTypedRoutesDeclarationFile(\n  ctx: RequireContext,\n  {\n    partialTypedGroups = false,\n    testIgnoreComments = false,\n  }: GetTypedRoutesDeclarationFileOptions = {}\n) {\n  let routeNode: RouteNode | null = null;\n\n  try {\n    routeNode = getRoutes(ctx, {\n      ignore: [/_layout\\.[tj]sx?$/], // Skip layout files\n      platformRoutes: false, // We don't need to generate platform specific routes\n      notFound: false, // We don't need +not-found routes either\n      ignoreEntryPoints: true,\n      ignoreRequireErrors: true,\n      importMode: 'async', // Don't load the file\n    });\n  } catch {\n    // Ignore errors from `getRoutes`. This is also called inside the app, which has\n    // a nicer UX for showing error messages\n  }\n\n  const groupedNodes = groupRouteNodes(routeNode);\n  const staticRoutesStrings: string[] = ['Router.RelativePathString', 'Router.ExternalPathString'];\n  const staticRoutesObjects: string[] = [\n    '{ pathname: Router.RelativePathString, params?: Router.UnknownInputParams }',\n    '{ pathname: Router.ExternalPathString, params?: Router.UnknownInputParams }',\n  ];\n\n  for (const type of groupedNodes.static) {\n    staticRoutesStrings.push(\n      contextKeyToType(type + \"${`?${string}` | `#${string}` | ''}\", partialTypedGroups)\n    );\n    staticRoutesObjects.push(\n      `{ pathname: ${contextKeyToType(type, partialTypedGroups)}; params?: Router.UnknownInputParams; }`\n    );\n  }\n\n  const dynamicRouteStrings: string[] = [];\n  const dynamicRouteObjects: string[] = [];\n  const hrefParamsEntries: [string, string][] = [];\n\n  for (const [dynamicRouteTemplate, paramsNames] of groupedNodes.dynamic) {\n    const params = paramsNames\n      .map((param) => {\n        const key = param.startsWith('...') ? param.slice(3) : param;\n        const value = param.startsWith('...') ? '(string | number)[]' : 'string | number';\n        return `${key}: ${value};`;\n      })\n      .join('');\n\n    let paramsString = '';\n    if (params.length) {\n      paramsString = `{ ${params} }`;\n      hrefParamsEntries.push([\n        contextKeyToType(dynamicRouteTemplate, partialTypedGroups),\n        paramsString,\n      ]);\n    }\n\n    dynamicRouteStrings.push(\n      contextKeyToType(\n        dynamicRouteTemplate\n          .replaceAll(CATCH_ALL, '${string}')\n          .replaceAll(SLUG, '${Router.SingleRoutePart<T>}'),\n        partialTypedGroups\n      )\n    );\n\n    dynamicRouteObjects.push(\n      `{ pathname: ${contextKeyToType(dynamicRouteTemplate, partialTypedGroups)}, params: Router.UnknownInputParams & ${paramsString} }`\n    );\n  }\n\n  const href = [\n    ...staticRoutesStrings,\n    ...staticRoutesObjects,\n    ...dynamicRouteStrings,\n    ...dynamicRouteObjects,\n  ].join(' | ');\n\n  const hrefParams = [...staticRoutesObjects, ...dynamicRouteObjects]\n    .join(' | ')\n    .replaceAll('UnknownInputParams', 'UnknownOutputParams');\n\n  const tsExpectError = testIgnoreComments\n    ? '// @ts-ignore-error -- During tests we need to ignore the \"duplicate\" declaration error, as multiple fixture declare types \\n      '\n    : '';\n\n  return `/* eslint-disable */\nimport * as Router from 'expo-router';\n\nexport * from 'expo-router';\n\ndeclare module 'expo-router' {\n  export namespace ExpoRouter {\n    export interface __routes<T extends string | object = string> {\n      ${tsExpectError}hrefParams: ${hrefParams};\n      ${tsExpectError}href: ${href};\n    }\n  }\n}\n`;\n}\n\nfunction groupRouteNodes(\n  routeNode: RouteNode | null,\n  groupedContextKeys = {\n    static: new Set<string>(),\n    dynamic: new Map<string, string[]>(),\n  }\n) {\n  if (!routeNode) {\n    return groupedContextKeys;\n  }\n\n  // Skip non-route files\n  if (routeNode.type !== 'route') {\n    // Except the root layout\n    if (routeNode.route === '') {\n      for (const child of routeNode.children) {\n        groupRouteNodes(child, groupedContextKeys);\n      }\n      return groupedContextKeys;\n    }\n\n    return groupedContextKeys;\n  }\n\n  let routeKey: string;\n\n  if (routeNode.generated) {\n    // Some routes like the root _layout, _sitemap, +not-found are generated.\n    // We cannot use the contextKey, as their context key does not specify a route\n    routeKey = routeNode.route;\n  } else {\n    routeKey = removeSupportedExtensions(routeNode.contextKey)\n      .replace(/\\/index$/, '') // Remove any trailing /index\n      .replace(/^\\./, ''); // Remove any leading .\n  }\n\n  routeKey ||= '/'; // A routeKey may be empty for contextKey '' or './index.js'\n\n  if (!routeKey.startsWith('/')) {\n    // Not all generated files will have the `/` prefix\n    routeKey = `/${routeKey}`;\n  }\n\n  if (routeNode.dynamic) {\n    groupedContextKeys.dynamic.set(\n      routeKey,\n      routeKey\n        .split('/')\n        .filter((segment) => {\n          return segment.startsWith('[') && segment.endsWith(']');\n        })\n        .map((segment) => {\n          return segment.slice(1, -1);\n        })\n    );\n  } else {\n    groupedContextKeys.static.add(routeKey);\n  }\n\n  for (const child of routeNode.children) {\n    groupRouteNodes(child, groupedContextKeys);\n  }\n\n  return groupedContextKeys;\n}\n\nfunction contextKeyToType(contextKey: string, partialTypedGroups: boolean) {\n  // If the route has groups, turn them into template strings\n  const typeWithGroups = contextKey.replaceAll(GROUP, (match) => {\n    const groups = match.slice(2, -1); // Remove the leading ( and the trailing )\n    // When `partialRoutes` is enabled, we always change a group to a template\n    if (groups.length > 1 || partialTypedGroups) {\n      // Ensure each group has the trailing slash\n      const groupsAsType = groups.split(',').map((group) => `'/(${group})'`);\n      // `partialRoutes` allow you to skip a group\n      if (partialTypedGroups) {\n        groupsAsType.push(\"''\");\n      }\n      // Combine together into a union\n      return `\\${${groupsAsType.join(' | ')}}`;\n    } else {\n      return match;\n    }\n  });\n\n  const typeWithoutGroups = contextKey.replaceAll(GROUP, '');\n\n  if (typeWithGroups === typeWithoutGroups) {\n    return `\\`${typeWithGroups}\\``;\n  } else {\n    return `\\`${typeWithGroups}\\` | \\`${typeWithoutGroups}\\``;\n  }\n}\n"]}