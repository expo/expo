{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/typed-routes/types.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * @hidden\n */\ntype HasTypedRoutes = ExpoRouter.__routes extends { StaticRoutes: string } ? true : false;\n\n/**\n * @hidden\n */\nexport type StaticRoutes = ExpoRouter.__routes extends { StaticRoutes: string }\n  ? ExpoRouter.__routes['StaticRoutes']\n  : string;\n\n/**\n * @hidden\n */\nexport type DynamicRoutes<T extends string> =\n  ExpoRouter.__routes<T> extends {\n    DynamicRoutes: any;\n  }\n    ? // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      T extends ExpoRouter.__routes<infer _>['DynamicRoutes']\n      ? T\n      : never\n    : string;\n\n/**\n * @hidden\n */\nexport type DynamicRouteTemplate = ExpoRouter.__routes extends { DynamicRouteTemplate: string }\n  ? ExpoRouter.__routes['DynamicRouteTemplate']\n  : string;\n\n/**\n * The main routing type for Expo Router.\n *\n * @internal\n * @hidden\n */\nexport namespace ExpoRouter {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  export interface __routes<T extends string = string> extends Record<string, unknown> {}\n}\n\n/**\n * @hidden\n */\nexport type Routes = DynamicRouteTemplate | AllUngroupedRoutes<StaticRoutes>;\n\n/**\n * The main routing type for Expo Router. Includes all available routes with strongly typed parameters.\n *\n * A Href can either be a string or an object.\n *\n * Href accepts an optional T parameter to correctly type dynamic routes string.\n *\n * For example: Without the generic the route `/folder/[slug]` will be typed as `/folder/${string}`,\n * which is incorrect as `/folder/apple/orange` would be valid. But by passing desired route as a generic `Href<'/folder/apple'>`,\n * it will validate against this edge case.\n *\n */\nexport type Href<T extends string | object = { __branded__: any }> = GeneratedHref<T>;\n\n/**\n * @hidden\n */\ntype GeneratedHref<T extends string | object> =\n  | StaticRouteToHrefString<\n      AllUngroupedRoutes<StaticRoutes> | RelativePathString | ExternalPathString\n    >\n  | StaticRouteToHrefObject<\n      AllUngroupedRoutes<StaticRoutes> | RelativePathString | ExternalPathString\n    >\n  | DynamicRouteString<T>\n  | DynamicTemplateToHrefObject<DynamicRouteTemplate>;\n\n/**\n * Converts a static route to a Href string type.\n */\ntype StaticRouteToHrefString<T extends string = string> = T | `${T}${SearchOrHash}`;\n\n/**\n * Converts a static route to a Href object.\n */\ntype StaticRouteToHrefObject<T extends string = string> = T extends any\n  ? {\n      pathname: T;\n      params?: RouteParamInput<T> | never;\n    }\n  : never;\n\n/**\n * Converts a dynamic route template to a `Href` string type.\n */\ntype DynamicRouteString<\n  T extends string | object,\n  P = DynamicRouteTemplate,\n> = '__branded__' extends keyof T\n  ? DynamicTemplateToHrefString<P>\n  : T extends string\n    ? DynamicRoutes<T>\n    : never;\n\n/**\n * @hidden\n */\nexport type DynamicTemplateToHrefString<Path> = Path extends `${infer PartA}/${infer PartB}`\n  ? // If the current segment (PartA) is dynamic, allow any string. This loop again with the next segment (PartB)\n    `${PartA extends `[${string}]` ? string : PartA}/${DynamicTemplateToHrefString<PartB>}`\n  : // Path is the last segment.\n    Path extends `[${string}]`\n    ? string\n    : Path;\n\n/**\n * Converts a dynamic route object to a `Href` object.\n */\ntype DynamicTemplateToHrefObject<T extends string> = T extends string\n  ? {\n      pathname: T;\n      params: RouteParamInput<T>;\n    }\n  : never;\n\n/****************\n * Route Utils  *\n ****************/\n\ntype RelativePathString = `./${string}` | `../${string}` | '..';\ntype SearchOrHash = `?${string}` | `#${string}`;\ntype ExternalPathString = `${string}:${string}`;\n\n/**\n * Given a route. Returns a union of both that route with and without the groups.\n *\n * The type is recursive and will provide a union of all possible routes.\n */\ntype AllUngroupedRoutes<Path> = Path extends `(${infer PartA})/${infer PartB}`\n  ? `(${PartA})/${AllUngroupedRoutes<PartB>}` | AllUngroupedRoutes<PartB>\n  : Path;\n\n/**\n * Routes can have known inputs (e.g query params).\n * Unlike outputs, inputs can be `undefined` or `null`.\n *\n * @hidden\n */\nexport type UnknownInputParams = Record<\n  string,\n  string | number | undefined | null | (string | number)[]\n>;\n\n/**\n * Routes can have unknown outputs (e.g query params).\n * Unlike inputs, outputs can't be undefined or null.\n *\n * @hidden\n */\nexport type UnknownOutputParams = Record<string, string | string[]>;\n\n/**\n * Return the name of a route parameter\n * @example\n * ```\n * '[test]'    -> 'test'\n * 'test'      -> never\n * '[...test]' -> '...test'\n * ```\n */\ntype IsParameter<Part> = Part extends `[${infer ParamName}]` ? ParamName : never;\n\n/**\n * Return a union of all raw parameter names. If there are no names return never.\n *\n * This differs from ParameterNames as it returns the `...` for catch all parameters.\n * @example\n * ```\n * /[test]         -> 'test'\n * /[abc]/[...def] -> 'abc'|'...def'\n * ```\n */\ntype ParameterNames<Path> = Path extends `${infer PartA}/${infer PartB}`\n  ? PartA extends '.' // Skip relative paths\n    ? ParameterNames<PartB>\n    : IsParameter<PartA> | ParameterNames<PartB>\n  : IsParameter<Path>;\n\n/**\n * Return only the RoutePart of a string. If the string has multiple parts return never\n *\n * string   | type\n *| ---------|------|\n *| 123      | 123 |\n *| /123/abc | never |\n *| 123?abc  | never |\n *| ./123    | never |\n *| /123     | never |\n *| 123/../  | never |\n *\n * @hidden\n */\nexport type SingleRoutePart<S extends string> = S extends `${string}/${string}`\n  ? never\n  : S extends `${string}${SearchOrHash}`\n    ? never\n    : S extends ''\n      ? never\n      : S extends `(${string})`\n        ? never\n        : S extends `[${string}]`\n          ? never\n          : S;\n\n/**\n * Returns a Record of the routes parameters as strings and CatchAll parameters\n *\n * There are two versions, input and output, as you can input 'string | number' but\n *  the output will always be 'string'\n *\n * @example\n * ```\n * /[id]/[...rest] -> { id: string, rest: string[] }\n * /no-params      -> {}\n * ```\n */\nexport type StrictRouteParamsInputs<Path> = {\n  [Key in ParameterNames<Path> as Key extends `...${infer Name}`\n    ? Name\n    : Key]: Key extends `...${string}` ? (string | number)[] : string | number;\n};\n\n/**\n * Returns a Record of the routes parameters as strings and CatchAll parameters\n *\n * There are two versions, input and output, as you can input 'string | number' but\n *  the output will always be 'string'\n *\n * @see {@link StrictRouteParamsInputs} for the input version\n *\n * @example\n * ```\n * /[id]/[...rest] -> { id: string, rest: string[] }\n * /no-params      -> {}\n * ```\n */\nexport type StrictRouteParamsOutput<Path> = {\n  [Key in ParameterNames<Path> as Key extends `...${infer Name}`\n    ? Name\n    : Key]: Key extends `...${string}` ? string[] : string;\n};\n\n/**\n * @hidden\n */\nexport type RouteParamInput<Path> = StrictRouteParamsInputs<Path> & UnknownInputParams;\n\n/**\n * @hidden\n */\nexport type RouteParams<\n  PathOrObject extends Routes | UnknownOutputParams,\n  ExtraPathOrObject extends UnknownOutputParams = UnknownOutputParams,\n> = PathOrObject extends string\n  ? StrictRouteParamsOutput<PathOrObject> & ExtraPathOrObject\n  : PathOrObject;\n\n/**\n * @deprecated Use `RouteParams` or `StrictRouteParams` instead.\n *\n * @hidden\n */\nexport type SearchParams<T extends string = never> = RouteParams<T>;\n\n/**\n * @hidden\n */\nexport type RouteSegments<PathOrStringArray extends string | string[]> =\n  PathOrStringArray extends string[]\n    ? PathOrStringArray\n    : PathOrStringArray extends `/${infer PartA}`\n      ? RouteSegments<PartA>\n      : PathOrStringArray extends `${infer PartA}/${infer PartB}`\n        ? [PartA, ...RouteSegments<PartB>]\n        : HasTypedRoutes extends true\n          ? [PathOrStringArray]\n          : string[];\n"]}