{"version":3,"file":"getStateFromPath.js","sourceRoot":"","sources":["../../src/fork/getStateFromPath.ts"],"names":[],"mappings":"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","sourcesContent":["import { PathConfigMap } from '@react-navigation/core';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport validatePathConfig from './validatePathConfig';\nimport { RouteNode } from '../Route';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n  hasChildren: boolean;\n  userReadableName: string;\n  _route?: RouteNode;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: '',\n    };\n  }\n\n  const pathname = parsed.pathname;\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    nonstandardPathname:\n      stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n\n    // React Navigation doesn't support hashes, so here\n    inputPathnameWithoutHash: stripBaseUrl(path, baseUrl).replace(/#.*$/, ''),\n  };\n}\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getMatchableRouteConfigs(options);\n\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\n\nexport function getMatchableRouteConfigs<ParamList extends object>(options?: Options<ParamList>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const screens = options?.screens;\n  // Expo Router disallows usage without a linking config.\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n\n  // This will be mutated...\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  // Create a normalized configs array which will be easier to use.\n  const converted = Object.keys(screens)\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\n    .flat();\n\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  const convertedWithInitial = converted.map((config) => ({\n    ...config,\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join('/')),\n  }));\n\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\n  const configs = convertedWithInitial.sort(sortConfigs);\n\n  // Assert any duplicates before we start parsing.\n  assertConfigDuplicates(configs);\n\n  return { configs, initialRoutes };\n}\n\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\n    const indexedKey = config.regex?.toString() ?? config.pattern;\n    const alpha = acc[indexedKey];\n    // NOTE(EvanBacon): Skips checking nodes that have children.\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      const a = alpha.routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\n        // file-based routing.\n        const last = config.pattern.split('/').pop();\n\n        if (!last?.match(/^\\*not-found$/)) {\n          const routeType = last?.startsWith(':')\n            ? 'dynamic route'\n            : last?.startsWith('*')\n            ? 'dynamic-rest route'\n            : 'route';\n          throw new Error(\n            `The ${routeType} pattern '${config.pattern || '/'}' resolves to both '${\n              alpha.userReadableName\n            }' and '${\n              config.userReadableName\n            }'. Patterns must be unique and cannot resolve to more than one route.`\n          );\n        }\n      }\n    }\n\n    return Object.assign(acc, {\n      [indexedKey]: config,\n    });\n  }, {});\n}\n\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\n  // Sort config so that:\n  // - the most exhaustive ones are always at the beginning\n  // - patterns with wildcard are always at the end\n\n  // If 2 patterns are same, move the one with less route names up\n  // This is an error state, so it's only useful for consistent error messages\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  }\n\n  // If one of the patterns starts with the other, it's more exhaustive\n  // So move it up\n  if (\n    a.pattern.startsWith(b.pattern) &&\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\n    b.screen !== 'index'\n  ) {\n    return -1;\n  }\n\n  if (b.pattern.startsWith(a.pattern) && a.screen !== 'index') {\n    return 1;\n  }\n\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\n  // as a slug or wildcard when nested more than one level deep.\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\n  const aParts = a.pattern\n    .split('/')\n    // Strip out group names to ensure they don't affect the priority.\n    .filter((part) => matchGroupName(part) == null);\n  if (a.screen === 'index') {\n    aParts.push('index');\n  }\n\n  const bParts = b.pattern.split('/').filter((part) => matchGroupName(part) == null);\n  if (b.screen === 'index') {\n    bParts.push('index');\n  }\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    // if b is longer, b get higher priority\n    if (aParts[i] == null) {\n      return 1;\n    }\n    // if a is longer, a get higher priority\n    if (bParts[i] == null) {\n      return -1;\n    }\n\n    const aWildCard = aParts[i].startsWith('*');\n    const bWildCard = bParts[i].startsWith('*');\n    // if both are wildcard we compare next component\n    if (aWildCard && bWildCard) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aWildCard) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bWildCard) {\n      return -1;\n    }\n\n    const aSlug = aParts[i].startsWith(':');\n    const bSlug = bParts[i].startsWith(':');\n    // if both are wildcard we compare next component\n    if (aSlug && bSlug) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aSlug) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bSlug) {\n      return -1;\n    }\n  }\n\n  // Sort initial routes with a higher priority than routes which will push more screens\n  // this ensures shared routes go to the shortest path.\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n\n  return bParts.length - aParts.length;\n}\n\nfunction getStateFromEmptyPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  if (!match) {\n    return undefined;\n  }\n\n  const routes = match.routeNames.map((name) => {\n    if (!match._route) {\n      return { name };\n    }\n    return {\n      name,\n      _route: match._route,\n    };\n  });\n\n  return createNestedStateObject(path, routes, configs, initialRoutes);\n}\n\nfunction getStateFromPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  const formattedPaths = getUrlWithReactNavigationConcessions(path);\n\n  if (formattedPaths.nonstandardPathname === '/') {\n    return getStateFromEmptyPathWithConfigs(\n      formattedPaths.inputPathnameWithoutHash,\n      configs,\n      initialRoutes\n    );\n  }\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n\n  if (routes == null) {\n    return undefined;\n  }\n  // This will always be empty if full path matched\n  return createNestedStateObject(\n    formattedPaths.inputPathnameWithoutHash,\n    routes,\n    configs,\n    initialRoutes\n  );\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nfunction matchAgainstConfigs(remaining: string, configs: RouteConfig[]): ParsedRoute[] | undefined {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (!match) {\n      continue;\n    }\n\n    // TODO: Add support for wildcard routes\n    const matchedParams = config.pattern\n      ?.split('/')\n      .filter((p) => p.match(/^[:*]/))\n      .reduce<Record<string, any>>((acc, p, i) => {\n        if (p.match(/^\\*/)) {\n          return {\n            ...acc,\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\n          };\n        }\n        return Object.assign(acc, {\n          // The param segments appear every second item starting from 2 in the regex match result.\n          // This will only work if we ensure groups aren't included in the match.\n          [p]: match![(i + 1) * 2]?.replace(/\\//, ''),\n        });\n      }, {});\n\n    const routeFromName = (name: string) => {\n      const config = configs.find((c) => c.screen === name);\n      if (!config?.path) {\n        return { name };\n      }\n\n      const segments = config.path.split('/');\n\n      const params: Record<string, any> = {};\n\n      segments\n        .filter((p) => p.match(/^[:*]/))\n        .forEach((p) => {\n          let value = matchedParams[p];\n          if (value) {\n            if (p.match(/^\\*/)) {\n              // Convert to an array before providing as a route.\n              value = value?.split('/').filter(Boolean);\n            }\n\n            const key = p.replace(/^[:*]/, '').replace(/\\?$/, '');\n            params[key] = config.parse?.[key] ? config.parse[key](value) : value;\n          }\n        });\n\n      if (params && Object.keys(params).length) {\n        return { name, params };\n      }\n\n      return { name };\n    };\n\n    routes = config.routeNames.map((name) => {\n      if (!config._route) {\n        return { ...routeFromName(name) };\n      }\n      return {\n        ...routeFromName(name),\n        _route: config._route,\n      };\n    });\n\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\n    const combinedParams = routes.reduce<Record<string, any>>(\n      (acc, r) => Object.assign(acc, r.params),\n      {}\n    );\n\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\n\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n    routes = routes.map((r) => {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n\n    remainingPath = remainingPath.replace(match[1], '');\n\n    break;\n  }\n\n  return routes;\n}\n\nfunction equalHeritage(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[] = [],\n  parentScreens: string[] = [],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = (routeConfig as any)[screen];\n\n  if (typeof config === 'string') {\n    // TODO: This should never happen with the addition of `_route`\n\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    const { _route } = config;\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config.parse,\n          _route\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  hasChildren?: boolean,\n  parse?: ParseConfig,\n  _route?: any\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join('/'),\n    hasChildren: !!hasChildren,\n    _route,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  routeConfigs: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      // If the parents are the same but the route name doesn't match the initial route\n      // then we return the initial route.\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    }\n    return {\n      routes: [route],\n    };\n  }\n\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n    };\n  }\n  return {\n    routes: [{ ...route, state: { routes: [] } }],\n  };\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  routeConfigs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n\n  // Remove groups from the path while preserving a trailing slash.\n  route.path = stripGroupSegmentsFromPath(path);\n\n  const params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {\n  const query = path.split('?')[1];\n  const searchParams = new URLSearchParams(query);\n  const params = Object.fromEntries(\n    // @ts-ignore: [Symbol.iterator] is indeed, available on every platform.\n    searchParams\n  );\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n\nconst baseUrlCache = new Map<string, RegExp>();\n\nfunction getBaseUrlRegex(baseUrl: string) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl)!;\n  }\n  const regex = new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      const reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\n"]}