{"version":3,"file":"getPathFromState.js","sourceRoot":"","sources":["../../src/fork/getPathFromState.ts"],"names":[],"mappings":";;;AAAA,iDAAuF;AAGvF,0CAKqB;AAuBrB,MAAM,eAAe,GAA0B,EAAE,CAAC;AAElD,MAAM,cAAc,GAAG,CAAC,KAAY,EAAqC,EAAE;IACzE,MAAM,KAAK,GACT,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ;QAC7B,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;QAC3B,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE5C,IAAI,KAAK,CAAC,KAAK,EAAE;QACf,OAAO,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KACpC;IAED,IAAI,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;QAC1C,OAAO,cAAc,CAAC,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;KACtD;IAED,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AAEF,SAAS,eAAe,CAAC,MAAqB;IAC5C,OAAO;QACL,KAAK,EAAE,KAAK;QACZ,IAAI,EAAE,SAAS;QACf,GAAG,EAAE,SAAS;QACd,KAAK,EAAE,CAAC;QACR,UAAU,EAAE,EAAE;QACd,MAAM,EAAE;YACN;gBACE,GAAG,EAAE,SAAS;gBACd,IAAI,EAAE,MAAM,CAAC,MAAM;gBACnB,MAAM,EAAE,MAAM,CAAC,MAAM;gBACrB,IAAI,EAAE,MAAM,CAAC,IAAI;aAClB;SACF;KACF,CAAC;AACJ,CAAC;AAED,SAAS,wBAAwB,CAAC,OAAe;IAC/C,OAAO,CACL,OAAO,KAAK,OAAO;QACnB,IAAA,2BAAgB,EAAC,OAAO,CAAC,IAAI,IAAI;QACjC,IAAA,yBAAc,EAAC,OAAO,CAAC,IAAI,IAAI;QAC/B,IAAA,oCAAyB,EAAC,OAAO,CAAC,IAAI,IAAI,CAC3C,CAAC;AACJ,CAAC;AAED,SAAS,oCAAoC,CAAC,GAAW;IACvD,OAAO,kBAAkB,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC3E,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,SAAwB,gBAAgB,CACtC,KAAY,EACZ,QAGC;IAED,OAAO,oBAAoB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC;AACpD,CAAC;AARD,mCAQC;AAED,SAAgB,oBAAoB,CAClC,KAAY,EACZ,WAGI,EAAE,OAAO,EAAE,eAAe,EAAE;IAEhC,IAAI,KAAK,IAAI,IAAI,EAAE;QACjB,MAAM,KAAK,CAAC,+EAA+E,CAAC,CAAC;KAC9F;IAED,MAAM,EAAE,cAAc,EAAE,qBAAqB,EAAE,GAAG,OAAO,EAAE,GAAG,QAAQ,CAAC;IAEvE,IAAA,yBAAkB,EAAC,OAAO,CAAC,CAAC;IAE5B,wDAAwD;IACxD,IAAI,MAAM,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,eAAe,CAAC,EAAE;QAC/C,MAAM,KAAK,CAAC,4EAA4E,CAAC,CAAC;KAC3F;IAED,OAAO,wBAAwB,CAC7B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACjC,iEAAiE;IACjE,uBAAuB,CAAC,OAAO,CAAC,OAAO,CAAC,EACxC,EAAE,cAAc,EAAE,qBAAqB,EAAE,CAC1C,CAAC;AACJ,CAAC;AA1BD,oDA0BC;AAED,SAAS,6BAA6B,CAAC,UAAsB,EAAE,MAA2B;IACxF,MAAM,SAAS,GAAG,UAAU,EAAE,SAAS,CAAC;IAExC,OAAO,MAAM,CAAC,WAAW,CACvB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC;QAC3C,GAAG;QACH,mCAAmC;QACnC,SAAS,EAAE,CAAC,GAAG,CAAC;YACd,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;YACvB,CAAC,CAAC,uBAAuB;gBACzB,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;oBACpB,CAAC,CAAC,KAAK;oBACP,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;KAClB,CAAC,CACH,CAAC;AACJ,CAAC;AAED,SAAgB,SAAS,CAAC,CAAM,EAAE,CAAM;IACtC,IAAI,CAAC,KAAK,CAAC,EAAE;QACX,OAAO,IAAI,CAAC;KACb;IAED,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;QACxC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;YACzB,OAAO,KAAK,CAAC;SACd;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACjC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;gBAC1B,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;KACb;IAED,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;QAClD,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC7B,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAE7B,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;YACjC,OAAO,KAAK,CAAC;SACd;QAED,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE;YACvB,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gBAC9B,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;KACb;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AArCD,8BAqCC;AAED,SAAS,eAAe,CACtB,KAAkB,EAClB,YAGC,EACD,OAAmC,EACnC,EACE,qBAAqB,GAGtB;IAED,gFAAgF;IAChF,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;QACjD,KAAK,CAAC,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;KAC7C;IAED,IAAI,OAAO,GAAkB,IAAI,CAAC;IAClC,IAAI,aAA8C,CAAC;IAEnD,MAAM,eAAe,GAAwB,EAAE,CAAC;IAEhD,OAAO,KAAK,CAAC,IAAI,IAAI,OAAO,EAAE;QAC5B,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACvC,MAAM,YAAY,GAAG,UAAU,CAAC,OAAO,CAAC;QAExC,IAAI,YAAY,IAAI,IAAI,EAAE;YACxB,2CAA2C;YAC3C,MAAM,IAAI,KAAK,CAAC,yCAAyC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;SACzE;QACD,OAAO,GAAG,YAAY,CAAC;QAEvB,IAAI,KAAK,CAAC,MAAM,EAAE;YAChB,MAAM,MAAM,GAAG,6BAA6B,CAAC,UAAU,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;YACvE,IAAI,OAAO,KAAK,SAAS,IAAI,OAAO,KAAK,IAAI,EAAE;gBAC7C,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;aACxC;YACD,IAAI,SAAS,CAAC,YAAY,EAAE,KAAK,CAAC,EAAE;gBAClC,IAAI,qBAAqB,EAAE;oBACzB,aAAa,GAAG,MAAM,CAAC;iBACxB;qBAAM;oBACL,8DAA8D;oBAC9D,sDAAsD;oBACtD,aAAa,GAAG,iCAAiC,CAAC;wBAChD,MAAM;wBACN,OAAO;wBACP,SAAS,EAAE,KAAK,CAAC,IAAI;qBACtB,CAAC,CAAC;iBACJ;aACF;SACF;QAED,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;YACjD,KAAK,CAAC,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SAC7C;QAED,0EAA0E;QAC1E,IAAI,CAAC,UAAU,CAAC,OAAO,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE;YACpD,IACE,UAAU,CAAC,gBAAgB;gBAC3B,UAAU,CAAC,OAAO;gBAClB,UAAU,CAAC,gBAAgB,IAAI,UAAU,CAAC,OAAO;gBACjD,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,gBAAgB,CAAC,EAAE,OAAO,EACxD;gBACA,MAAM,kBAAkB,GAAG,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;gBAE3E,0EAA0E;gBAC1E,OAAO,GAAG,kBAAkB,CAAC,OAAQ,CAAC;gBACtC,IAAI,aAAa,EAAE;oBACjB,IAAI,CAAC,qBAAqB,EAAE;wBAC1B,8DAA8D;wBAC9D,sDAAsD;wBACtD,aAAa,GAAG,iCAAiC,CAAC;4BAChD,MAAM,EAAE,aAAa;4BACrB,OAAO;4BACP,SAAS,EAAE,KAAK,CAAC,IAAI;yBACtB,CAAC,CAAC;qBACJ;iBACF;aACF;YACD,MAAM;SACP;QAED,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;QAEjE,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC5C,MAAM,aAAa,GAAG,UAAU,CAAC,OAAO,CAAC;QAEzC,uDAAuD;QACvD,IAAI,aAAa,IAAI,SAAS,CAAC,IAAI,IAAI,aAAa,EAAE;YACpD,KAAK,GAAG,SAAwB,CAAC;YACjC,OAAO,GAAG,aAAa,CAAC;SACzB;aAAM;YACL,sDAAsD;YACtD,MAAM;SACP;KACF;IAED,IAAI,OAAO,IAAI,IAAI,EAAE;QACnB,MAAM,IAAI,KAAK,CACb,+BAA+B,KAAK,CAAC,IAAI,mBAAmB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAC/F,CAAC;KACH;IAED,IAAI,OAAO,IAAI,CAAC,aAAa,IAAI,YAAY,CAAC,MAAM,EAAE;QACpD,IAAI,qBAAqB,EAAE;YACzB,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC;SACrC;aAAM;YACL,8DAA8D;YAC9D,sDAAsD;YACtD,aAAa,GAAG,iCAAiC,CAAC;gBAChD,MAAM,EAAE,YAAY,CAAC,MAAM;gBAC3B,OAAO;gBACP,SAAS,EAAE,KAAK,CAAC,IAAI;aACtB,CAAC,CAAC;SACJ;QACD,MAAM,CAAC,MAAM,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;KAC/C;IAED,OAAO;QACL,OAAO;QACP,SAAS,EAAE,KAAK;QAChB,aAAa;QACb,MAAM,EAAE,eAAe;KACxB,CAAC;AACJ,CAAC;AAED,SAAS,wBAAwB,CAC/B,KAAY,EACZ,OAAmC,EACnC,EACE,cAAc,EACd,qBAAqB,GACyC;IAEhE,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,IAAI,OAAO,GAAU,KAAK,CAAC;IAE3B,MAAM,SAAS,GAAwB,EAAE,CAAC;IAE1C,OAAO,OAAO,EAAE;QACd,IAAI,IAAI,GAAG,CAAC;QAEZ,6EAA6E;QAC7E,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,CAAgB,CAAC;QAEhE,gFAAgF;QAChF,uCAAuC;QACvC,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;YACjD,KAAK,CAAC,KAAK,GAAG,eAAe,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SAC7C;QAED,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,aAAa,EAAE,GAAG,eAAe,CACnE,KAAK,EACL,cAAc,CAAC,OAAO,CAAC,EACvB,EAAE,GAAG,OAAO,EAAE,EACd,EAAE,qBAAqB,EAAE,CAC1B,CAAC;QAEF,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QAEjC,IAAI,IAAI,+BAA+B,CAAC;YACtC,OAAO;YACP,SAAS,EAAE,SAAS,CAAC,IAAI;YACzB,MAAM,EAAE,SAAS;YACjB,gBAAgB,EAAE,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,gBAAgB;YAC3D,cAAc;YACd,qBAAqB;SACtB,CAAC,CAAC;QAEH,IACE,SAAS,CAAC,KAAK;YACf,4IAA4I;YAC5I,iDAAiD;YACjD,4GAA4G;YAC5G,sCAAsC;YACtC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,EACpE;YACA,qDAAqD;YACrD,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC;SAC3B;aAAM;YACL,2BAA2B;YAE3B,yCAAyC;YACzC,IAAI,aAAa,EAAE;gBACjB,KAAK,MAAM,KAAK,IAAI,aAAa,EAAE;oBACjC,wEAAwE;oBACxE,IAAI,aAAa,CAAC,KAAK,CAAC,KAAK,WAAW,EAAE;wBACxC,gEAAgE;wBAChE,OAAO,aAAa,CAAC,KAAK,CAAC,CAAC;qBAC7B;iBACF;gBAED,MAAM,KAAK,GAAG,IAAI,eAAe,CAAC,aAAa,CAAC,CAAC,QAAQ,EAAE,CAAC;gBAC5D,IAAI,KAAK,EAAE;oBACT,IAAI,IAAI,IAAI,KAAK,EAAE,CAAC;iBACrB;aACF;YACD,MAAM;SACP;KACF;IAED,OAAO,EAAE,IAAI,EAAE,aAAa,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE,YAAY,CAAC,SAAS,CAAC,EAAE,CAAC;AAC3F,CAAC;AAED,SAAS,YAAY,CAAC,MAA8B;IAClD,MAAM,MAAM,GAAwB,EAAE,CAAC;IAEvC,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACjD,IAAI;YACF,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;gBACxB,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC;aACvD;iBAAM;gBACL,MAAM,CAAC,GAAG,CAAC,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;aACzC;SACF;QAAC,MAAM;YACN,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;SACrB;KACF;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,+BAA+B,CAAC,EACvC,OAAO,EACP,SAAS,EACT,MAAM,EACN,cAAc,EACd,qBAAqB,EACrB,gBAAgB,GAQjB;IACC,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACpC,OAAO,QAAQ;SACZ,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;QACZ,MAAM,IAAI,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;QAE7B,mDAAmD;QACnD,kFAAkF;QAClF,wCAAwC;QACxC,IAAI,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACrB,IAAI,qBAAqB,EAAE;gBACzB,IAAI,IAAI,KAAK,WAAW,EAAE;oBACxB,OAAO,YAAY,CAAC;iBACrB;gBACD,OAAO,OAAO,IAAI,GAAG,CAAC;aACvB;YACD,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE;gBAChB,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;oBAC/B,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBAC/B;gBACD,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC;aACrB;YACD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,gFAAgF;gBAChF,OAAO,SAAS,CAAC;aAClB;YACD,yDAAyD;YACzD,4EAA4E;YAC5E,8DAA8D;YAC9D,OAAO,SAAS;gBACd,EAAE,KAAK,CAAC,GAAG,CAAC;iBACX,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;iBACZ,IAAI,CAAC,GAAG,CAAC,CAAC;SACd;QAED,mEAAmE;QACnE,IAAI,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACrB,IAAI,qBAAqB,EAAE;gBACzB,OAAO,IAAI,IAAI,GAAG,CAAC;aACpB;YACD,2EAA2E;YAC3E,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,IAAI,CAAC,cAAc,IAAI,IAAA,yBAAc,EAAC,CAAC,CAAC,IAAI,IAAI,EAAE;YAChD,yDAAyD;YACzD,+DAA+D;YAC/D,oEAAoE;YACpE,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;gBAC7B,IAAI,gBAAgB,EAAE;oBACpB,yDAAyD;oBACzD,IAAI,wBAAwB,CAAC,gBAAgB,CAAC,EAAE;wBAC9C,OAAO,EAAE,CAAC;qBACX;oBACD,OAAO,oCAAoC,CAAC,gBAAgB,CAAC,CAAC;iBAC/D;aACF;YACD,OAAO,EAAE,CAAC;SACX;QACD,0CAA0C;QAC1C,OAAO,oCAAoC,CAAC,CAAC,CAAC,CAAC;IACjD,CAAC,CAAC;SACD,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;SACnB,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,CAAC;AAED,qIAAqI;AACrI,SAAS,iCAAiC,CAAC,EACzC,OAAO,EACP,SAAS,EACT,MAAM,GAMP;IACC,MAAM,eAAe,GAA2B,EAAE,GAAG,MAAM,EAAE,CAAC;IAE9D,0FAA0F;IAE1F,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAEpC,iBAAiB;IACjB,QAAQ;SACL,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;SAC5C,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QACnB,MAAM,IAAI,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;QACnC,OAAO,eAAe,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC,CAAC,CAAC;IAEL,sBAAsB;IACtB,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;QACvD,4GAA4G;QAC5G,MAAM,IAAI,GAAG,IAAA,uBAAY,EAAC,SAAS,CAAC;YAClC,CAAC,CAAC,WAAW;YACb,CAAC,CAAC,IAAA,oCAAyB,EAAC,SAAS,CAAC,IAAI,SAAS,CAAC;QACtD,OAAO,eAAe,CAAC,IAAI,CAAC,CAAC;KAC9B;IAED,OAAO,eAAe,CAAC;AACzB,CAAC;AAED,8CAA8C;AAC9C,SAAS,iBAAiB,CAAC,IAAY;IACrC,wDAAwD;IACxD,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IACjD,IAAI,cAAc,CAAC,MAAM,IAAI,CAAC,EAAE;QAC9B,OAAO,cAAc,CAAC;KACvB;IACD,qDAAqD;IACrD,OAAO,cAAc,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;AAC3C,CAAC;AASD,wCAAwC;AACxC,2FAA2F;AAC3F,SAAS,eAAe,CAAC,MAA4B;IACnD,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,KAAK,CAAC;KACd;IAED,IAAI,QAAQ,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,KAAK,QAAQ,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE;QAC9E,OAAO,IAAI,CAAC;KACb;IAED,OAAO,CACL,SAAS,IAAI,MAAM;QACnB,OAAO,MAAM,CAAC,OAAO,KAAK,SAAS;QACnC,sBAAsB;QACtB,QAAQ,IAAI,MAAM,CACnB,CAAC;AACJ,CAAC;AAED,MAAM,YAAY,GAAG,CAAC,OAAe,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;AAE1F,MAAM,SAAS,GAAG,CAAC,GAAG,KAAe,EAAU,EAAE,CAC9C,EAAe;KACb,MAAM,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;KACzC,MAAM,CAAC,OAAO,CAAC;KACf,IAAI,CAAC,GAAG,CAAC,CAAC;AAEf,MAAM,gBAAgB,GAAG,CACvB,MAAmC,EACnC,aAAsB,EACV,EAAE;IACd,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;QAC9B,6FAA6F;QAC7F,MAAM,OAAO,GAAG,aAAa,CAAC,CAAC,CAAC,SAAS,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAE1E,OAAO,EAAE,OAAO,EAAE,CAAC;KACpB;IAED,IAAI,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,IAAI,KAAK,SAAS,EAAE;QAC7C,MAAM,IAAI,KAAK,CACb,sJAAsJ,CACvJ,CAAC;KACH;IAED,8DAA8D;IAC9D,0EAA0E;IAC1E,MAAM,OAAO,GACX,MAAM,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,aAAa,IAAI,EAAE,EAAE,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;IAEhG,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,uBAAuB,CAAC,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAE9F,OAAO;QACL,oFAAoF;QACpF,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;QACtD,SAAS,EAAE,MAAM,CAAC,SAAS;QAC3B,OAAO;QACP,gBAAgB,EAAE,MAAM,CAAC,gBAAgB;KAC1C,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,uBAAuB,GAAG,CAC9B,OAA8B,EAC9B,OAAgB,EACY,EAAE,CAC9B,MAAM,CAAC,WAAW,CAChB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CACjF,CAAC;AAEJ,SAAgB,aAAa,CAC3B,IAAY,EACZ,UAA8B,OAAO,CAAC,GAAG,CAAC,aAAa;IAEvD,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,aAAa,EAAE;QAC1C,IAAI,OAAO,EAAE;YACX,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC;SACpE;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAVD,sCAUC","sourcesContent":["import { PathConfig, PathConfigMap, validatePathConfig } from '@react-navigation/core';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\n\nimport {\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  testNotFound,\n} from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\ntype CustomRoute = Route<string> & {\n  state?: State;\n};\n\nconst DEFAULT_SCREENS: PathConfigMap<object> = {};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  if (route && isInvalidParams(route.params)) {\n    return getActiveRoute(createFakeState(route.params));\n  }\n\n  return route;\n};\n\nfunction createFakeState(params: StateAsParams) {\n  return {\n    stale: false,\n    type: 'UNKNOWN',\n    key: 'UNKNOWN',\n    index: 0,\n    routeNames: [],\n    routes: [\n      {\n        key: 'UNKNOWN',\n        name: params.screen,\n        params: params.params,\n        path: params.path,\n      },\n    ],\n  };\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' ||\n    matchDynamicName(segment) != null ||\n    matchGroupName(segment) != null ||\n    matchDeepDynamicRouteName(segment) != null\n  );\n}\n\nfunction encodeURIComponentPreservingBrackets(str: string) {\n  return encodeURIComponent(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends object>(\n  state: State,\n  _options?: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  }\n): string {\n  return getPathDataFromState(state, _options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  _options: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  } = { screens: DEFAULT_SCREENS }\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  const { preserveGroups, preserveDynamicRoutes, ...options } = _options;\n\n  validatePathConfig(options);\n\n  // Expo Router disallows usage without a linking config.\n  if (Object.is(options.screens, DEFAULT_SCREENS)) {\n    throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");\n  }\n\n  return getPathFromResolvedState(\n    JSON.parse(JSON.stringify(state)),\n    // Create a normalized configs object which will be easier to use\n    createNormalizedConfigs(options.screens),\n    { preserveGroups, preserveDynamicRoutes }\n  );\n}\n\nfunction processParamsWithUserSettings(configItem: ConfigItem, params: Record<string, any>) {\n  const stringify = configItem?.stringify;\n\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value]) => [\n      key,\n      // TODO: Strip nullish values here.\n      stringify?.[key]\n        ? stringify[key](value)\n        : // Preserve rest params\n        Array.isArray(value)\n        ? value\n        : String(value),\n    ])\n  );\n}\n\nexport function deepEqual(a: any, b: any) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n\n    for (const key of keysA) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction walkConfigItems(\n  route: CustomRoute,\n  focusedRoute: {\n    name: string;\n    params?: object;\n  },\n  configs: Record<string, ConfigItem>,\n  {\n    preserveDynamicRoutes,\n  }: {\n    preserveDynamicRoutes?: boolean;\n  }\n) {\n  // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n  if (!route.state && isInvalidParams(route.params)) {\n    route.state = createFakeState(route.params);\n  }\n\n  let pattern: string | null = null;\n  let focusedParams: Record<string, any> | undefined;\n\n  const collectedParams: Record<string, any> = {};\n\n  while (route.name in configs) {\n    const configItem = configs[route.name];\n    const inputPattern = configItem.pattern;\n\n    if (inputPattern == null) {\n      // This should never happen in Expo Router.\n      throw new Error('Unexpected: No pattern found for route ' + route.name);\n    }\n    pattern = inputPattern;\n\n    if (route.params) {\n      const params = processParamsWithUserSettings(configItem, route.params);\n      if (pattern !== undefined && pattern !== null) {\n        Object.assign(collectedParams, params);\n      }\n      if (deepEqual(focusedRoute, route)) {\n        if (preserveDynamicRoutes) {\n          focusedParams = params;\n        } else {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = getParamsWithConventionsCollapsed({\n            params,\n            pattern,\n            routeName: route.name,\n          });\n        }\n      }\n    }\n\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    // If there is no `screens` property or no nested state, we return pattern\n    if (!configItem.screens || route.state === undefined) {\n      if (\n        configItem.initialRouteName &&\n        configItem.screens &&\n        configItem.initialRouteName in configItem.screens &&\n        configItem.screens[configItem.initialRouteName]?.pattern\n      ) {\n        const initialRouteConfig = configItem.screens[configItem.initialRouteName];\n\n        // NOTE(EvanBacon): Big hack to support initial route changes in tab bars.\n        pattern = initialRouteConfig.pattern!;\n        if (focusedParams) {\n          if (!preserveDynamicRoutes) {\n            // If this is the focused route, keep the params for later use\n            // We save it here since it's been stringified already\n            focusedParams = getParamsWithConventionsCollapsed({\n              params: focusedParams,\n              pattern,\n              routeName: route.name,\n            });\n          }\n        }\n      }\n      break;\n    }\n\n    const index = route.state.index ?? route.state.routes.length - 1;\n\n    const nextRoute = route.state.routes[index];\n    const nestedScreens = configItem.screens;\n\n    // if there is config for next route name, we go deeper\n    if (nestedScreens && nextRoute.name in nestedScreens) {\n      route = nextRoute as CustomRoute;\n      configs = nestedScreens;\n    } else {\n      // If not, there is no sense in going deeper in config\n      break;\n    }\n  }\n\n  if (pattern == null) {\n    throw new Error(\n      `No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`\n    );\n  }\n\n  if (pattern && !focusedParams && focusedRoute.params) {\n    if (preserveDynamicRoutes) {\n      focusedParams = focusedRoute.params;\n    } else {\n      // If this is the focused route, keep the params for later use\n      // We save it here since it's been stringified already\n      focusedParams = getParamsWithConventionsCollapsed({\n        params: focusedRoute.params,\n        pattern,\n        routeName: route.name,\n      });\n    }\n    Object.assign(focusedParams, collectedParams);\n  }\n\n  return {\n    pattern,\n    nextRoute: route,\n    focusedParams,\n    params: collectedParams,\n  };\n}\n\nfunction getPathFromResolvedState(\n  state: State,\n  configs: Record<string, ConfigItem>,\n  {\n    preserveGroups,\n    preserveDynamicRoutes,\n  }: { preserveGroups?: boolean; preserveDynamicRoutes?: boolean }\n) {\n  let path = '';\n  let current: State = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    path += '/';\n\n    // Make mutable copies to ensure we don't leak state outside of the function.\n    const route = current.routes[current.index ?? 0] as CustomRoute;\n\n    // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n    // if (isInvalidParams(route.params)) {\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    const { pattern, params, nextRoute, focusedParams } = walkConfigItems(\n      route,\n      getActiveRoute(current),\n      { ...configs },\n      { preserveDynamicRoutes }\n    );\n\n    Object.assign(allParams, params);\n\n    path += getPathWithConventionsCollapsed({\n      pattern,\n      routePath: nextRoute.path,\n      params: allParams,\n      initialRouteName: configs[nextRoute.name]?.initialRouteName,\n      preserveGroups,\n      preserveDynamicRoutes,\n    });\n\n    if (\n      nextRoute.state &&\n      // NOTE(EvanBacon): The upstream implementation allows for sending in synthetic states (states that weren't generated by `getStateFromPath`)\n      // and any invalid routes will simply be ignored.\n      // Because of this, we need to check if the next route is valid before continuing, otherwise our more strict\n      // implementation will throw an error.\n      configs[nextRoute.state.routes?.[nextRoute.state?.index ?? 0]?.name]\n    ) {\n      // Continue looping with the next state if available.\n      current = nextRoute.state;\n    } else {\n      // Finished crawling state.\n\n      // Check for query params before exiting.\n      if (focusedParams) {\n        for (const param in focusedParams) {\n          // TODO: This is not good. We shouldn't squat strings named \"undefined\".\n          if (focusedParams[param] === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete focusedParams[param];\n          }\n        }\n\n        const query = new URLSearchParams(focusedParams).toString();\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n      break;\n    }\n  }\n\n  return { path: appendBaseUrl(basicSanitizePath(path)), params: decodeParams(allParams) };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  routePath,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  initialRouteName,\n}: {\n  pattern: string;\n  routePath?: string;\n  params: Record<string, any>;\n  preserveGroups?: boolean;\n  preserveDynamicRoutes?: boolean;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // We don't know what to show for wildcard patterns\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n          return `[...${name}]`;\n        }\n        if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        }\n        if (i === 0) {\n          // This can occur when a wildcard matches all routes and the given path was `/`.\n          return routePath;\n        }\n        // remove existing segments from route.path and return it\n        // this is used for nested wildcard routes. Without this, the path would add\n        // all nested segments to the beginning of the wildcard route.\n        return routePath\n          ?.split('/')\n          .slice(i + 1)\n          .join('/');\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        return params[name];\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return encodeURIComponentPreservingBrackets(initialRouteName);\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return encodeURIComponentPreservingBrackets(p);\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\n/** Given a set of query params and a pattern with possible conventions, collapse the conventions and return the remaining params. */\nfunction getParamsWithConventionsCollapsed({\n  pattern,\n  routeName,\n  params,\n}: {\n  pattern: string;\n  /** Route name is required for matching the wildcard route. This is specific to Expo Router. */\n  routeName: string;\n  params: object;\n}): Record<string, string> {\n  const processedParams: Record<string, string> = { ...params };\n\n  // Remove the params present in the pattern since we'll only use the rest for query string\n\n  const segments = pattern.split('/');\n\n  // Dynamic Routes\n  segments\n    .filter((segment) => segment.startsWith(':'))\n    .forEach((segment) => {\n      const name = getParamName(segment);\n      delete processedParams[name];\n    });\n\n  // Deep Dynamic Routes\n  if (segments.some((segment) => segment.startsWith('*'))) {\n    // NOTE(EvanBacon): Drop the param name matching the wildcard route name -- this is specific to Expo Router.\n    const name = testNotFound(routeName)\n      ? 'not-found'\n      : matchDeepDynamicRouteName(routeName) ?? routeName;\n    delete processedParams[name];\n  }\n\n  return processedParams;\n}\n\n// Remove multiple as well as trailing slashes\nfunction basicSanitizePath(path: string) {\n  // Remove duplicate slashes like `foo//bar` -> `foo/bar`\n  const simplifiedPath = path.replace(/\\/+/g, '/');\n  if (simplifiedPath.length <= 1) {\n    return simplifiedPath;\n  }\n  // Remove trailing slash like `foo/bar/` -> `foo/bar`\n  return simplifiedPath.replace(/\\/$/, '');\n}\n\ntype StateAsParams = {\n  initial: boolean;\n  path?: string;\n  screen: string;\n  params: Record<string, any>;\n};\n\n// TODO: Make StackRouter not do this...\n// Detect if the params came from StackRouter using `params` to pass around internal state.\nfunction isInvalidParams(params?: Record<string, any>): params is StateAsParams {\n  if (!params) {\n    return false;\n  }\n\n  if ('params' in params && typeof params.params === 'object' && !!params.params) {\n    return true;\n  }\n\n  return (\n    'initial' in params &&\n    typeof params.initial === 'boolean' &&\n    // \"path\" in params &&\n    'screen' in params\n  );\n}\n\nconst getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n    initialRouteName: config.initialRouteName,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => [name, createConfigItem(c, pattern)])\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"]}