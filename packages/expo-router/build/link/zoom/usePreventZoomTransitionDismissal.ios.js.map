{"version":3,"file":"usePreventZoomTransitionDismissal.ios.js","sourceRoot":"","sources":["../../../src/link/zoom/usePreventZoomTransitionDismissal.ios.tsx"],"names":[],"mappings":";AAAA,YAAY,CAAC;;AAWb,8EA0DC;AAnED,qDAAoD;AACpD,iCAAuC;AAGvC,uEAAwE;AACxE,qFAAiF;AACjF,6DAA0F;AAC1F,uDAAoD;AAEpD,SAAgB,iCAAiC,CAC/C,OAAkD;IAElD,MAAM,OAAO,GAAG,IAAA,WAAG,EAAC,qDAA2B,CAAC,CAAC;IACjD,MAAM,KAAK,GAAG,IAAA,iBAAQ,GAAE,CAAC;IACzB,MAAM,UAAU,GAAG,IAAA,6BAAa,GAAE,CAAC;IAEnC,MAAM,cAAc,GAAG,IAAA,WAAG,EAAC,wCAAkB,CAAC,CAAC;IAC/C,MAAM,iBAAiB,GAAG,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACpD,MAAM,cAAc,GAAG,iBAAiB,EAAE,OAAO,EAAE,cAAc,CAAC;IAElE,IAAA,iBAAS,EAAC,GAAG,EAAE;QACb,MAAM,IAAI,GAAG,OAAO,EAAE,4BAA4B,CAAC;QAEnD,4BAA4B;QAC5B,IAAI,IAAI,EAAE,CAAC;YACT,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;YAExC,gDAAgD;YAChD,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;gBAC7D,OAAO,CAAC,IAAI,CAAC,yEAAyE,CAAC,CAAC;gBACxF,OAAO;YACT,CAAC;YACD,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;gBAC7D,OAAO,CAAC,IAAI,CAAC,yEAAyE,CAAC,CAAC;gBACxF,OAAO;YACT,CAAC;QACH,CAAC;QAED,wDAAwD;QACxD,qCAAqC;QACrC,yFAAyF;QACzF,uDAAuD;QACvD,mDAAmD;QACnD,MAAM,YAAY,GAAG,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAEtF,OAAO,CAAC,sBAAsB,EAAE,CAAC,YAAY,CAAC,CAAC;QAE/C,8FAA8F;QAC9F,iGAAiG;QACjG,4EAA4E;QAC5E,UAAU,CAAC,UAAU,CAAC;YACpB,CAAC,mEAAgD,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS;SACrF,CAAC,CAAC;QAEH,qBAAqB;QACrB,OAAO,GAAG,EAAE;YACV,OAAO,CAAC,sBAAsB,EAAE,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC,CAAC;IACJ,CAAC,EAAE;QACD,OAAO,EAAE,4BAA4B,EAAE,IAAI;QAC3C,OAAO,EAAE,4BAA4B,EAAE,IAAI;QAC3C,OAAO,EAAE,4BAA4B,EAAE,IAAI;QAC3C,OAAO,EAAE,4BAA4B,EAAE,IAAI;QAC3C,OAAO,CAAC,sBAAsB;QAC9B,cAAc;QACd,UAAU;KACX,CAAC,CAAC;AACL,CAAC","sourcesContent":["'use client';\n\nimport { useRoute } from '@react-navigation/native';\nimport { use, useEffect } from 'react';\n\nimport type { UsePreventZoomTransitionDismissalOptions } from './usePreventZoomTransitionDismissal.types';\nimport { ZoomTransitionTargetContext } from './zoom-transition-context';\nimport { DescriptorsContext } from '../../fork/native-stack/descriptors-context';\nimport { INTERNAL_EXPO_ROUTER_GESTURE_ENABLED_OPTION_NAME } from '../../navigationParams';\nimport { useNavigation } from '../../useNavigation';\n\nexport function usePreventZoomTransitionDismissal(\n  options?: UsePreventZoomTransitionDismissalOptions\n) {\n  const context = use(ZoomTransitionTargetContext);\n  const route = useRoute();\n  const navigation = useNavigation();\n\n  const descriptorsMap = use(DescriptorsContext);\n  const currentDescriptor = descriptorsMap[route.key];\n  const gestureEnabled = currentDescriptor?.options?.gestureEnabled;\n\n  useEffect(() => {\n    const rect = options?.unstable_dismissalBoundsRect;\n\n    // Validate rect if provided\n    if (rect) {\n      const { minX, maxX, minY, maxY } = rect;\n\n      // Validate that max > min when both are defined\n      if (minX !== undefined && maxX !== undefined && minX >= maxX) {\n        console.warn('[expo-router] unstable_dismissalBoundsRect: minX must be less than maxX');\n        return;\n      }\n      if (minY !== undefined && maxY !== undefined && minY >= maxY) {\n        console.warn('[expo-router] unstable_dismissalBoundsRect: minY must be less than maxY');\n        return;\n      }\n    }\n\n    // Determine the final rect to use for dismissal bounds:\n    // 1. If user provided a rect, use it\n    // 2. If user disabled gestures entirely (gestureEnabled={false}), block the whole screen\n    //    by setting impossible bounds { maxX: 0, maxY: 0 }\n    // 3. Otherwise, allow normal dismissal (null rect)\n    const computedRect = rect ?? (gestureEnabled === false ? { maxX: 0, maxY: 0 } : null);\n\n    context.setDismissalBoundsRect?.(computedRect);\n\n    // Disable React Navigation's gesture handler when we have custom bounds to prevent conflicts.\n    // The native zoom transition's interactiveDismissShouldBegin callback handles dismissal instead.\n    // We use the internal option to preserve the user's gestureEnabled setting.\n    navigation.setOptions({\n      [INTERNAL_EXPO_ROUTER_GESTURE_ENABLED_OPTION_NAME]: computedRect ? false : undefined,\n    });\n\n    // Cleanup on unmount\n    return () => {\n      context.setDismissalBoundsRect?.(null);\n    };\n  }, [\n    options?.unstable_dismissalBoundsRect?.minX,\n    options?.unstable_dismissalBoundsRect?.maxX,\n    options?.unstable_dismissalBoundsRect?.minY,\n    options?.unstable_dismissalBoundsRect?.maxY,\n    context.setDismissalBoundsRect,\n    gestureEnabled,\n    navigation,\n  ]);\n}\n"]}