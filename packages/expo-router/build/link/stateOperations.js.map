{"version":3,"file":"stateOperations.js","sourceRoot":"","sources":["../../src/link/stateOperations.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  getActionFromState,\n} from '@react-navigation/native';\n\nimport { ResultState } from '../fork/getStateFromPath';\n\nexport type NavigateAction = Extract<\n  ReturnType<typeof getActionFromState>,\n  { type: 'NAVIGATE' }\n> & {\n  payload: NavigateActionParams;\n};\n\nexport type NavigateActionParams = {\n  params?: NavigateActionParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  name?: string;\n};\n\n// Get the last state for a given target state (generated from a path).\nfunction findTopStateForTarget(state: ResultState) {\n  let current: Partial<InitialState> | undefined = state;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    current = current?.routes[current?.routes.length - 1].state;\n  }\n\n  return current;\n}\n\n/** Return the absolute last route to move to. */\nexport function findTopRouteForTarget(state: ResultState) {\n  const nextState = findTopStateForTarget(state)!;\n  // Ensure we get the last route to prevent returning the initial route.\n  return nextState.routes?.[nextState.routes.length - 1]!;\n}\n\n/** @returns true if moving to a sibling inside the same navigator. */\nexport function isMovingToSiblingRoute(\n  currentState: NavigationState | PartialState<NavigationState> | undefined,\n  targetState: ResultState | undefined\n): boolean {\n  if (!currentState || !targetState) {\n    return false;\n  }\n\n  // Need to type this, as the current types are not compaitble with the `find`\n  const targetRoute = targetState.routes[0];\n\n  // Make sure we're in the same navigator\n  if (!currentState.routeNames?.includes(targetRoute.name)) {\n    return false;\n  }\n\n  // If there's no state, we're at the end of the path\n  if (!targetRoute.state) {\n    return true;\n  }\n\n  // Coerce the types into a more common form\n  const currentRoutes:\n    | {\n        name: string;\n        state?: NavigationState | PartialState<NavigationState>;\n      }[]\n    | undefined = currentState?.routes;\n  const locatedState = currentRoutes?.find((r) => r.name === targetRoute.name);\n\n  if (!locatedState) {\n    return false;\n  }\n\n  return isMovingToSiblingRoute(locatedState.state, targetRoute.state);\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getQualifiedStateForTopOfTargetState(\n  rootState: InitialState,\n  targetState: ResultState\n) {\n  let current: InitialState | undefined = targetState;\n  let currentRoot: InitialState | undefined = rootState;\n\n  while (current?.routes?.[current?.routes?.length - 1].state != null) {\n    const nextRoute: any = current?.routes?.[current?.routes?.length - 1];\n\n    const nextCurrentRoot: InitialState | undefined = currentRoot?.routes?.find(\n      (route) => route.name === nextRoute.name\n    )?.state;\n\n    if (nextCurrentRoot == null) {\n      return currentRoot;\n      // Not sure what to do -- we're tracking against the assumption that\n      // all routes in the target state are in the root state\n      // currentRoot = undefined;\n    } else {\n      currentRoot = nextCurrentRoot;\n    }\n\n    current = nextRoute.state;\n  }\n\n  return currentRoot;\n}\n\n// Given the root state and a target state from `getStateFromPath`,\n// return the root state containing the highest target route matching the root state.\n// This can be used to determine what type of navigator action should be used.\nexport function getEarliestMismatchedRoute<T extends ParamListBase>(\n  rootState: NavigationState<T> | undefined,\n  actionParams: NavigateActionParams\n): { name: string; params?: any; type?: string } | null {\n  const actionName = actionParams.name ?? actionParams.screen;\n  if (!rootState?.routes || rootState.index == null) {\n    // This should never happen where there's more action than state.\n    return {\n      name: actionName,\n      type: 'stack',\n    };\n  }\n\n  const nextCurrentRoot = rootState.routes[rootState.index];\n  if (actionName === nextCurrentRoot.name) {\n    if (!actionParams.params) {\n      // All routes match all the way up, no change required.\n      return null;\n    }\n\n    return getEarliestMismatchedRoute(\n      // @react-navigation/native types this as NavigationState | Partial<NavigationState> | undefined\n      // In our usage, it's always a NavigationState | undefined\n      nextCurrentRoot.state as NavigationState<T> | undefined,\n      actionParams.params\n    );\n  }\n\n  // There's a selected state but it doesn't match the action state\n  // this is now the lowest point of change.\n  return {\n    name: actionName,\n    params: actionParams.params,\n    type: rootState.type,\n  };\n}\n"]}