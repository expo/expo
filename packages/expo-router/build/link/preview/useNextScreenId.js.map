{"version":3,"file":"useNextScreenId.js","sourceRoot":"","sources":["../../../src/link/preview/useNextScreenId.ts"],"names":[],"mappings":";;AAWA,0CAQC;AAdD,iCAA8C;AAE9C,kEAAmF;AAEnF,kCAAsC;AAEtC,SAAgB,eAAe;IAC7B,MAAM,CAAC,oBAAoB,EAAE,uBAAuB,CAAC,GAAG,IAAA,gBAAQ,GAAsB,CAAC;IACvF,MAAM,eAAe,GAAG,IAAA,mBAAW,EAAC,CAAC,IAAU,EAAQ,EAAE;QACvD,MAAM,cAAc,GAAG,oCAAoC,CAAC,IAAI,CAAC,CAAC;QAClE,MAAM,QAAQ,GAAG,cAAc,EAAE,GAAG,CAAC;QACrC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;IACpC,CAAC,EAAE,EAAE,CAAC,CAAC;IACP,OAAO,CAAC,oBAAoB,EAAE,eAAe,CAAC,CAAC;AACjD,CAAC;AAED,SAAS,oCAAoC,CAC3C,IAAU;IAEV,MAAM,SAAS,GAAG,oBAAK,CAAC,KAAK,CAAC;IAC9B,IAAI,SAAS,GAAG,oBAAK,CAAC,eAAe,CAAC,IAAA,kBAAW,EAAC,IAAI,CAAC,CAAC,CAAC;IACzD,IAAI,KAAK,GAAqC,SAAS,CAAC;IACxD,OAAO,SAAS,IAAI,KAAK,EAAE,CAAC;QAC1B,MAAM,gBAAgB,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7C,MAAM,iBAAiB,GAAG,gBAAgB;YACxC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,gBAAgB,CAAC,IAAI,CAAC;YAC5D,CAAC,CAAC,SAAS,CAAC;QAEd,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvB,gEAAgE;YAChE,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBAC3B,MAAM,UAAU,GAAG,KAA4C,CAAC;gBAChE,8CAA8C;gBAC9C,MAAM,UAAU,GAAG,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBACzF,MAAM,cAAc,GAAG,UAAU,CAAC,eAAe,CAAC,IAAI,CACpD,CAAC,KAAK,EAAE,EAAE,CACR,KAAK,CAAC,IAAI,KAAK,gBAAgB,CAAC,IAAI;oBACpC,CAAC,CAAC,UAAU;wBACV,CAAC,KAAK,CAAC,MAAM,IAAI,QAAQ,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,CAC3F,CAAC;gBACF,OAAO,cAAc,CAAC;YACxB,CAAC;QACH,CAAC;QACD,SAAS,GAAG,gBAAgB,EAAE,KAAK,CAAC;QACpC,KAAK,GAAG,iBAAiB,EAAE,KAAK,CAAC;IACnC,CAAC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import {\n  ParamListBase,\n  StackNavigationState,\n  type NavigationRoute,\n} from '@react-navigation/native';\nimport { useCallback, useState } from 'react';\n\nimport { store, type ReactNavigationState } from '../../global-state/router-store';\nimport { Href } from '../../types';\nimport { resolveHref } from '../href';\n\nexport function useNextScreenId(): [string | undefined, (href: Href) => void] {\n  const [internalNextScreenId, internalSetNextScreenId] = useState<string | undefined>();\n  const setNextScreenId = useCallback((href: Href): void => {\n    const preloadedRoute = getPreloadedRouteFromRootStateByHref(href);\n    const routeKey = preloadedRoute?.key;\n    internalSetNextScreenId(routeKey);\n  }, []);\n  return [internalNextScreenId, setNextScreenId];\n}\n\nfunction getPreloadedRouteFromRootStateByHref(\n  href: Href\n): NavigationRoute<ParamListBase, string> | undefined {\n  const rootState = store.state;\n  let hrefState = store.getStateForHref(resolveHref(href));\n  let state: ReactNavigationState | undefined = rootState;\n  while (hrefState && state) {\n    const currentHrefRoute = hrefState.routes[0];\n    const currentStateRoute = currentHrefRoute\n      ? state.routes.find((r) => r.name === currentHrefRoute.name)\n      : undefined;\n\n    if (!currentStateRoute) {\n      // Only checking stack, because it is the only native navigator.\n      if (state.type === 'stack') {\n        const stackState = state as StackNavigationState<ParamListBase>;\n        // Sometimes the route is stored inside params\n        const innerRoute = currentHrefRoute.state ? currentHrefRoute.state.routes[0] : undefined;\n        const preloadedRoute = stackState.preloadedRoutes.find(\n          (route) =>\n            route.name === currentHrefRoute.name &&\n            (!innerRoute ||\n              (route.params && 'screen' in route.params && route.params.screen === innerRoute.name))\n        );\n        return preloadedRoute;\n      }\n    }\n    hrefState = currentHrefRoute?.state;\n    state = currentStateRoute?.state;\n  }\n  return undefined;\n}\n"]}