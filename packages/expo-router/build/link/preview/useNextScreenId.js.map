{"version":3,"file":"useNextScreenId.js","sourceRoot":"","sources":["../../../src/link/preview/useNextScreenId.ts"],"names":[],"mappings":";;AASA,0CA4CC;AArDD,iCAAiE;AAEjE,6DAA6D;AAE7D,mCAA8F;AAC9F,kEAAwD;AACxD,uCAAwC;AAGxC,SAAgB,eAAe;IAI7B,MAAM,MAAM,GAAG,IAAA,iBAAS,GAAE,CAAC;IAC3B,MAAM,EAAE,iBAAiB,EAAE,GAAG,IAAA,0CAAqB,GAAE,CAAC;IACtD,MAAM,CAAC,oBAAoB,EAAE,uBAAuB,CAAC,GAAG,IAAA,gBAAQ,GAAsB,CAAC;IACvF,MAAM,WAAW,GAAG,IAAA,cAAM,EAAmB,SAAS,CAAC,CAAC;IACxD,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC,GAAG,IAAA,gBAAQ,EAAY,EAAE,CAAC,CAAC;IAEtD,IAAA,iBAAS,EAAC,GAAG,EAAE;QACb,sFAAsF;QACtF,OAAO,oBAAK,CAAC,aAAa,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE;YACtE,qEAAqE;YACrE,IAAI,WAAW,CAAC,OAAO,IAAI,KAAK,EAAE,CAAC;gBACjC,MAAM,cAAc,GAAG,IAAA,4CAAoC,EAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;gBACxF,MAAM,QAAQ,GAAG,cAAc,EAAE,GAAG,CAAC;gBACrC,MAAM,oBAAoB,GAAG,IAAA,qCAA6B,EAAC,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;gBACvF,sFAAsF;gBACtF,mDAAmD;gBACnD,IAAI,QAAQ,IAAI,oBAAoB,CAAC,MAAM,EAAE,CAAC;oBAC5C,UAAU,CAAC,GAAG,EAAE;wBACd,uBAAuB,CAAC,QAAQ,CAAC,CAAC;wBAClC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;wBAC5B,UAAU,CAAC,oBAAoB,CAAC,CAAC;oBACnC,CAAC,CAAC,CAAC;gBACL,CAAC;gBACD,8DAA8D;gBAC9D,oCAAoC;gBACpC,WAAW,CAAC,OAAO,GAAG,SAAS,CAAC;YAClC,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,MAAM,QAAQ,GAAG,IAAA,mBAAW,EAC1B,CAAC,IAAU,EAAQ,EAAE;QACnB,0CAA0C;QAC1C,uBAAuB,CAAC,SAAS,CAAC,CAAC;QACnC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACtB,WAAW,CAAC,OAAO,GAAG,IAAI,CAAC;IAC7B,CAAC,EACD,CAAC,MAAM,CAAC,QAAQ,CAAC,CAClB,CAAC;IACF,OAAO,CAAC,EAAE,YAAY,EAAE,oBAAoB,EAAE,OAAO,EAAE,EAAE,QAAQ,CAAC,CAAC;AACrE,CAAC","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { useLinkPreviewContext } from './LinkPreviewContext';\nimport { TabPath } from './native';\nimport { getPreloadedRouteFromRootStateByHref, getTabPathFromRootStateByHref } from './utils';\nimport { store } from '../../global-state/router-store';\nimport { useRouter } from '../../hooks';\nimport { Href } from '../../types';\n\nexport function useNextScreenId(): [\n  { nextScreenId: string | undefined; tabPath: TabPath[] },\n  (href: Href) => void,\n] {\n  const router = useRouter();\n  const { setOpenPreviewKey } = useLinkPreviewContext();\n  const [internalNextScreenId, internalSetNextScreenId] = useState<string | undefined>();\n  const currentHref = useRef<Href | undefined>(undefined);\n  const [tabPath, setTabPath] = useState<TabPath[]>([]);\n\n  useEffect(() => {\n    // When screen is prefetched, then the root state is updated with the preloaded route.\n    return store.navigationRef.addListener('state', ({ data: { state } }) => {\n      // If we have the current href, it means that we prefetched the route\n      if (currentHref.current && state) {\n        const preloadedRoute = getPreloadedRouteFromRootStateByHref(currentHref.current, state);\n        const routeKey = preloadedRoute?.key;\n        const tabPathFromRootState = getTabPathFromRootStateByHref(currentHref.current, state);\n        // Without this timeout react-native does not have enough time to mount the new screen\n        // and thus it will not be found on the native side\n        if (routeKey || tabPathFromRootState.length) {\n          setTimeout(() => {\n            internalSetNextScreenId(routeKey);\n            setOpenPreviewKey(routeKey);\n            setTabPath(tabPathFromRootState);\n          });\n        }\n        // We got the preloaded state, so we can reset the currentHref\n        // to prevent unnecessary processing\n        currentHref.current = undefined;\n      }\n    });\n  }, []);\n\n  const prefetch = useCallback(\n    (href: Href): void => {\n      // Resetting the nextScreenId to undefined\n      internalSetNextScreenId(undefined);\n      router.prefetch(href);\n      currentHref.current = href;\n    },\n    [router.prefetch]\n  );\n  return [{ nextScreenId: internalNextScreenId, tabPath }, prefetch];\n}\n"]}