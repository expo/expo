{"version":3,"file":"routing.js","sourceRoot":"","sources":["../../src/global-state/routing.ts"],"names":[],"mappings":"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","sourcesContent":["import { CommonActions, getActionFromState, StackActions } from '@react-navigation/core';\nimport { TabActions } from '@react-navigation/native';\nimport * as Linking from 'expo-linking';\n\nimport type { RouterStore } from './router-store';\nimport { Href, resolveHref } from '../link/href';\nimport { resolve } from '../link/path';\nimport {\n  NavigateAction,\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n} from '../link/stateOperations';\nimport { hasUrlProtocolPrefix } from '../utils/url';\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'REPLACE');\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  assertIsReady(this);\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function setParams(this: RouterStore, params: Record<string, string | number> = {}) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (hasUrlProtocolPrefix(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  if (href.startsWith('.')) {\n    let base =\n      this.linking.getPathFromState?.(navigationRef.getRootState(), {\n        screens: [],\n        preserveGroups: true,\n      }) ?? '';\n\n    if (base && !base.endsWith('/')) {\n      base += '/..';\n    }\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  // Ensure simple operations are used when moving between siblings\n  // in the same navigator. This ensures that the state is not reset.\n  // TODO: We may need to apply this at a larger scale in the future.\n  if (isMovingToSiblingRoute(rootState, state)) {\n    // Can perform naive movements\n    const knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state)!;\n    const nextRoute = findTopRouteForTarget(state);\n    // NOTE(EvanBacon): There's an issue where moving from \"a -> b\" is considered siblings:\n    // a. index (initialRouteName=\"index\")\n    // b. stack/index\n    // However, the preservation approach doesn't work because it would be moving to a route with the same name.\n    // The next check will see if the current focused route has the same name as the next route, if so, then fallback on\n    // the default React Navigation logic.\n    if (\n      findTopRouteForTarget(\n        // @ts-expect-error: stale types don't matter here\n        rootState\n      )?.name !== nextRoute.name\n    ) {\n      if (event === 'REPLACE') {\n        if (knownOwnerState.type === 'tab') {\n          navigationRef.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n        } else {\n          navigationRef.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n        }\n      } else {\n        // NOTE: Not sure if we should pop or push here...\n        navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n      }\n      return;\n    }\n  }\n\n  // TODO: Advanced movements across multiple navigators\n\n  const action = getActionFromState(state, this.linking.config);\n  if (action) {\n    // Here we have a navigation action to a nested screen, where we should ideally replace.\n    // This request can only be fulfilled if the target is an initial route.\n    // First, check if the action is fully initial routes.\n    // Then find the nearest mismatched route in the existing state.\n    // Finally, use the correct navigator-based action to replace the nested screens.\n    // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n    if (event === 'REPLACE' && isAbsoluteInitialRoute(action)) {\n      const earliest = getEarliestMismatchedRoute(rootState, action.payload);\n      if (earliest) {\n        if (earliest.type === 'stack') {\n          navigationRef.dispatch(StackActions.replace(earliest.name, earliest.params));\n        } else {\n          navigationRef.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n        }\n        return;\n      } else {\n        // This should never happen because moving to the same route would be handled earlier\n        // in the sibling operations.\n      }\n    }\n\n    // Ignore the replace event here since replace across\n    // navigators is not supported.\n    navigationRef.dispatch(action);\n  } else {\n    navigationRef.reset(state);\n  }\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n): action is NavigateAction {\n  if (action?.type !== 'NAVIGATE') {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return 'initial' in obj;\n}\n"]}