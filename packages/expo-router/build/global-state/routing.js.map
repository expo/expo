{"version":3,"file":"routing.js","sourceRoot":"","sources":["../../src/global-state/routing.ts"],"names":[],"mappings":"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","sourcesContent":["import { StackActions, type NavigationState } from '@react-navigation/native';\nimport * as Linking from 'expo-linking';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport { type RouterStore } from './router-store';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { Href, resolveHref } from '../link/href';\nimport { resolve } from '../link/path';\nimport { shouldLinkExternally } from '../utils/url';\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport function navigate(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'NAVIGATE');\n}\n\nexport function push(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'PUSH');\n}\n\nexport function dismiss(this: RouterStore, count?: number) {\n  this.navigationRef?.dispatch(StackActions.pop(count));\n}\n\nexport function replace(this: RouterStore, url: Href) {\n  return this.linkTo(resolveHref(url), 'REPLACE');\n}\n\nexport function dismissAll(this: RouterStore) {\n  this.navigationRef?.dispatch(StackActions.popToTop());\n}\n\nexport function goBack(this: RouterStore) {\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function canDismiss(this: RouterStore): boolean {\n  let state = this.rootState;\n\n  // Keep traversing down the state tree until we find a stack navigator that we can pop\n  while (state) {\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n\n    state = state.routes?.[state.index]?.state as any;\n  }\n\n  return false;\n}\n\nexport function setParams(this: RouterStore, params: Record<string, string | number> = {}) {\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport function linkTo(this: RouterStore, href: string, event?: string) {\n  if (shouldLinkExternally(href)) {\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  if (href.startsWith('.')) {\n    // Resolve base path by merging the current segments with the params\n    let base =\n      this.routeInfo?.segments\n        ?.map((segment) => {\n          if (!segment.startsWith('[')) return segment;\n\n          if (segment.startsWith('[...')) {\n            segment = segment.slice(4, -1);\n            const params = this.routeInfo?.params?.[segment];\n            if (Array.isArray(params)) {\n              return params.join('/');\n            } else {\n              return params?.split(',')?.join('/') ?? '';\n            }\n          } else {\n            segment = segment.slice(1, -1);\n            return this.routeInfo?.params?.[segment];\n          }\n        })\n        .filter(Boolean)\n        .join('/') ?? '/';\n\n    if (!this.routeInfo?.isIndex) {\n      base += '/..';\n    }\n\n    href = resolve(base, href);\n  }\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  return navigationRef.dispatch(getNavigateAction(state, rootState, event));\n}\n\ntype NavigationParams = Partial<{\n  screen: string;\n  params: NavigationParams;\n  key?: string;\n}>;\n\nfunction rewriteNavigationStateToParams(\n  state: { routes: ResultState['routes'] } | NavigationState | undefined,\n  params: NavigationParams = {}\n) {\n  if (!state) return params;\n  // We Should always have at least one route in the state\n  const lastRoute = state.routes[state.routes.length - 1]!;\n  params.screen = lastRoute.name;\n  // Weirdly, this always needs to be an object. If it's undefined, it won't work.\n  params.params = lastRoute.params ? JSON.parse(JSON.stringify(lastRoute.params)) : {};\n\n  if (lastRoute.state) {\n    rewriteNavigationStateToParams(lastRoute.state, params.params);\n  }\n\n  return JSON.parse(JSON.stringify(params));\n}\n\nfunction getNavigateAction(state: ResultState, parentState: NavigationState, type = 'NAVIGATE') {\n  const { screen, params } = rewriteNavigationStateToParams(state);\n\n  let key: string | undefined;\n\n  if (type === 'PUSH') {\n    /*\n     * The StackAction.PUSH does not work correctly with Expo Router.\n     *\n     * Expo Router provides a getId() function for every route, altering how React Navigation handles stack routing.\n     * Ordinarily, PUSH always adds a new screen to the stack. However, with getId() present, it navigates to the screen with the matching ID instead (by moving the screen to the top of the stack)\n     * When you try and push to a screen with the same ID, no navigation will occur\n     * Refer to: https://github.com/react-navigation/react-navigation/blob/13d4aa270b301faf07960b4cd861ffc91e9b2c46/packages/routers/src/StackRouter.tsx#L279-L290\n     *\n     * Expo Router needs to retain the default behavior of PUSH, consistently adding new screens to the stack, even if their IDs are identical.\n     *\n     * To resolve this issue, we switch to using a NAVIGATE action with a new key. In the navigate action, screens are matched by either key or getId() function.\n     * By generating a unique new key, we ensure that the screen is always pushed onto the stack.\n     *\n     */\n    type = 'NAVIGATE';\n\n    if (parentState.type === 'stack') {\n      key = `${screen}-${nanoid()}`; // @see https://github.com/react-navigation/react-navigation/blob/13d4aa270b301faf07960b4cd861ffc91e9b2c46/packages/routers/src/StackRouter.tsx#L406-L407\n    }\n  } else if (type === 'REPLACE' && parentState.type === 'tab') {\n    type = 'JUMP_TO';\n  }\n\n  return {\n    type,\n    target: parentState.key,\n    payload: {\n      key,\n      name: screen,\n      params,\n    },\n  };\n}\n"]}