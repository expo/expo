{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/navigationEvents/index.ts"],"names":[],"mappings":";;;AAwEA,oBAOC;AAnDD,MAAM,eAAe,GAA6B;IAChD,gBAAgB;IAChB,aAAa;IACb,aAAa;IACb,aAAa;CACd,CAAC;AAEF,IAAI,oBAAoB,GAAG,KAAK,CAAC;AACjC,IAAI,WAAW,GAAG,KAAK,CAAC;AAKxB,MAAM,WAAW,GAEb,EAAE,CAAC;AAEP,SAAS,WAAW,CAClB,SAAoB,EACpB,QAA6C;IAE7C,IAAI,oBAAoB,EAAE,CAAC;QACzB,OAAO,CAAC,IAAI,CACV,6MAA6M,CAC9M,CAAC;QACF,OAAO,GAAG,EAAE,GAAE,CAAC,CAAC;IAClB,CAAC;IACD,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;QACzC,MAAM,IAAI,KAAK,CAAC,2BAA2B,SAAS,EAAE,CAAC,CAAC;IAC1D,CAAC;IACD,WAAW,GAAG,IAAI,CAAC;IACnB,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE,CAAC;QAC5B,WAAW,CAAC,SAAS,CAAC,GAAG,IAAI,GAAG,EAAqC,CAAC;IACxE,CAAC;IACD,WAAW,CAAC,SAAS,CAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IACtC,OAAO,GAAG,EAAE;QACV,WAAW,CAAC,SAAS,CAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACzC,IAAI,WAAW,CAAC,SAAS,CAAE,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;YACvC,OAAO,WAAW,CAAC,SAAS,CAAC,CAAC;QAChC,CAAC;QACD,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;IACpD,CAAC,CAAC;AACJ,CAAC;AAED,SAAgB,IAAI,CAAkC,IAAe,EAAE,KAAyB;IAC9F,MAAM,mBAAmB,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;IAC9C,IAAI,mBAAmB,EAAE,CAAC;QACxB,KAAK,MAAM,QAAQ,IAAI,mBAAmB,EAAE,CAAC;YAC3C,QAAQ,CAAC,KAAK,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;AACH,CAAC;AAEY,QAAA,yBAAyB,GAAG;IACvC,WAAW;IACX,IAAI;IACJ,cAAc;QACZ,OAAO,WAAW,CAAC;IACrB,CAAC;IACD,iBAAiB;QACf,oBAAoB,GAAG,IAAI,CAAC;IAC9B,CAAC;CACF,CAAC","sourcesContent":["interface BasePageEvent {\n  pathname: string;\n  screenId: string;\n}\n\n/**\n * The rendering of the page started\n *\n * This can happen if screen is to be focused for the first time or when the screen is preloaded\n */\nexport interface PageWillRender extends BasePageEvent {\n  type: 'pageWillRender';\n}\n\nexport interface PageFocusedEvent extends BasePageEvent {\n  type: 'pageFocused';\n}\n\nexport interface PageBlurredEvent extends BasePageEvent {\n  type: 'pageBlurred';\n}\n\nexport interface PageRemoved extends BasePageEvent {\n  type: 'pageRemoved';\n}\n\nexport type AnalyticsEvent = PageWillRender | PageFocusedEvent | PageBlurredEvent | PageRemoved;\n\nconst availableEvents: AnalyticsEvent['type'][] = [\n  'pageWillRender',\n  'pageFocused',\n  'pageBlurred',\n  'pageRemoved',\n];\n\nlet isAfterInitialRender = false;\nlet hasListener = false;\n\ntype EventTypeName = AnalyticsEvent['type'];\ntype Payload<T extends EventTypeName> = Omit<Extract<AnalyticsEvent, { type: T }>, 'type'>;\n\nconst subscribers: {\n  [K in EventTypeName]?: Set<(event: Payload<K>) => void>;\n} = {};\n\nfunction addListener<EventType extends EventTypeName>(\n  eventType: EventType,\n  callback: (event: Payload<EventType>) => void\n) {\n  if (isAfterInitialRender) {\n    console.warn(\n      '[expo-router] unstable_analytics.addListener was called after the initial render. Analytics listeners should be added in the global scope before first render of your app, preferably in a root _layout.tsx'\n    );\n    return () => {};\n  }\n  if (!availableEvents.includes(eventType)) {\n    throw new Error(`Unsupported event type: ${eventType}`);\n  }\n  hasListener = true;\n  if (!subscribers[eventType]) {\n    subscribers[eventType] = new Set() as (typeof subscribers)[EventType];\n  }\n  subscribers[eventType]!.add(callback);\n  return () => {\n    subscribers[eventType]!.delete(callback);\n    if (subscribers[eventType]!.size === 0) {\n      delete subscribers[eventType];\n    }\n    hasListener = Object.keys(subscribers).length > 0;\n  };\n}\n\nexport function emit<EventType extends EventTypeName>(type: EventType, event: Payload<EventType>) {\n  const subscribersForEvent = subscribers[type];\n  if (subscribersForEvent) {\n    for (const callback of subscribersForEvent) {\n      callback(event);\n    }\n  }\n}\n\nexport const unstable_navigationEvents = {\n  addListener,\n  emit,\n  hasAnyListener() {\n    return hasListener;\n  },\n  markInitialRender() {\n    isAfterInitialRender = true;\n  },\n};\n"]}