{"version":3,"file":"Common.types.js","sourceRoot":"","sources":["../src/Common.types.ts"],"names":[],"mappings":"AA8PA;;GAEG;AACH,MAAM,CAAN,IAAY,sBAmBX;AAnBD,WAAY,sBAAsB;IAChC;;OAEG;IACH,yGAA4B,CAAA;IAC5B;;OAEG;IACH,6HAAsC,CAAA;IACtC;;;OAGG;IACH,iGAAwB,CAAA;IACxB;;;OAGG;IACH,+FAAuB,CAAA;AACzB,CAAC,EAnBW,sBAAsB,KAAtB,sBAAsB,QAmBjC","sourcesContent":["/**\n * Basic point type for representing a coordinate on a map.\n */\nexport type Point = {\n  /**\n   * The latitude of the point in degrees. Use decimal degrees as opposed to degrees/minutes/seconds.\n   * @required\n   */\n  latitude: number;\n  /**\n   * The longitude of the point in degrees. Use decimal degrees as opposed to degrees/minutes/seconds.\n   * @required\n   */\n  longitude: number;\n};\n\n/**\n * Type for representing width and height on a map using latitude and longitude.\n */\nexport type LatLngDelta = {\n  /**\n   * The north-to-south distance.\n   * @required\n   */\n  latitudeDelta: number;\n  /**\n   * The east-to-west distance.\n   * @required\n   */\n  longitudeDelta: number;\n};\n\n/**\n * Generic object that associates numerical data with a georgaphic coordinate.\n */\nexport type PointWithData = Point & {\n  /**\n   * Numerical data associated with the point. (optional)\n   * @default 1\n   */\n  data?: number;\n};\n\n/**\n * PatternItem is used to define a repeating pattern for polyline and polygon line.\n * PatternItem with type `stroke` and length 0 will represent a dot.\n * Use an array of PatternItem to define a pattern.\n */\nexport type PatternItem = {\n  /**\n   * The type of the pattern item.\n   * * `'stroke'` - rendered line segment\n   * * `'gap'` - transparent gap between pattern items\n   * @required\n   */\n  type: 'stroke' | 'gap';\n  /**\n   * Length of the pattern item in pixels.\n   * @required\n   */\n  length: number;\n};\n\nexport type CameraPosition = {\n  /**\n   * The location that the camera is pointing at.\n   * @required\n   */\n  target: Point;\n\n  /**\n   * The Direction that the camera is pointing in, in degrees clockwise from north\n   * @required\n   */\n  bearing: number;\n\n  /**\n   * The angle, in degrees, of the camera angle from the nadir (directly facing the Earth).\n   * @required\n   */\n\n  tilt: number;\n\n  /**\n   * Zoom level near the center of the screen.\n   * @platform iOS: Google maps only.\n   * @platform Android: Supported\n   */\n  zoom: number;\n\n  /**\n   * The amount of north-to-south distance (measured in degrees) to display on the map.\n   * @required for Apple Maps Only\n   */\n  latitudeDelta: number;\n\n  /**\n   * The amount of east-to-west distance (measured in degrees) to display for the map region.\n   * @required for Apple Maps Only\n   */\n  longitudeDelta: number;\n};\n\n/**\n * Information about animation of the camera, contains target position and animation parameters.\n * Camera will animate only the values which have been set, unset parameters won't be affected\n *\n * Note: If latLngDelta is set the camera move is going to ignore the zoom,\n * tilt and bearing properties.Instead the camera will move to a smallest view containing a rectangle\n * created around the center point by the deltas.\n */\nexport type CameraMove = {\n  /**\n   * Location to which the camera should animate. This will be in the center of the view\n   */\n  target?: Point;\n\n  /**\n   * Bearing to which the camera should animate.\n   */\n  bearing?: number;\n\n  /**\n   * Tilt to which the camera should animate.\n   */\n\n  tilt?: number;\n\n  /**\n   * Zoom to which the camera should animate.\n   */\n  zoom?: number;\n\n  latLngDelta?: LatLngDelta;\n\n  /**\n   * Duration in milliseconds of the animation\n   * @default 1000\n   */\n  duration?: number;\n  /**\n   * When true camera will smoothly animate it's position over the time provided in `duration` prop.\n   * Otherwise the camera will instantly move to provided position\n   * @default true\n   */\n  animate?: boolean;\n};\n\n/**\n * Type describing points of interest on the map\n */\nexport type PointOfInterest = {\n  /**\n   * Position of the point of interest\n   * @required\n   */\n  position: Point;\n  /**\n   * Name of the point of interest\n   * @required\n   */\n  name: string;\n  /**\n   * Unique ID of the point of interest\n   * @required\n   */\n  placeId: string;\n};\n\n/**\n * Type describing a marker (pin) placed on the map\n */\nexport type Marker = {\n  /**\n   * Id given to the marker\n   */\n  id: string;\n  /**\n   * Position of the marker\n   * @required\n   */\n  position: Point;\n};\n\nexport type MapCluster = {\n  /**\n   * ID of the cluster\n   */\n  id: string;\n  /**\n   * Position of the point of the cluster\n   * @required\n   */\n  position: Point;\n};\n\nexport type UserLocation = {\n  /**\n   * Current position of the user represented by\n   * {@link Point}\n   */\n  position: Point;\n  /**\n   * Current altitude of the user\n   */\n  altitude: number;\n  /**\n   * The radius of uncertainty for the user'slocation, measured in meters.\n   */\n  accuracy: number;\n  /**\n   * Accuracy of current altitude estimate\n   */\n  verticalAccuracy: number;\n  /**\n   * Current speed of the user measured im meters per second\n   */\n  speed: number;\n  /**\n   * Accuracy of the current speed estimate\n   */\n  speedAccuracy: number;\n  /**\n   * Direction the user is heading\n   */\n  heading: number;\n  /**\n   * The time at which this location was determined\n   */\n  timestamp: number;\n};\n\nexport type Color =\n  | 'red'\n  | 'blue'\n  | 'green'\n  | 'black'\n  | 'white'\n  | 'gray'\n  | 'cyan'\n  | 'magenta'\n  | 'yellow'\n  | 'lightgray'\n  | 'darkgray'\n  | 'aqua'\n  | 'fuchsia'\n  | 'lime'\n  | 'maroon'\n  | 'navy'\n  | 'olive'\n  | 'purple'\n  | 'silver'\n  | 'teal';\n\n/**\n * Possible power priorities for OnLocationChange event\n */\nexport enum LocationChangePriority {\n  /**\n   * Best accuracy that the device can acquire. Will consume more power.\n   */\n  PRIORITY_HIGH_ACCURACY = 100,\n  /**\n   * Bock level accuracy. Block level accuracy is considered to be about 100 meter accuracy.\n   */\n  PRIORITY_BALANCED_POWER_ACCURACY = 102,\n  /**\n   * City level accuracy. City level accuracy is considered to be about 10km accuracy.\n   * Using a coarse accuracy such as this often consumes less power\n   */\n  PRIORITY_LOW_POWER = 104,\n  /**\n   * No locations will be returned unless a different client has requested location updates in which case\n   * this request will act as a passive listener to those locations. Will use no additional power\n   */\n  PRIORITY_NO_POWER = 105,\n}\n"]}