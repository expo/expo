{"version":3,"file":"backoff.js","sourceRoot":"","sources":["../../src/utils/backoff.ts"],"names":[],"mappings":"AAAA,kEAAkE;AAClE,MAAM,UAAU,0BAA0B,CACxC,cAAsB,EACtB,kBAA0B,EAC1B,EACE,UAAU,GAAG,GAAG,EAChB,mBAAmB,GAAG,IAAI,EAC1B,UAAU,GAAG,cAAc,EAC3B,UAAU,GAAG,QAAQ,GACtB,GAAG,EAAE;IAEN,gGAAgG;IAChG,2FAA2F;IAE3F,gDAAgD;IAChD,IAAI,cAAc,IAAI,CAAC;QAAE,cAAc,GAAG,CAAC,CAAC;IAC5C,gDAAgD;IAChD,IAAI,kBAAkB,GAAG,CAAC;QAAE,kBAAkB,GAAG,CAAC,CAAC;IACnD,4DAA4D;IAC5D,IAAI,UAAU,GAAG,CAAC;QAAE,UAAU,GAAG,CAAC,CAAC;IACnC,gDAAgD;IAChD,IAAI,mBAAmB,GAAG,CAAC,IAAI,mBAAmB,GAAG,CAAC;QAAE,mBAAmB,GAAG,CAAC,CAAC;IAEhF,MAAM,WAAW,GAAG,cAAc,GAAG,UAAU,IAAI,kBAAkB,CAAC;IACtE,iFAAiF;IACjF,MAAM,YAAY,GAAG,CAAC,GAAG,mBAAmB,GAAG,CAAC,GAAG,mBAAmB,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;IAEvF,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,GAAG,YAAY,EAAE,UAAU,CAAC,EAAE,UAAU,CAAC,CAAC;AAChF,CAAC","sourcesContent":["// See: https://github.com/ide/backoff/blob/0c83ac6/src/backoff.ts\nexport function computeNextBackoffInterval(\n  initialBackoff: number,\n  previousRetryCount: number,\n  {\n    multiplier = 1.5,\n    randomizationFactor = 0.25,\n    minBackoff = initialBackoff,\n    maxBackoff = Infinity,\n  } = {}\n): number {\n  // NOTE: These are internal assumptions/assertions of the backoff function, but we're hardcoding\n  // these values, so they're replaced with conditions instead, to make this self-documenting\n\n  // The initial backoff interval must be positive\n  if (initialBackoff <= 0) initialBackoff = 1;\n  // The previous retry count must not be negative\n  if (previousRetryCount < 0) previousRetryCount = 0;\n  // The backoff multiplier must be greater than or equal to 1\n  if (multiplier < 1) multiplier = 1;\n  // The minimum backoff interval must be positive\n  if (randomizationFactor < 0 || randomizationFactor > 1) randomizationFactor = 0;\n\n  const nextBackoff = initialBackoff * multiplier ** previousRetryCount;\n  // Apply jitter within the negative to positive range of the randomization factor\n  const jitterFactor = 1 - randomizationFactor + 2 * randomizationFactor * Math.random();\n\n  return Math.min(Math.max(nextBackoff * jitterFactor, minBackoff), maxBackoff);\n}\n"]}