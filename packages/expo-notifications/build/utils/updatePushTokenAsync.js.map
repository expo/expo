{"version":3,"file":"updatePushTokenAsync.js","sourceRoot":"","sources":["../../src/utils/updatePushTokenAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError, Platform } from '@unimodules/core';\nimport * as Application from 'expo-application';\n\nimport { Registration } from '../DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\nimport generateRetries from './generateRetries';\nimport makeInterruptible from './makeInterruptible';\n\nexport const [\n  updatePushTokenAsync,\n  hasPushTokenBeenUpdated,\n  interruptPushTokenUpdates,\n] = makeInterruptible<[DevicePushToken]>(updatePushTokenAsyncGenerator);\n\nasync function* updatePushTokenAsyncGenerator(token: DevicePushToken) {\n  // Fetch the latest registration info from the persisted storage\n  const lastRegistrationInfo = yield ServerRegistrationModule.getLastRegistrationInfoAsync?.();\n  // If there is none, do not do anything.\n  if (!lastRegistrationInfo) {\n    return;\n  }\n\n  // Prepare request body\n  const lastRegistration: Registration = JSON.parse(lastRegistrationInfo);\n  // Persist `pendingDevicePushToken` in case the app gets killed\n  // before we finish registering to server.\n  await ServerRegistrationModule.setLastRegistrationInfoAsync?.(\n    JSON.stringify({\n      ...lastRegistration,\n      pendingDevicePushToken: token,\n    })\n  );\n\n  const body = {\n    ...lastRegistration.body,\n    // Information whether a token is applicable\n    // to development or production notification service\n    // should never be persisted as it can change between\n    // Xcode development and TestFlight/AppStore without\n    // backing store being resetted (development registration\n    // remains in production environment).\n    development: await shouldUseDevelopmentNotificationService(),\n    deviceToken: token.data,\n    type: getTypeOfToken(token),\n  };\n\n  const retriesIterator = generateRetries(async retry => {\n    try {\n      const response = await fetch(lastRegistration.url, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n      }).catch(error => {\n        throw new CodedError(\n          'ERR_NOTIFICATIONS_NETWORK_ERROR',\n          `Error encountered while updating device push token in server: ${error}.`\n        );\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating device push token in server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error thrown while updating device push token in server:',\n        e\n      );\n\n      // We only want to retry if it was a network error.\n      // Other error may be JSON.parse error which we can do nothing about.\n      if (e instanceof CodedError && (e as CodedError).code === 'ERR_NOTIFICATIONS_NETWORK_ERROR') {\n        retry();\n      } else {\n        // If we aren't going to try again, throw the error\n        throw e;\n      }\n    }\n  });\n\n  let result = (yield retriesIterator.next()) as IteratorResult<void, void>;\n  while (!result.done) {\n    // We specifically want to yield the result here\n    // to the calling function so that call to this generator\n    // may be interrupted between retries.\n    result = (yield retriesIterator.next()) as IteratorResult<void, void>;\n  }\n\n  // We uploaded the token successfully, let's clear the `pendingDevicePushToken`\n  // from the registration so that we don't try to upload the same token\n  // again.\n  yield ServerRegistrationModule.setLastRegistrationInfoAsync?.(\n    JSON.stringify({\n      ...lastRegistration,\n      pendingDevicePushToken: null,\n    })\n  );\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch (e) {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"]}