package expo.modules.backgroundtask

import android.content.Context
import android.os.Build
import android.util.Log
import androidx.work.Constraints
import androidx.work.Data
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.NetworkType
import androidx.work.Operation
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import com.facebook.react.common.build.ReactBuildConfig
import com.google.common.util.concurrent.ListenableFuture
import expo.modules.interfaces.taskManager.TaskServiceProviderHelper
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.withContext
import java.time.Duration
import java.util.concurrent.TimeUnit

class BackgroundTaskScheduler {
  companion object {
    // Default interval
    const val DEFAULT_INTERVAL_MINUTES = 60L * 24L // Once every day

    // Unique identifier (generated by us) to identify the worker
    private const val WORKER_IDENTIFIER = "EXPO_BACKGROUND_WORKER"

    // Log tag
    private val TAG = BackgroundTaskScheduler::class.java.simpleName

    // Number of active task consumers
    private var numberOfRegisteredTasksOfThisType = 0

    // Interval
    private var intervalMinutes: Long = DEFAULT_INTERVAL_MINUTES

    /**
     * Call when a task is registered
     */
    fun registerTask(intervalMinutes: Long) {
      numberOfRegisteredTasksOfThisType += 1
      this.intervalMinutes = intervalMinutes
    }

    /**
     * Call when a task is unregistered
     */
    fun unregisterTask() {
      numberOfRegisteredTasksOfThisType -= 1
    }

    /**
     * Schedules the worker task to run. The worker should run periodically.
     */
    suspend fun startWorker(context: Context, appScopeKey: String): Boolean {
      if (numberOfRegisteredTasksOfThisType == 0) {
        Log.d(TAG, "Will not enqueue worker. No registered tasks to run.")
        return false
      }

      // Stop the current worker (if any)
      stopWorker(context)

      Log.d(TAG, "Enqueuing worker with identifier $WORKER_IDENTIFIER")

      // Build the work request
      val data = Data.Builder()
        .putString("appScopeKey", appScopeKey)
        .build()
      val constraints = Constraints.Builder()
        .setRequiresBatteryNotLow(true)
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .build()

      // Create the work request
      val builder = PeriodicWorkRequestBuilder<BackgroundTaskWork>(
        repeatIntervalTimeUnit = TimeUnit.MINUTES,
        repeatInterval = intervalMinutes
      )
        .setInputData(data)
        .setConstraints(constraints)

      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        // Add minimum interval here as well so that the work doesn't start immediately
        builder.setInitialDelay(Duration.ofMinutes(intervalMinutes))
      }

      // Create work request
      val workRequest = builder.build()

      // Get Work manager
      val workManager = WorkManager.getInstance(context)

      // Enqueue the work
      return try {
        workManager.enqueueUniquePeriodicWork(
          WORKER_IDENTIFIER,
          ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE,
          workRequest
        ).await()

        true
      } catch (e: Exception) {
        Log.e(TAG, "Worker failed to start with error " + e.message)
        false
      }
    }

    /**
     * Cancels the worker task
     */
    suspend fun stopWorker(context: Context): Boolean {
      if (!isWorkerRunning(context)) {
        return false
      }

      Log.d(TAG, "Cancelling worker with identifier $WORKER_IDENTIFIER")

      // Stop our main worker
      val workManager = WorkManager.getInstance(context)
      return try {
        workManager.cancelUniqueWork(WORKER_IDENTIFIER).await()
      } catch (e: Exception) {
        Log.d(TAG, "Stopping worker failed with error " + e.message)
        false
      }
    }

    /**
     * Returns true if the worker task is pending
     */
    private suspend fun isWorkerRunning(context: Context): Boolean {
      val workInfo = getWorkerInfo(context)
      return workInfo?.state == WorkInfo.State.RUNNING ||
        workInfo?.state == WorkInfo.State.ENQUEUED
    }

    /**
     * Runs tasks with the given appScopeKey
     */
    suspend fun runTasks(context: Context, appScopeKey: String) : Boolean {
      // Get task service
      val taskService = TaskServiceProviderHelper.getTaskServiceImpl(context)
        ?: throw MissingTaskServiceException()

      Log.d(TAG, "runTasks: $appScopeKey")

      // Get all task consumers
      val consumers = taskService.getTaskConsumers(appScopeKey)
      Log.d(TAG, "runTasks: number of consumers ${consumers.size}")

      if (consumers.size == 0) {
        return false
      }

      val tasks = consumers.mapNotNull { consumer ->
        val bgTaskConsumer = consumer as? BackgroundTaskConsumer ?: return@mapNotNull null

        Log.d(TAG, "runTasks: executing tasks for consumer of type ${consumer.taskType()}")

        val taskCompletion = CompletableDeferred<Unit>()

        bgTaskConsumer.executeTask {
          Log.d(TAG, "Task successfully finished")
          taskCompletion.complete(Unit)
        }

        taskCompletion
      }

      // Await all tasks to complete
      tasks.awaitAll()

      return true
    }

    /**
     * Returns the worker info object from the WorkManager if the worker has been
     * registered, otherwise returns null
     */
    private suspend fun getWorkerInfo(context: Context): WorkInfo? {
      // Get work manager
      val workManager = WorkManager.getInstance(context)

      return try {
        val workInfos = workManager.getWorkInfosForUniqueWork(WORKER_IDENTIFIER).await()
        return workInfos.firstOrNull()
      } catch (e: Exception) {
        Log.d(TAG, "Calling getWorkInfosForUniqueWork failed with error " + e.message)
        null
      }
    }

    /**
     * Helper function for calling functions returning an Operation
     */
    suspend fun Operation.await(): Boolean = withContext(Dispatchers.IO) {
      try {
        result.get()
        true
      } catch (e: Exception) {
        throw e
      }
    }

    /**
     * Helper function for calling functions returning a ListenableFuture
     */
    suspend fun <T> ListenableFuture<T>.await(): T = withContext(Dispatchers.IO) {
      try {
        get()
      } catch (e: CancellationException) {
        cancel(true)
        throw e
      } catch (e: Exception) {
        throw e
      }
    }
  }
}
