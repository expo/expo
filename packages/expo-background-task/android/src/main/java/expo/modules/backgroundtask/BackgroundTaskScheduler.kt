package expo.modules.backgroundtask

import android.content.Context
import android.os.Build
import android.util.Log
import androidx.work.Constraints
import androidx.work.Data
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.NetworkType
import androidx.work.Operation
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkInfo
import androidx.work.WorkManager
import com.google.common.util.concurrent.ListenableFuture
import expo.modules.interfaces.taskManager.TaskServiceProviderHelper
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.withContext
import java.time.Duration
import java.util.concurrent.TimeUnit

object BackgroundTaskScheduler {
  // Default interval
  const val DEFAULT_INTERVAL_MINUTES = 60L * 24L // Once every day

  // Unique identifier (generated by us) to identify the worker
  private const val WORKER_IDENTIFIER = "EXPO_BACKGROUND_WORKER"

  // Log tag
  private val TAG = BackgroundTaskScheduler::class.java.simpleName

  // Number of active task consumers
  private var numberOfRegisteredTasksOfThisType = 0

  // Interval
  private var intervalMinutes: Long = DEFAULT_INTERVAL_MINUTES

  /**
   * Call when a task is registered
   */
  fun registerTask(intervalMinutes: Long) {
    numberOfRegisteredTasksOfThisType += 1
    this.intervalMinutes = intervalMinutes
  }

  /**
   * Call when a task is unregistered
   */
  fun unregisterTask() {
    numberOfRegisteredTasksOfThisType -= 1
  }

  /**
   * Schedules the worker task to run. The worker should run periodically.
   */
  suspend fun startWorker(context: Context, appScopeKey: String): Boolean {
    if (numberOfRegisteredTasksOfThisType == 0) {
      Log.d(TAG, "Will not enqueue worker. No registered tasks to run.")
      return false
    }

    // Stop the current worker (if any)
    stopWorker(context)

    Log.d(TAG, "Enqueuing worker with identifier $WORKER_IDENTIFIER")

    // Build the work request
    val data = Data.Builder()
      .putString("appScopeKey", appScopeKey)
      .build()
    val constraints = Constraints.Builder()
      .setRequiresBatteryNotLow(true)
      .setRequiredNetworkType(NetworkType.CONNECTED)
      .build()

    // Create the work request
    val builder = PeriodicWorkRequestBuilder<BackgroundTaskWork>(
      repeatIntervalTimeUnit = TimeUnit.MINUTES,
      repeatInterval = intervalMinutes
    )
      .setInputData(data)
      .setConstraints(constraints)

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      // Add minimum interval here as well so that the work doesn't start immediately
      builder.setInitialDelay(Duration.ofMinutes(intervalMinutes))
    }

    // Create work request
    val workRequest = builder.build()

    // Get Work manager
    val workManager = WorkManager.getInstance(context)

    // Enqueue the work
    return try {
      workManager.enqueueUniquePeriodicWork(
        WORKER_IDENTIFIER,
        ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE,
        workRequest
      ).await()

      true
    } catch (e: Exception) {
      Log.e(TAG, "Worker failed to start with error " + e.message)
      false
    }
  }

  /**
   * Cancels the worker task
   */
  suspend fun stopWorker(context: Context): Boolean {
    if (!isWorkerRunning(context)) {
      return false
    }

    Log.d(TAG, "Cancelling worker with identifier $WORKER_IDENTIFIER")

    // Stop our main worker
    val workManager = WorkManager.getInstance(context)
    return try {
      workManager.cancelUniqueWork(WORKER_IDENTIFIER).await()
    } catch (e: Exception) {
      Log.d(TAG, "Stopping worker failed with error " + e.message)
      false
    }
  }

  /**
   * Returns true if the worker task is pending
   */
  private suspend fun isWorkerRunning(context: Context): Boolean {
    val workInfo = getWorkerInfo(context)
    return workInfo?.state == WorkInfo.State.RUNNING ||
      workInfo?.state == WorkInfo.State.ENQUEUED
  }

  /**
   * Runs tasks with the given appScopeKey
   */
  suspend fun runTasks(context: Context, appScopeKey: String): Boolean {
    // Get task service
    val taskService = TaskServiceProviderHelper.getTaskServiceImpl(context)
      ?: throw MissingTaskServiceException()

    Log.d(TAG, "runTasks: $appScopeKey")

    // Get all task consumers
    val consumers = taskService.getTaskConsumers(appScopeKey)
    Log.d(TAG, "runTasks: number of consumers ${consumers.size}")

    if (consumers.size == 0) {
      return false
    }

    val tasks = consumers.filterIsInstance<BackgroundTaskConsumer>()
      .map { bgTaskConsumer ->
        Log.d(TAG, "runTasks: executing tasks for consumer of type ${bgTaskConsumer.taskType()}")
        val taskCompletion = CompletableDeferred<Unit>()
        bgTaskConsumer.executeTask {
          Log.d(TAG, "Task successfully finished")
          taskCompletion.complete(Unit)
        }
        taskCompletion
      }
    // Await all tasks to complete
    tasks.awaitAll()
    return true
  }

  /**
   * Returns the worker info object from the WorkManager if the worker has been
   * registered, otherwise returns null
   */
  private suspend fun getWorkerInfo(context: Context): WorkInfo? {
    // Get work manager
    val workManager = WorkManager.getInstance(context)

    return try {
      val workInfos = workManager.getWorkInfosForUniqueWork(WORKER_IDENTIFIER).await()
      return workInfos.firstOrNull()
    } catch (e: Exception) {
      Log.d(TAG, "Calling getWorkInfosForUniqueWork failed with error " + e.message)
      null
    }
  }

  /**
   * Helper function for calling functions returning an Operation
   */
  private suspend fun Operation.await(): Boolean = withContext(Dispatchers.IO) {
    result.get()
    true
  }

  /**
   * Helper function for calling functions returning a ListenableFuture
   */
  private suspend fun <T> ListenableFuture<T>.await(): T = withContext(Dispatchers.IO) {
    try {
      get()
    } catch (e: CancellationException) {
      cancel(true)
      throw e
    } catch (e: Exception) {
      throw e
    }
  }
}
