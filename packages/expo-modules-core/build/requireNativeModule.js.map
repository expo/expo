{"version":3,"file":"requireNativeModule.js","sourceRoot":"","sources":["../src/requireNativeModule.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAE7C,OAAO,kBAAkB,MAAM,sBAAsB,CAAC;AA2BtD;;;;;;;;GAQG;AACH,MAAM,UAAU,mBAAmB,CAAmB,UAAkB;IACtE,MAAM,YAAY,GAAG,2BAA2B,CAAa,UAAU,CAAC,CAAC;IAEzE,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,KAAK,CAAC,8BAA8B,UAAU,GAAG,CAAC,CAAC;KAC9D;IACD,OAAO,YAAY,CAAC;AACtB,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,2BAA2B,CACzC,UAAkB;IAElB,+BAA+B,EAAE,CAAC;IAElC,OAAO,CACL,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,UAAU,CAAC;QACtC,UAAU,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC;QACpC,kBAAkB,CAAC,UAAU,CAAC;QAC9B,IAAI,CACL,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,SAAS,+BAA+B;IACtC,IAAI,UAAU,CAAC,IAAI,EAAE;QACnB,OAAO;KACR;IACD,IAAI;QACF,oDAAoD;QACpD,sEAAsE;QACtE,yEAAyE;QACzE,aAAa,CAAC,eAAe,EAAE,cAAc,EAAE,CAAC;KACjD;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,KAAK,CAAC,mCAAmC,KAAK,EAAE,CAAC,CAAC;KAC3D;AACH,CAAC","sourcesContent":["import { NativeModules } from 'react-native';\n\nimport NativeModulesProxy from './NativeModulesProxy';\n\ntype ExpoObject = {\n  modules:\n    | undefined\n    | {\n        [key: string]: any;\n      };\n  uuidv4: () => string;\n  uuidv5: (name: string, namespace: string) => string;\n};\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var expo: ExpoObject | undefined;\n\n  /**\n   * @deprecated `global.ExpoModules` is deprecated, use `global.expo.modules` instead.\n   */\n  // eslint-disable-next-line no-var\n  var ExpoModules:\n    | undefined\n    | {\n        [key: string]: any;\n      };\n}\n\n/**\n * Imports the native module registered with given name. In the first place it tries to load\n * the module installed through the JSI host object and then falls back to the bridge proxy module.\n * Notice that the modules loaded from the proxy may not support some features like synchronous functions.\n *\n * @param moduleName Name of the requested native module.\n * @returns Object representing the native module.\n * @throws Error when there is no native module with given name.\n */\nexport function requireNativeModule<ModuleType = any>(moduleName: string): ModuleType {\n  const nativeModule = requireOptionalNativeModule<ModuleType>(moduleName);\n\n  if (!nativeModule) {\n    throw new Error(`Cannot find native module '${moduleName}'`);\n  }\n  return nativeModule;\n}\n\n/**\n * Imports the native module registered with the given name. The same as `requireNativeModule`,\n * but returns `null` when the module cannot be found instead of throwing an error.\n *\n * @param moduleName Name of the requested native module.\n * @returns Object representing the native module or `null` when it cannot be found.\n */\nexport function requireOptionalNativeModule<ModuleType = any>(\n  moduleName: string\n): ModuleType | null {\n  ensureNativeModulesAreInstalled();\n\n  return (\n    globalThis.expo?.modules?.[moduleName] ??\n    globalThis.ExpoModules?.[moduleName] ??\n    NativeModulesProxy[moduleName] ??\n    null\n  );\n}\n\n/**\n * Ensures that the native modules are installed in the current runtime.\n * Otherwise, it synchronously calls a native function that installs them.\n */\nfunction ensureNativeModulesAreInstalled(): void {\n  if (globalThis.expo) {\n    return;\n  }\n  try {\n    // TODO: ExpoModulesCore shouldn't be optional here,\n    // but to keep backwards compatibility let's just ignore it in SDK 50.\n    // In most cases the modules were already installed from the native side.\n    NativeModules.ExpoModulesCore?.installModules();\n  } catch (error) {\n    console.error(`Unable to install Expo modules: ${error}`);\n  }\n}\n"]}