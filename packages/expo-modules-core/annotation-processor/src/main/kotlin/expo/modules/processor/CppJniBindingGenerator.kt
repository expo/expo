package expo.modules.processor

import expo.modules.processor.OptimizedFunctionProcessor.FunctionMetadata

object CppJniBindingGenerator {

    fun generate(metadata: FunctionMetadata): String {
        val functionFullName = "${metadata.moduleName}_${metadata.functionName}"
        val jniMethodName = toJNIMethodName(metadata.modulePackage, metadata.moduleName, metadata.functionName)

        return """
// Generated by OptimizedFunctionProcessor
// DO NOT EDIT - This file is auto-generated

#include <jni.h>
#include <jsi/jsi.h>

namespace jsi = facebook::jsi;

namespace expo {
namespace generated {

// Forward declaration of the adapter function
jsi::Value ${functionFullName}_adapter(
    JNIEnv* env,
    jobject moduleInstance,
    jsi::Runtime& rt,
    const jsi::Value* args,
    size_t count
);

} // namespace generated
} // namespace expo

extern "C" JNIEXPORT jlong JNICALL
${jniMethodName}(
    JNIEnv* env,
    jclass clazz
) {
    // Return function pointer as jlong
    return reinterpret_cast<jlong>(&expo::generated::${functionFullName}_adapter);
}
""".trimIndent()
    }

    /**
     * Converts package and function name to JNI method name format
     * Example: expo.modules.benchmark.BenchmarkingExpoModule.getAddNumbersFunctionPointer
     * becomes: Java_expo_modules_benchmark_BenchmarkingExpoModule_1OptimizedRegistry_getAddNumbersFunctionPointer
     */
    private fun toJNIMethodName(packageName: String, moduleName: String, functionName: String): String {
        val packagePath = packageName.replace('.', '_')
        val methodName = "get${functionName.capitalize()}FunctionPointer"
        return "Java_${packagePath}_${moduleName}_1OptimizedRegistry_$methodName"
    }

    private fun String.capitalize(): String {
        return this.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }
}
