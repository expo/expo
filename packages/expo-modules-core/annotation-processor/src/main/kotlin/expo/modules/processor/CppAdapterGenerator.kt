package expo.modules.processor

import expo.modules.processor.OptimizedFunctionProcessor.FunctionMetadata

object CppAdapterGenerator {

    fun generate(metadata: FunctionMetadata): String {
        val functionFullName = "${metadata.moduleName}_${metadata.functionName}"
        val paramCount = metadata.parameters.size

        // Generate parameter extraction code
        val paramExtractionCode = metadata.parameters.mapIndexed { index, param ->
            val jniType = mapKotlinTypeToJNIType(param.kotlinType)
            val jsiExtraction = mapKotlinTypeToJSIExtraction(param.kotlinType)
            "    $jniType arg$index = ${jsiExtraction.replace("INDEX", index.toString())};"
        }.joinToString("\n")

        // Generate JNI method signature
        val jniSignature = buildJNISignature(metadata)

        // Generate JNI call
        val jniCallCode = generateJNICall(metadata)

        // Generate return statement
        val returnCode = generateReturnStatement(metadata.returnType)

        return """
// Generated by OptimizedFunctionProcessor
// DO NOT EDIT - This file is auto-generated

#include <jni.h>
#include <jsi/jsi.h>
#include <stdexcept>

namespace jsi = facebook::jsi;

namespace expo {
namespace generated {

// Cached method ID (initialized once)
static jmethodID ${functionFullName}_methodId = nullptr;

// Specialized adapter - NO BOXING
jsi::Value ${functionFullName}_adapter(
    JNIEnv* env,
    jobject moduleInstance,
    jsi::Runtime& rt,
    const jsi::Value* args,
    size_t count
) {
    // Validate arg count
    if (count != $paramCount) {
        throw std::runtime_error("${metadata.functionName}: Expected $paramCount args, got " + std::to_string(count));
    }

    // Direct primitive extraction - NO BOXING
$paramExtractionCode

    // Cache method ID on first call
    if (${functionFullName}_methodId == nullptr) {
        jclass clazz = env->GetObjectClass(moduleInstance);
        ${functionFullName}_methodId = env->GetMethodID(clazz, "${metadata.functionName}", "$jniSignature");
        if (${functionFullName}_methodId == nullptr) {
            throw std::runtime_error("Method not found: ${metadata.functionName}");
        }
    }

    // Direct JNI call with primitives
$jniCallCode

$returnCode
}

} // namespace generated
} // namespace expo
""".trimIndent()
    }

    private fun mapKotlinTypeToJNIType(kotlinType: String): String {
        return when (kotlinType) {
            "Double" -> "jdouble"
            "Int" -> "jint"
            "Boolean" -> "jboolean"
            "Long" -> "jlong"
            "Float" -> "jfloat"
            "String" -> "jstring"
            "Unit" -> "void"
            else -> "jobject"
        }
    }

    private fun mapKotlinTypeToJSIExtraction(kotlinType: String): String {
        return when (kotlinType) {
            "Double" -> "args[INDEX].asNumber()"
            "Int" -> "static_cast<jint>(args[INDEX].asNumber())"
            "Boolean" -> "args[INDEX].asBool()"
            "Long" -> "static_cast<jlong>(args[INDEX].asNumber())"
            "Float" -> "static_cast<jfloat>(args[INDEX].asNumber())"
            "String" -> "args[INDEX].asString(rt).utf8(rt).c_str()"
            else -> "nullptr  // Unsupported type: $kotlinType"
        }
    }

    private fun buildJNISignature(metadata: FunctionMetadata): String {
        val paramSignatures = metadata.parameters.map { param ->
            mapKotlinTypeToJNISignature(param.kotlinType)
        }.joinToString("")

        val returnSignature = mapKotlinTypeToJNISignature(metadata.returnType)

        return "($paramSignatures)$returnSignature"
    }

    private fun mapKotlinTypeToJNISignature(kotlinType: String): String {
        return when (kotlinType) {
            "Double" -> "D"
            "Int" -> "I"
            "Boolean" -> "Z"
            "Long" -> "J"
            "Float" -> "F"
            "String" -> "Ljava/lang/String;"
            "Unit" -> "V"
            else -> "Ljava/lang/Object;"
        }
    }

    private fun generateJNICall(metadata: FunctionMetadata): String {
        val jniCallMethod = when (metadata.returnType) {
            "Double" -> "CallDoubleMethod"
            "Int" -> "CallIntMethod"
            "Boolean" -> "CallBooleanMethod"
            "Long" -> "CallLongMethod"
            "Float" -> "CallFloatMethod"
            "Unit" -> "CallVoidMethod"
            "String" -> "CallObjectMethod"
            else -> "CallObjectMethod"
        }

        val argList = metadata.parameters.indices.joinToString(", ") { "arg$it" }
        val returnVar = if (metadata.returnType != "Unit") {
            val jniType = mapKotlinTypeToJNIType(metadata.returnType)
            "    $jniType result = env->$jniCallMethod(\n" +
            "        moduleInstance,\n" +
            "        ${metadata.moduleName}_${metadata.functionName}_methodId"
        } else {
            "    env->$jniCallMethod(\n" +
            "        moduleInstance,\n" +
            "        ${metadata.moduleName}_${metadata.functionName}_methodId"
        }

        return if (argList.isNotEmpty()) {
            "$returnVar,\n        $argList\n    );"
        } else {
            "$returnVar\n    );"
        }
    }

    private fun generateReturnStatement(returnType: String): String {
        return when (returnType) {
            "Unit" -> "    return jsi::Value::undefined();"
            "Double", "Int", "Long", "Float" -> "    return jsi::Value(result);"
            "Boolean" -> "    return jsi::Value(result);"
            "String" -> """    const char* cstr = env->GetStringUTFChars(static_cast<jstring>(result), nullptr);
    jsi::String jsStr = jsi::String::createFromUtf8(rt, cstr);
    env->ReleaseStringUTFChars(static_cast<jstring>(result), cstr);
    return jsi::Value(std::move(jsStr));"""
            else -> "    // TODO: Handle object return type\n    return jsi::Value::undefined();"
        }
    }
}
