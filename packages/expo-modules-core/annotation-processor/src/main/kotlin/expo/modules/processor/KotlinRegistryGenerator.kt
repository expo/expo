package expo.modules.processor

import expo.modules.processor.OptimizedFunctionProcessor.FunctionMetadata

object KotlinRegistryGenerator {

    fun generate(moduleName: String, packageName: String, functions: List<FunctionMetadata>): String {
        // Generate extension functions for iOS-style DSL
        val extensionFunctions = functions.joinToString("\n\n") { function ->
            val jniSignature = buildJNISignature(function)
            val paramTypesArray = function.parameters.joinToString(", ") {
                "\"${mapKotlinTypeToJNISignature(it.kotlinType)}\""
            }
            val returnType = mapKotlinTypeToJNISignature(function.returnType)

            """/**
 * iOS-style DSL for optimized function: ${function.jsFunctionName}
 *
 * Call this in your ModuleDefinition block instead of Function("${function.jsFunctionName}", ::${function.kotlinFunctionName})
 */
fun expo.modules.kotlin.modules.ModuleDefinitionBuilder.${function.kotlinFunctionName}() {
    this.registerOptimizedFunction(
        jsName = "${function.jsFunctionName}",
        kotlinMethodName = "${function.kotlinFunctionName}",
        jniSignature = "$jniSignature",
        paramTypes = arrayOf($paramTypesArray),
        returnType = "$returnType"
    )
}"""
        }

        return """
// Generated by OptimizedFunctionProcessor
// DO NOT EDIT - This file is auto-generated
//
// iOS-style DSL for optimized functions - just call the function in your definition block!
// Uses JNI reflection with shared C++ dispatcher (no per-function C++ code needed).

package $packageName

$extensionFunctions
""".trimIndent()
    }

    private fun buildJNISignature(metadata: FunctionMetadata): String {
        val paramSignatures = metadata.parameters.joinToString("") { param ->
            mapKotlinTypeToJNISignature(param.kotlinType)
        }
        val returnSignature = mapKotlinTypeToJNISignature(metadata.returnType)
        return "($paramSignatures)$returnSignature"
    }

    private fun mapKotlinTypeToJNISignature(kotlinType: String): String {
        return when (kotlinType) {
            "Double" -> "D"
            "Int" -> "I"
            "Boolean" -> "Z"
            "Long" -> "J"
            "Float" -> "F"
            "String" -> "Ljava/lang/String;"
            "Unit" -> "V"
            else -> "Ljava/lang/Object;"
        }
    }

    private fun String.capitalize(): String {
        return this.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }
}
