{"version":3,"file":"getStructure.js","sourceRoot":"","sources":["../src/getStructure.ts"],"names":[],"mappings":"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","sourcesContent":["// convert requires above to imports\nimport { execSync } from 'child_process';\nimport fsNode from 'fs';\nimport { globSync } from 'glob';\nimport XML from 'xml-js';\nimport YAML from 'yaml';\n\nimport {\n  Closure,\n  CursorInfoOutput,\n  FileType,\n  FullyAnnotatedDecl,\n  OutputModuleDefinition,\n  OutputViewDefinition,\n  Structure,\n} from './types';\n\nconst rootDir = process.cwd();\nconst pattern = `${rootDir}/**/*.swift`;\n\nfunction getStructureFromFile(file: FileType) {\n  const command = 'sourcekitten structure --file ' + file.path;\n\n  try {\n    const output = execSync(command);\n    return JSON.parse(output.toString());\n  } catch (error) {\n    console.error('An error occurred while executing the command:', error);\n  }\n}\n// find an object with \"key.typename\" : \"ModuleDefinition\" somewhere in the structure and return it\nfunction findModuleDefinitionInStructure(structure: Structure): Structure[] | null {\n  if (!structure) {\n    return null;\n  }\n  if (structure?.['key.typename'] === 'ModuleDefinition') {\n    const root = structure?.['key.substructure'];\n    if (!root) {\n      console.warn('Found ModuleDefinition but it is malformed');\n    }\n    return root;\n  }\n  const substructure = structure['key.substructure'];\n  if (Array.isArray(substructure) && substructure.length > 0) {\n    for (const child of substructure) {\n      let result = null;\n      result = findModuleDefinitionInStructure(child);\n      if (result) {\n        return result;\n      }\n    }\n  }\n  return null;\n}\n\n// Read string straight from file â€“ needed since we can't get cursorinfo for modulename\nfunction getIdentifierFromOffsetObject(offsetObject: Structure, file: FileType) {\n  // adding 1 and removing 1 to get rid of quotes\n  return file.content\n    .substring(offsetObject['key.offset'], offsetObject['key.offset'] + offsetObject['key.length'])\n    .replaceAll('\"', '');\n}\n\nfunction maybeUnwrapXMLStructs(type: string | Partial<{ _text: string; 'ref.struct': string }>) {\n  if (!type) {\n    return type;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (type['_text']) {\n    return type['_text'];\n  }\n  if (type['ref.struct']) {\n    return maybeUnwrapXMLStructs(type['ref.struct']);\n  }\n  return type;\n}\n\nfunction maybeWrapArray<T>(itemOrItems: T[] | T | null) {\n  if (!itemOrItems) {\n    return null;\n  }\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems;\n  } else {\n    return [itemOrItems];\n  }\n}\n\nfunction parseXMLAnnotatedDeclarations(cursorInfoOutput: CursorInfoOutput) {\n  const xml = cursorInfoOutput['key.fully_annotated_decl'];\n  if (!xml) {\n    return null;\n  }\n  const parsed = XML.xml2js(xml, { compact: true }) as FullyAnnotatedDecl;\n\n  const parameters =\n    maybeWrapArray(parsed?.['decl.function.free']?.['decl.var.parameter'])?.map((p) => ({\n      name: maybeUnwrapXMLStructs(p['decl.var.parameter.argument_label']),\n      typename: maybeUnwrapXMLStructs(p['decl.var.parameter.type']),\n    })) ?? [];\n  const returnType = maybeUnwrapXMLStructs(\n    parsed?.['decl.function.free']?.['decl.function.returntype']\n  );\n  return { parameters, returnType };\n}\n\nlet cachedSDKPath: string | null = null;\nfunction getSDKPath() {\n  if (cachedSDKPath) {\n    return cachedSDKPath;\n  }\n  const sdkPath = execSync('xcrun --sdk iphoneos --show-sdk-path').toString().trim();\n  cachedSDKPath = sdkPath;\n  return cachedSDKPath;\n}\n\n// Read type description with sourcekitten, works only for variables\nfunction getTypeFromOffsetObject(offsetObject: Structure, file: FileType) {\n  if (!offsetObject) {\n    return null;\n  }\n  const request = {\n    'key.request': 'source.request.cursorinfo',\n    'key.sourcefile': file.path,\n    'key.offset': offsetObject['key.offset'],\n    'key.compilerargs': [file.path, '-target', 'arm64-apple-ios', '-sdk', getSDKPath()],\n  };\n  const yamlRequest = YAML.stringify(request, {\n    defaultStringType: 'QUOTE_DOUBLE',\n    lineWidth: 0,\n    defaultKeyType: 'PLAIN',\n    // needed since behaviour of sourcekitten is not consistent\n  } as any).replace('\"source.request.cursorinfo\"', 'source.request.cursorinfo');\n\n  const command = 'sourcekitten request --yaml \"' + yamlRequest.replaceAll('\"', '\\\\\"') + '\"';\n  try {\n    const output = execSync(command, { stdio: 'pipe' });\n    return parseXMLAnnotatedDeclarations(JSON.parse(output.toString()));\n  } catch (error) {\n    console.error('An error occurred while executing the command:', error);\n  }\n  return null;\n}\n\nfunction hasSubstructure(structureObject: Structure) {\n  return structureObject?.['key.substructure'] && structureObject['key.substructure'].length > 0;\n}\n\nfunction parseClosureTypes(structureObject: Structure) {\n  const closure = structureObject['key.substructure']?.find(\n    (s) => s['key.kind'] === 'source.lang.swift.expr.closure'\n  );\n  if (!closure) {\n    return null;\n  }\n  const parameters = closure['key.substructure']\n    ?.filter((s) => s['key.kind'] === 'source.lang.swift.decl.var.parameter')\n    .map((p) => ({ name: p['key.name'], typename: p['key.typename'] }));\n\n  const returnType = closure?.['key.typename'] ?? 'unknown';\n  return { parameters, returnType };\n}\n\n// Used for functions,async functions, all of shape Identifier(name, closure or function)\nfunction findNamedDefinitionsOfType(type: string, moduleDefinition: Structure[], file: FileType) {\n  const definitionsOfType = moduleDefinition.filter((md) => md['key.name'] === type);\n  return definitionsOfType.map((d) => {\n    const definitionParams = d['key.substructure'];\n    const name = getIdentifierFromOffsetObject(definitionParams[0], file);\n    let types = null;\n    if (hasSubstructure(definitionParams[1])) {\n      types = parseClosureTypes(definitionParams[1]);\n    } else {\n      types = getTypeFromOffsetObject(definitionParams[1], file);\n    }\n    return { name, types };\n  });\n}\n\n// Used for events\nfunction findGroupedDefinitionsOfType(type: string, moduleDefinition: Structure[], file: FileType) {\n  const definitionsOfType = moduleDefinition.filter((md) => md['key.name'] === type);\n  return definitionsOfType.flatMap((d) => {\n    const definitionParams = d['key.substructure'];\n    return definitionParams.map((d) => ({ name: getIdentifierFromOffsetObject(d, file) }));\n  });\n}\n\nfunction findAndParseView(\n  moduleDefinition: Structure[],\n  file: FileType\n): null | OutputViewDefinition {\n  const viewDefinition = moduleDefinition.find((md) => md['key.name'] === 'View');\n  if (!viewDefinition) {\n    return null;\n  }\n  // we support reading view definitions from closure only\n  const viewModuleDefinition =\n    viewDefinition['key.substructure']?.[1]?.['key.substructure']?.[0]?.['key.substructure']?.[0]?.[\n      'key.substructure'\n    ];\n  if (!viewModuleDefinition) {\n    console.warn('Could not parse view definition');\n    return null;\n  }\n  // let's drop nested view field (is null anyways)\n  const { view: _, ...definition } = parseModuleDefinition(viewModuleDefinition, file);\n  return definition;\n}\n\nfunction omitViewFromClosureArguments(definitions: Closure[]) {\n  return definitions.map((d) => ({\n    ...d,\n    types: {\n      ...d.types,\n      parameters: d.types?.parameters?.filter((t, idx) => idx !== 0 && t.name !== 'view'),\n    },\n  }));\n}\n\n// Some blocks have additional modifiers like runOnQueue â€“ we may need to do additional traversing to get to the function definition\nfunction parseBlockModifiers(structureObject: Structure) {\n  if (structureObject['key.name']?.includes('runOnQueue')) {\n    return structureObject['key.substructure'][0];\n  }\n  return structureObject;\n}\n\nfunction parseModuleDefinition(\n  moduleDefinition: Structure[],\n  file: FileType\n): OutputModuleDefinition {\n  const preparedModuleDefinition = moduleDefinition.map(parseBlockModifiers);\n  const parsedDefinition = {\n    name: findNamedDefinitionsOfType('Name', preparedModuleDefinition, file)?.[0]?.name,\n    functions: findNamedDefinitionsOfType('Function', preparedModuleDefinition, file),\n    asyncFunctions: findNamedDefinitionsOfType('AsyncFunction', preparedModuleDefinition, file),\n    events: findGroupedDefinitionsOfType('Events', preparedModuleDefinition, file),\n    properties: findNamedDefinitionsOfType('Property', preparedModuleDefinition, file),\n    props: omitViewFromClosureArguments(\n      findNamedDefinitionsOfType('Prop', preparedModuleDefinition, file)\n    ),\n    view: findAndParseView(preparedModuleDefinition, file),\n  };\n  return parsedDefinition;\n}\n\nfunction findModuleDefinitionsInFiles(files: string[]) {\n  const modules = [];\n  for (const path of files) {\n    const file = { path, content: fsNode.readFileSync(path, 'utf8') };\n    const definition = findModuleDefinitionInStructure(getStructureFromFile(file));\n    if (definition) {\n      modules.push(parseModuleDefinition(definition, file));\n    }\n  }\n  return modules;\n}\n\nexport function getAllExpoModulesInWorkingDirectory() {\n  const files = globSync(pattern);\n  return findModuleDefinitionsInFiles(files);\n}\n"]}