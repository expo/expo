{"version":3,"file":"mockgen.js","sourceRoot":"","sources":["../src/mockgen.ts"],"names":[],"mappings":";AACA,YAAY,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEb,4CAAoB;AACpB,gDAAwB;AACxB,mDAAqC;AACrC,4DAA4B;AAI5B,MAAM,aAAa,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;AAEpC;;;;;EAKE;AAEF,SAAS,YAAY,CAAC,IAAY;IAChC,sHAAsH;IACtH,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AACpD,CAAC;AACD,SAAS,qBAAqB,CAAC,IAAY;IACzC,MAAM,OAAO,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IACnC,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO,IAAI,CAAC;KACb;IACD,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACrD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,SAAS,eAAe,CAAC,IAAY;IACnC,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AAC5B,CAAC;AACD,SAAS,wBAAwB,CAAC,IAAY;IAC5C,MAAM,UAAU,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;IACzC,IAAI,CAAC,UAAU,EAAE;QACf,OAAO,IAAI,CAAC;KACb;IACD,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACrD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAY;IACrC,OAAO,CACL,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QACpB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;QAClB,yBAAyB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACnE,CAAC;AACJ,CAAC;AAED;;;;;EAKE;AACF,SAAS,yBAAyB,CAAC,IAAY;IAC7C,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC;IACpB,IAAI,iBAAiB,GAAG,CAAC,CAAC;IAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACpC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACnB,iBAAiB,EAAE,CAAC;SACrB;aAAM,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YAC1B,iBAAiB,EAAE,CAAC;SACrB;aAAM,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,iBAAiB,KAAK,CAAC,EAAE;YACrD,UAAU,GAAG,CAAC,CAAC;YACf,MAAM;SACP;KACF;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AACD,SAAS,qBAAqB,CAAC,IAAY;IACzC,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACrD,MAAM,aAAa,GAAG,yBAAyB,CAAC,SAAS,CAAC,CAAC;IAC3D,OAAO;QACL,GAAG,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,IAAI,EAAE;QAC7C,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE;KACjD,CAAC;AACJ,CAAC;AAUD;;;EAGE;AACF,SAAS,oBAAoB,CAAC,IAAY;IACxC,IAAI,CAAC,IAAI,EAAE;QACT,OAAO,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;KACpE;IACD,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QACzB,OAAO,oBAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC;YACpC,oBAAoB,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;YACpD,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC;SACjE,CAAC,CAAC;KACJ;IACD,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QAC3B,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC;QACnD,MAAM,OAAO,GAAG,oBAAoB,CAAC,GAAG,CAAC,CAAC;QAC1C,MAAM,SAAS,GAAG,oBAAoB,CAAC,KAAK,CAAC,CAAC;QAE9C,MAAM,cAAc,GAAG,oBAAE,CAAC,OAAO,CAAC,oBAAoB,CACpD,SAAS,EACT,CAAC,oBAAE,CAAC,OAAO,CAAC,0BAA0B,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,EACxF,SAAS,CACV,CAAC;QAEF,MAAM,eAAe,GAAG,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;QAC3E,OAAO,eAAe,CAAC;KACxB;IACD,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACtB,OAAO,oBAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,oBAAoB,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KAC1F;IACD,QAAQ,IAAI,EAAE;QACZ,iGAAiG;QACjG,KAAK,SAAS;YACZ,OAAO,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QACpE,KAAK,QAAQ;YACX,OAAO,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;QACvE,KAAK,MAAM;YACT,OAAO,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;QACxE,KAAK,KAAK,CAAC;QACX,KAAK,OAAO,CAAC;QACb,KAAK,QAAQ;YACX,OAAO,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;QACvE,KAAK,KAAK,EAAE,iBAAiB;YAC3B,OAAO,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QACpE,SAAS,uHAAuH;YAC9H,OAAO,oBAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;KACnD;AACH,CAAC;AAED,2EAA2E;AAC3E,SAAS,eAAe,CAAC,YAAoB;IAC3C,IAAI,CAAC,YAAY,EAAE;QACjB,OAAO,SAAS,CAAC;KAClB;IACD,QAAQ,YAAY,CAAC,IAAI,EAAE;QACzB,KAAK,oBAAE,CAAC,UAAU,CAAC,UAAU,CAAC;QAC9B,KAAK,oBAAE,CAAC,UAAU,CAAC,WAAW;YAC5B,OAAO,SAAS,CAAC;QACnB,KAAK,oBAAE,CAAC,UAAU,CAAC,SAAS;YAC1B,uHAAuH;YACvH,2CAA2C;YAC3C,OAAO,eAAe,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAW,CAAC,CAAC;QAC1D,KAAK,oBAAE,CAAC,UAAU,CAAC,aAAa;YAC9B,OAAO,oBAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;QAC5C,KAAK,oBAAE,CAAC,UAAU,CAAC,cAAc;YAC/B,OAAO,oBAAE,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;QAClC,KAAK,oBAAE,CAAC,UAAU,CAAC,aAAa;YAC9B,OAAO,oBAAE,CAAC,OAAO,CAAC,oBAAoB,CAAC,GAAG,CAAC,CAAC;QAC9C,KAAK,oBAAE,CAAC,UAAU,CAAC,SAAS;YAC1B,OAAO,oBAAE,CAAC,OAAO,CAAC,4BAA4B,EAAE,CAAC;QACnD,KAAK,oBAAE,CAAC,UAAU,CAAC,WAAW;YAC5B,2GAA2G;YAC3G,OAAO,oBAAE,CAAC,OAAO,CAAC,6BAA6B,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QAC7D,KAAK,oBAAE,CAAC,UAAU,CAAC,aAAa;YAC9B,2IAA2I;YAC3I,OAAO,oBAAE,CAAC,2BAA2B,CACnC,oBAAE,CAAC,OAAO,CAAC,UAAU,EAAE,EACvB,oBAAE,CAAC,UAAU,CAAC,uBAAuB,EACrC,8CACI,YAAoB,EAAE,QAAgB,EAAE,WAAW,IAAI,EAC3D,GAAG,CACJ,CAAC;KACL;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,SAAS,aAAa,CAAC,MAAmB;IACxC,OAAO,oBAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,SAAS,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;AACjE,CAAC;AAED,SAAS,4BAA4B,CAAC,MAAc;IAClD,IAAI,MAAM,CAAC,IAAI,KAAK,oBAAE,CAAC,UAAU,CAAC,UAAU,IAAI,MAAM,CAAC,IAAI,KAAK,oBAAE,CAAC,UAAU,CAAC,WAAW,EAAE;QACzF,OAAO,EAAE,CAAC;KACX;IACD,OAAO,CAAC,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACrE,CAAC;AAED;;EAEE;AACF,SAAS,kBAAkB,CAAC,SAAoB,EAAE,KAAK,GAAG,KAAK;IAC7D,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE;QACnC,MAAM,IAAI,GAAG,oBAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC3D,MAAM,UAAU,GAAG,oBAAoB,CAAC,WAAW,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;QACvE,MAAM,IAAI,GAAG,oBAAE,CAAC,OAAO,CAAC,yBAAyB,CAC/C;YACE,oBAAE,CAAC,OAAO,CAAC,WAAW,CAAC,oBAAE,CAAC,UAAU,CAAC,aAAa,CAAC;YACnD,KAAK,CAAC,CAAC,CAAC,oBAAE,CAAC,OAAO,CAAC,WAAW,CAAC,oBAAE,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,SAAS;SACvE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAA4B,EAC/C,SAAS,EACT,IAAI,EACJ,SAAS,EACT,WAAW,EAAE,KAAK,EAAE,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CACvC,oBAAE,CAAC,OAAO,CAAC,0BAA0B,CACnC,SAAS,EACT,SAAS,EACT,CAAC,CAAC,IAAI,EACN,SAAS,EACT,oBAAoB,CAAC,CAAC,CAAC,QAAQ,CAAC,EAChC,SAAS,CACV,CACF,IAAI,EAAE,EACP,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,EAC9C,oBAAE,CAAC,OAAO,CAAC,WAAW,CAAC,4BAA4B,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,CACvE,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;GAGG;AACH,SAAS,oBAAoB,CAAC,IAAa,EAAE,WAAqB;IAChE,IAAI,oBAAE,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE;QAChC,WAAW,CAAC,IAAI,CAAE,IAAI,CAAC,QAAgB,EAAE,WAAW,CAAC,CAAC;KACvD;IACD,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,oBAAoB,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC;AACjE,CAAC;AAED;;GAEG;AACH,SAAS,cAAc,CAAC,MAA8B;IACpD,MAAM,UAAU,GAAa,EAAE,CAAC;IAEhC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;SAClB,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAE,EAAc,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;SACtF,OAAO,CAAC,CAAC,KAA0B,EAAE,EAAE;QACtC,KAAK,EAAE,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE;YACzC,oBAAoB,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE,UAAU,CAAC,CAAC;QACnE,CAAC,CAAC,CAAC;QACH,KAAK,EAAE,UAAU;YACf,oBAAoB,CAAC,oBAAoB,CAAC,KAAK,EAAE,UAAU,CAAC,EAAE,UAAU,CAAC,CAAC;IAC9E,CAAC,CAAC,CAAC;IACL,OAAO,IAAI,GAAG,CAAC,UAAU,CAAC,CAAC;AAC7B,CAAC;AAED;;GAEG;AACH,SAAS,cAAc,CAAC,KAAkB;IACxC,OAAO,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;QACpC,MAAM,IAAI,GAAG,oBAAE,CAAC,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC/C,MAAM,SAAS,GAAG,oBAAE,CAAC,OAAO,CAAC,0BAA0B,CACrD,CAAC,oBAAE,CAAC,OAAO,CAAC,WAAW,CAAC,oBAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,EACrD,IAAI,EACJ,SAAS,EACT,oBAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAC3D,CAAC;QACF,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC,CAAC;AACL,CAAC;AAED,MAAM,MAAM,GAAG;;;;;CAKd,CAAC;AACF,SAAS,SAAS;IAChB,OAAO,CAAC,oBAAE,CAAC,OAAO,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC;AACjD,CAAC;AAED,SAAS,gBAAgB,CAAC,MAA8B,EAAE,YAAqB;IAC7E,OAAQ,EAAsE,CAAC,MAAM,CACnF,SAAS,EAAE,EACX,YAAY,CAAC,CAAC,CAAC,cAAc,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAC1D,kBAAkB,CAAC,MAAM,CAAC,SAAS,CAAC,EACpC,kBAAkB,CAAC,MAAM,CAAC,cAAc,EAAE,IAAI,CAAC,CAChD,CAAC;AACJ,CAAC;AAED,KAAK,UAAU,YAAY,CAAC,IAAY,EAAE,SAAiC,OAAO;IAChF,OAAO,MAAM,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE;QACjC,MAAM;QACN,QAAQ,EAAE,CAAC;QACX,UAAU,EAAE,GAAG;QACf,aAAa,EAAE,MAAM;QACrB,WAAW,EAAE,IAAI;KAClB,CAAC,CAAC;AACL,CAAC;AAEM,KAAK,UAAU,aAAa,CACjC,OAAiC,EACjC,iBAA8C,YAAY;IAE1D,MAAM,OAAO,GAAG,oBAAE,CAAC,aAAa,CAAC,EAAE,OAAO,EAAE,oBAAE,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC,CAAC;IAEvE,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE;QACvB,MAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC,cAAc,KAAK,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAC5E,MAAM,UAAU,GAAG,oBAAE,CAAC,gBAAgB,CACpC,QAAQ,EACR,EAAE,EACF,oBAAE,CAAC,YAAY,CAAC,MAAM,EACtB,KAAK,EACL,oBAAE,CAAC,UAAU,CAAC,GAAG,CAClB,CAAC;QACF,YAAE,CAAC,SAAS,CAAC,cAAI,CAAC,IAAI,CAAC,aAAa,EAAE,OAAO,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QACrE,MAAM,QAAQ,GAAG,cAAI,CAAC,IAAI,CAAC,aAAa,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC7D,kDAAkD;QAClD,MAAM,IAAI,GAAG,oBAAE,CAAC,OAAO,CAAC,eAAe,CAAC,gBAAgB,CAAC,CAAC,EAAE,cAAc,KAAK,YAAY,CAAC,CAAC,CAAC;QAC9F,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC,oBAAE,CAAC,UAAU,CAAC,SAAS,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;QAE/E,IAAI,cAAc,KAAK,YAAY,EAAE;YACnC,MAAM,UAAU,GAAG,oBAAE,CAAC,eAAe,CAAC,SAAS,EAAE;gBAC/C,eAAe,EAAE;oBACf,MAAM,EAAE,oBAAE,CAAC,UAAU,CAAC,MAAM;oBAC5B,MAAM,EAAE,oBAAE,CAAC,YAAY,CAAC,MAAM;iBAC/B;aACF,CAAC,CAAC,UAAU,CAAC;YACd,MAAM,YAAY,GAAG,MAAM,YAAY,CAAC,UAAU,CAAC,CAAC;YACpD,YAAE,CAAC,aAAa,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;SAC1C;aAAM;YACL,MAAM,YAAY,GAAG,MAAM,YAAY,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;YACjE,YAAE,CAAC,aAAa,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;SAC1C;KACF;AACH,CAAC;AAnCD,sCAmCC","sourcesContent":["#!/usr/bin/env node\n'use strict';\n\nimport fs from 'fs';\nimport path from 'path';\nimport * as prettier from 'prettier';\nimport ts from 'typescript';\n\nimport { Closure, ClosureTypes, OutputModuleDefinition } from './types';\n\nconst directoryPath = process.cwd();\n\n/*\nWe receive types from SourceKitten and `getStructure` like so (examples):\n[AcceptedTypes]?, UIColor?, [String: Any]\n\nWe need to parse them first to TS nodes in `mapSwiftTypeToTsType` with the following helper functions.\n*/\n\nfunction isSwiftArray(type: string) {\n  // This can also be an object, but we check that first, so if it's not an object and is wrapped with [] it's an array.\n  return type.startsWith('[') && type.endsWith(']');\n}\nfunction maybeUnwrapSwiftArray(type: string) {\n  const isArray = isSwiftArray(type);\n  if (!isArray) {\n    return type;\n  }\n  const innerType = type.substring(1, type.length - 1);\n  return innerType;\n}\n\nfunction isSwiftOptional(type: string) {\n  return type.endsWith('?');\n}\nfunction maybeUnwrapSwiftOptional(type: string) {\n  const isOptional = isSwiftOptional(type);\n  if (!isOptional) {\n    return type;\n  }\n  const innerType = type.substring(0, type.length - 1);\n  return innerType;\n}\n\nfunction isSwiftDictionary(type: string) {\n  return (\n    type.startsWith('[') &&\n    type.endsWith(']') &&\n    findRootColonInDictionary(type.substring(1, type.length - 1)) >= 0\n  );\n}\n\n/*\nThe Swift object type can have nested objects as the type of it's values (or maybe even keys).\n[String: [String: Any]]\n\nWe can't use regex to find the root colon, so this is the safest way – by counting brackets.\n*/\nfunction findRootColonInDictionary(type: string) {\n  let colonIndex = -1;\n  let openBracketsCount = 0;\n  for (let i = 0; i < type.length; i++) {\n    if (type[i] === '[') {\n      openBracketsCount++;\n    } else if (type[i] === ']') {\n      openBracketsCount--;\n    } else if (type[i] === ':' && openBracketsCount === 0) {\n      colonIndex = i;\n      break;\n    }\n  }\n  return colonIndex;\n}\nfunction unwrapSwiftDictionary(type: string) {\n  const innerType = type.substring(1, type.length - 1);\n  const colonPosition = findRootColonInDictionary(innerType);\n  return {\n    key: innerType.slice(0, colonPosition).trim(),\n    value: innerType.slice(colonPosition + 1).trim(),\n  };\n}\n\ntype TSNode =\n  | ts.UnionTypeNode\n  | ts.KeywordTypeNode\n  | ts.TypeReferenceNode\n  | ts.ArrayTypeNode\n  | ts.OptionalTypeNode\n  | ts.TypeLiteralNode;\n\n/*\nMain function that converts a string representation of a Swift type to a TypeScript compiler API node AST.\nWe can pass those types straight to a TypeScript printer (a function that converts AST to text).\n*/\nfunction mapSwiftTypeToTsType(type: string): TSNode {\n  if (!type) {\n    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword);\n  }\n  if (isSwiftOptional(type)) {\n    return ts.factory.createUnionTypeNode([\n      mapSwiftTypeToTsType(maybeUnwrapSwiftOptional(type)),\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),\n    ]);\n  }\n  if (isSwiftDictionary(type)) {\n    const { key, value } = unwrapSwiftDictionary(type);\n    const keyType = mapSwiftTypeToTsType(key);\n    const valueType = mapSwiftTypeToTsType(value);\n\n    const indexSignature = ts.factory.createIndexSignature(\n      undefined,\n      [ts.factory.createParameterDeclaration(undefined, undefined, 'key', undefined, keyType)],\n      valueType\n    );\n\n    const typeLiteralNode = ts.factory.createTypeLiteralNode([indexSignature]);\n    return typeLiteralNode;\n  }\n  if (isSwiftArray(type)) {\n    return ts.factory.createArrayTypeNode(mapSwiftTypeToTsType(maybeUnwrapSwiftArray(type)));\n  }\n  switch (type) {\n    // Our custom representation for types that we have no type hints for. Not necessairly Swift any.\n    case 'unknown':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    case 'String':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n    case 'Bool':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n    case 'Int':\n    case 'Float':\n    case 'Double':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n    case 'Any': // Swift Any type\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    default: // Custom Swift type (record) – for now mapped to a custom TS type exported at the top of the file by `getMockedTypes`.\n      return ts.factory.createTypeReferenceNode(type);\n  }\n}\n\n// Mocks require sample return values, so we generate them based on TS AST.\nfunction getMockLiterals(tsReturnType: TSNode) {\n  if (!tsReturnType) {\n    return undefined;\n  }\n  switch (tsReturnType.kind) {\n    case ts.SyntaxKind.AnyKeyword:\n    case ts.SyntaxKind.VoidKeyword:\n      return undefined;\n    case ts.SyntaxKind.UnionType:\n      // we take the first element of our union for the mock – we know the cast is correct since we create the type ourselves\n      // the second is `undefined` for optionals.\n      return getMockLiterals(tsReturnType.types[0] as TSNode);\n    case ts.SyntaxKind.StringKeyword:\n      return ts.factory.createStringLiteral('');\n    case ts.SyntaxKind.BooleanKeyword:\n      return ts.factory.createFalse();\n    case ts.SyntaxKind.NumberKeyword:\n      return ts.factory.createNumericLiteral('0');\n    case ts.SyntaxKind.ArrayType:\n      return ts.factory.createArrayLiteralExpression();\n    case ts.SyntaxKind.TypeLiteral:\n      // handles a dictionary, could be improved by creating an object fitting the schema instead of an empty one\n      return ts.factory.createObjectLiteralExpression([], false);\n    case ts.SyntaxKind.TypeReference:\n      // A fallback – we print a comment that these mocks are not fitting the custom type. Could be improved by expanding a set of default mocks.\n      return ts.addSyntheticTrailingComment(\n        ts.factory.createNull(),\n        ts.SyntaxKind.SingleLineCommentTrivia,\n        ` TODO: Replace with mock for value of type ${\n          ((tsReturnType as any)?.typeName as any)?.escapedText ?? ''\n        }.`\n      );\n  }\n  return undefined;\n}\n\nfunction wrapWithAsync(tsType: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode('Promise', [tsType]);\n}\n\nfunction maybeWrapWithReturnStatement(tsType: TSNode) {\n  if (tsType.kind === ts.SyntaxKind.AnyKeyword || tsType.kind === ts.SyntaxKind.VoidKeyword) {\n    return [];\n  }\n  return [ts.factory.createReturnStatement(getMockLiterals(tsType))];\n}\n\n/*\nWe iterate over a list of functions and we create TS AST for each of them.\n*/\nfunction getMockedFunctions(functions: Closure[], async = false) {\n  return functions.map((fnStructure) => {\n    const name = ts.factory.createIdentifier(fnStructure.name);\n    const returnType = mapSwiftTypeToTsType(fnStructure.types?.returnType);\n    const func = ts.factory.createFunctionDeclaration(\n      [\n        ts.factory.createToken(ts.SyntaxKind.ExportKeyword),\n        async ? ts.factory.createToken(ts.SyntaxKind.AsyncKeyword) : undefined,\n      ].filter((f) => !!f) as ts.ModifierToken<any>[],\n      undefined,\n      name,\n      undefined,\n      fnStructure?.types?.parameters.map((p) =>\n        ts.factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          p.name,\n          undefined,\n          mapSwiftTypeToTsType(p.typename),\n          undefined\n        )\n      ) ?? [],\n      async ? wrapWithAsync(returnType) : returnType,\n      ts.factory.createBlock(maybeWrapWithReturnStatement(returnType), true)\n    );\n    return func;\n  });\n}\n\n/**\n * Collect all type references used in any of the AST types to generate type aliases\n * e.g. type `[URL: string]?` will generate `type URL = any;`\n */\nfunction getAllTypeReferences(node: ts.Node, accumulator: string[]) {\n  if (ts.isTypeReferenceNode(node)) {\n    accumulator.push((node.typeName as any)?.escapedText);\n  }\n  node.forEachChild((n) => getAllTypeReferences(n, accumulator));\n}\n\n/**\n * Iterates over types to collect the aliases.\n */\nfunction getTypesToMock(module: OutputModuleDefinition) {\n  const foundTypes: string[] = [];\n\n  Object.values(module)\n    .flatMap((t) => (Array.isArray(t) ? t?.map((t2) => (t2 as Closure)?.types) : [] ?? []))\n    .forEach((types: ClosureTypes | null) => {\n      types?.parameters.forEach(({ typename }) => {\n        getAllTypeReferences(mapSwiftTypeToTsType(typename), foundTypes);\n      });\n      types?.returnType &&\n        getAllTypeReferences(mapSwiftTypeToTsType(types?.returnType), foundTypes);\n    });\n  return new Set(foundTypes);\n}\n\n/**\n * Gets a mock for a custom type.\n */\nfunction getMockedTypes(types: Set<string>) {\n  return Array.from(types).map((type) => {\n    const name = ts.factory.createIdentifier(type);\n    const typeAlias = ts.factory.createTypeAliasDeclaration(\n      [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      name,\n      undefined,\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n    );\n    return typeAlias;\n  });\n}\n\nconst prefix = `\nAutomatically generated by expo-modules-test-core.\n\nThis autogenerated file provides a mock for native Expo module,\nand works out of the box with the expo jest preset.\n`;\nfunction getPrefix() {\n  return [ts.factory.createJSDocComment(prefix)];\n}\n\nfunction getMockForModule(module: OutputModuleDefinition, includeTypes: boolean) {\n  return ([] as (ts.TypeAliasDeclaration | ts.FunctionDeclaration | ts.JSDoc)[]).concat(\n    getPrefix(),\n    includeTypes ? getMockedTypes(getTypesToMock(module)) : [],\n    getMockedFunctions(module.functions),\n    getMockedFunctions(module.asyncFunctions, true)\n  );\n}\n\nasync function prettifyCode(text: string, parser: 'babel' | 'typescript' = 'babel') {\n  return await prettier.format(text, {\n    parser,\n    tabWidth: 2,\n    printWidth: 100,\n    trailingComma: 'none',\n    singleQuote: true,\n  });\n}\n\nexport async function generateMocks(\n  modules: OutputModuleDefinition[],\n  outputLanguage: 'javascript' | 'typescript' = 'javascript'\n) {\n  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n  for (const m of modules) {\n    const filename = m.name + (outputLanguage === 'javascript' ? '.js' : '.ts');\n    const resultFile = ts.createSourceFile(\n      filename,\n      '',\n      ts.ScriptTarget.Latest,\n      false,\n      ts.ScriptKind.TSX\n    );\n    fs.mkdirSync(path.join(directoryPath, 'mocks'), { recursive: true });\n    const filePath = path.join(directoryPath, 'mocks', filename);\n    // get ts nodearray from getMockForModule(m) array\n    const mock = ts.factory.createNodeArray(getMockForModule(m, outputLanguage === 'typescript'));\n    const printedTs = printer.printList(ts.ListFormat.MultiLine, mock, resultFile);\n\n    if (outputLanguage === 'javascript') {\n      const compiledJs = ts.transpileModule(printedTs, {\n        compilerOptions: {\n          module: ts.ModuleKind.ESNext,\n          target: ts.ScriptTarget.ESNext,\n        },\n      }).outputText;\n      const prettifiedJs = await prettifyCode(compiledJs);\n      fs.writeFileSync(filePath, prettifiedJs);\n    } else {\n      const prettifiedTs = await prettifyCode(printedTs, 'typescript');\n      fs.writeFileSync(filePath, prettifiedTs);\n    }\n  }\n}\n"]}