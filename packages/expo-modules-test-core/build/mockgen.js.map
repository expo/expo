{"version":3,"file":"mockgen.js","sourceRoot":"","sources":["../src/mockgen.ts"],"names":[],"mappings":"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","sourcesContent":["#!/usr/bin/env node\n'use strict';\n\nimport fs from 'fs';\nimport path from 'path';\nimport * as prettier from 'prettier';\nimport ts from 'typescript';\n\nimport {\n  Closure,\n  ClosureTypes,\n  OutputModuleDefinition,\n  OutputNestedClassDefinition,\n} from './types';\n\nconst directoryPath = process.cwd();\n\n/*\nWe receive types from SourceKitten and `getStructure` like so (examples):\n[AcceptedTypes]?, UIColor?, [String: Any]\n\nWe need to parse them first to TS nodes in `mapSwiftTypeToTsType` with the following helper functions.\n*/\n\nfunction isSwiftArray(type: string) {\n  // This can also be an object, but we check that first, so if it's not an object and is wrapped with [] it's an array.\n  return type.startsWith('[') && type.endsWith(']');\n}\nfunction maybeUnwrapSwiftArray(type: string) {\n  const isArray = isSwiftArray(type);\n  if (!isArray) {\n    return type;\n  }\n  const innerType = type.substring(1, type.length - 1);\n  return innerType;\n}\n\nfunction isSwiftOptional(type: string) {\n  return type.endsWith('?');\n}\nfunction maybeUnwrapSwiftOptional(type: string) {\n  const isOptional = isSwiftOptional(type);\n  if (!isOptional) {\n    return type;\n  }\n  const innerType = type.substring(0, type.length - 1);\n  return innerType;\n}\n\nfunction isSwiftDictionary(type: string) {\n  return (\n    type.startsWith('[') &&\n    type.endsWith(']') &&\n    findRootColonInDictionary(type.substring(1, type.length - 1)) >= 0\n  );\n}\n\nfunction isEither(type: string) {\n  return type.startsWith('Either<');\n}\n// \"Either<TypeOne, TypeTwo>\" -> [\"TypeOne\", \"TypeTwo\"]\nfunction maybeUnwrapEither(type: string): string[] {\n  if (!isEither(type)) {\n    return [type];\n  }\n  const innerType = type.substring(7, type.length - 1);\n  return innerType.split(',').map((t) => t.trim());\n}\n\n/*\nThe Swift object type can have nested objects as the type of it's values (or maybe even keys).\n[String: [String: Any]]\n\nWe can't use regex to find the root colon, so this is the safest way – by counting brackets.\n*/\nfunction findRootColonInDictionary(type: string) {\n  let colonIndex = -1;\n  let openBracketsCount = 0;\n  for (let i = 0; i < type.length; i++) {\n    if (type[i] === '[') {\n      openBracketsCount++;\n    } else if (type[i] === ']') {\n      openBracketsCount--;\n    } else if (type[i] === ':' && openBracketsCount === 0) {\n      colonIndex = i;\n      break;\n    }\n  }\n  return colonIndex;\n}\nfunction unwrapSwiftDictionary(type: string) {\n  const innerType = type.substring(1, type.length - 1);\n  const colonPosition = findRootColonInDictionary(innerType);\n  return {\n    key: innerType.slice(0, colonPosition).trim(),\n    value: innerType.slice(colonPosition + 1).trim(),\n  };\n}\n\ntype TSNode =\n  | ts.UnionTypeNode\n  | ts.KeywordTypeNode\n  | ts.TypeReferenceNode\n  | ts.ArrayTypeNode\n  | ts.OptionalTypeNode\n  | ts.TypeLiteralNode;\n\n/*\nMain function that converts a string representation of a Swift type to a TypeScript compiler API node AST.\nWe can pass those types straight to a TypeScript printer (a function that converts AST to text).\n*/\nfunction mapSwiftTypeToTsType(type: string): TSNode {\n  if (!type) {\n    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword);\n  }\n  if (isSwiftOptional(type)) {\n    return ts.factory.createUnionTypeNode([\n      mapSwiftTypeToTsType(maybeUnwrapSwiftOptional(type)),\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),\n    ]);\n  }\n  if (isSwiftDictionary(type)) {\n    const { key, value } = unwrapSwiftDictionary(type);\n    const keyType = mapSwiftTypeToTsType(key);\n    const valueType = mapSwiftTypeToTsType(value);\n\n    const indexSignature = ts.factory.createIndexSignature(\n      undefined,\n      [ts.factory.createParameterDeclaration(undefined, undefined, 'key', undefined, keyType)],\n      valueType\n    );\n\n    const typeLiteralNode = ts.factory.createTypeLiteralNode([indexSignature]);\n    return typeLiteralNode;\n  }\n  if (isSwiftArray(type)) {\n    return ts.factory.createArrayTypeNode(mapSwiftTypeToTsType(maybeUnwrapSwiftArray(type)));\n  }\n  // Custom handling for the Either convertible\n  if (isEither(type)) {\n    return ts.factory.createUnionTypeNode(\n      maybeUnwrapEither(type).map((t) => mapSwiftTypeToTsType(t))\n    );\n  }\n\n  switch (type) {\n    // Our custom representation for types that we have no type hints for. Not necessairly Swift any.\n    case 'unknown':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    case 'String':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n    case 'Bool':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n    case 'Int':\n    case 'Float':\n    case 'Double':\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n    case 'Any': // Swift Any type\n      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    default: // Custom Swift type (record) – for now mapped to a custom TS type exported at the top of the file by `getMockedTypes`.\n      return ts.factory.createTypeReferenceNode(type);\n  }\n}\n\n// Mocks require sample return values, so we generate them based on TS AST.\nfunction getMockLiterals(tsReturnType: TSNode) {\n  if (!tsReturnType) {\n    return undefined;\n  }\n  switch (tsReturnType.kind) {\n    case ts.SyntaxKind.AnyKeyword:\n    case ts.SyntaxKind.VoidKeyword:\n      return undefined;\n    case ts.SyntaxKind.UnionType:\n      // we take the first element of our union for the mock – we know the cast is correct since we create the type ourselves\n      // the second is `undefined` for optionals.\n      return getMockLiterals(tsReturnType.types[0] as TSNode);\n    case ts.SyntaxKind.StringKeyword:\n      return ts.factory.createStringLiteral('');\n    case ts.SyntaxKind.BooleanKeyword:\n      return ts.factory.createFalse();\n    case ts.SyntaxKind.NumberKeyword:\n      return ts.factory.createNumericLiteral('0');\n    case ts.SyntaxKind.ArrayType:\n      return ts.factory.createArrayLiteralExpression();\n    case ts.SyntaxKind.TypeLiteral:\n      // handles a dictionary, could be improved by creating an object fitting the schema instead of an empty one\n      return ts.factory.createObjectLiteralExpression([], false);\n  }\n  return undefined;\n}\n\nfunction wrapWithAsync(tsType: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode('Promise', [tsType]);\n}\n\nfunction maybeWrapWithReturnStatement(tsType: TSNode) {\n  if (tsType.kind === ts.SyntaxKind.AnyKeyword || tsType.kind === ts.SyntaxKind.VoidKeyword) {\n    return [];\n  }\n  if (tsType.kind === ts.SyntaxKind.TypeReference) {\n    // A fallback – we print a comment that these mocks are not fitting the custom type. Could be improved by expanding a set of default mocks.\n    return [\n      ts.addSyntheticTrailingComment(\n        ts.factory.createReturnStatement(ts.factory.createNull()),\n        ts.SyntaxKind.SingleLineCommentTrivia,\n        ` TODO: Replace with mock for value of type ${\n          ((tsType as any)?.typeName as any)?.escapedText ?? ''\n        }.`\n      ),\n    ];\n  }\n  return [ts.factory.createReturnStatement(getMockLiterals(tsType))];\n}\n\n/*\nWe iterate over a list of functions and we create TS AST for each of them.\n*/\nfunction getMockedFunctions(functions: Closure[], { async = false, classMethod = false } = {}) {\n  return functions.map((fnStructure) => {\n    const name = ts.factory.createIdentifier(fnStructure.name);\n    const returnType = mapSwiftTypeToTsType(fnStructure.types?.returnType);\n    const parameters =\n      fnStructure?.types?.parameters.map((p) =>\n        ts.factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          p.name ?? '_',\n          undefined,\n          mapSwiftTypeToTsType(p.typename),\n          undefined\n        )\n      ) ?? [];\n    const returnBlock = ts.factory.createBlock(maybeWrapWithReturnStatement(returnType), true);\n\n    if (classMethod) {\n      return ts.factory.createMethodDeclaration(\n        [async ? ts.factory.createToken(ts.SyntaxKind.AsyncKeyword) : undefined].flatMap((f) =>\n          f ? [f] : []\n        ),\n        undefined,\n        name,\n        undefined,\n        undefined,\n        parameters,\n        async ? wrapWithAsync(returnType) : returnType,\n        returnBlock\n      );\n    }\n    const func = ts.factory.createFunctionDeclaration(\n      [\n        ts.factory.createToken(ts.SyntaxKind.ExportKeyword),\n        async ? ts.factory.createToken(ts.SyntaxKind.AsyncKeyword) : undefined,\n      ].flatMap((f) => (f ? [f] : [])),\n      undefined,\n      name,\n      undefined,\n      parameters,\n      async ? wrapWithAsync(returnType) : returnType,\n      returnBlock\n    );\n    return func;\n  });\n}\n\n/**\n * Collect all type references used in any of the AST types to generate type aliases\n * e.g. type `[URL: string]?` will generate `type URL = any;`\n */\nfunction getAllTypeReferences(node: ts.Node, accumulator: string[]) {\n  if (ts.isTypeReferenceNode(node)) {\n    accumulator.push((node.typeName as any)?.escapedText);\n  }\n  node.forEachChild((n) => getAllTypeReferences(n, accumulator));\n}\n\n/**\n * Iterates over types to collect the aliases.\n */\nfunction getTypesToMock(module: OutputModuleDefinition | OutputNestedClassDefinition) {\n  const foundTypes: string[] = [];\n\n  Object.values(module)\n    .flatMap((t) => (Array.isArray(t) ? t?.map((t2) => (t2 as Closure)?.types) : [] ?? []))\n    .forEach((types: ClosureTypes | null) => {\n      types?.parameters.forEach(({ typename }) => {\n        getAllTypeReferences(mapSwiftTypeToTsType(typename), foundTypes);\n      });\n      types?.returnType &&\n        getAllTypeReferences(mapSwiftTypeToTsType(types?.returnType), foundTypes);\n    });\n  return new Set(foundTypes);\n}\n\n/**\n * Gets a mock for a custom type.\n */\nfunction getMockedTypes(types: Set<string>) {\n  return Array.from(types).map((type) => {\n    const name = ts.factory.createIdentifier(type);\n    const typeAlias = ts.factory.createTypeAliasDeclaration(\n      [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      name,\n      undefined,\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n    );\n    return typeAlias;\n  });\n}\n\nconst prefix = `Automatically generated by expo-modules-test-core.\n\nThis autogenerated file provides a mock for native Expo module,\nand works out of the box with the expo jest preset.\n`;\nfunction getPrefix() {\n  return [ts.factory.createJSDocComment(prefix)];\n}\n\nfunction generatePropTypesForDefinition(definition: OutputNestedClassDefinition) {\n  return ts.factory.createTypeAliasDeclaration(\n    [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],\n    'ViewProps',\n    undefined,\n    ts.factory.createTypeLiteralNode([\n      ...definition.props.map((p) => {\n        const propType = mapSwiftTypeToTsType(p.types.parameters[0].typename);\n        return ts.factory.createPropertySignature(undefined, p.name, undefined, propType);\n      }),\n      ...definition.events.map((e) => {\n        const eventType = ts.factory.createFunctionTypeNode(\n          undefined,\n          [\n            ts.factory.createParameterDeclaration(\n              undefined,\n              undefined,\n              'event',\n              undefined,\n              ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)\n            ),\n          ],\n          ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword)\n        );\n        return ts.factory.createPropertySignature(undefined, e.name, undefined, eventType);\n      }),\n    ])\n  );\n}\n/*\nGenerate a mock for view props and functions.\n*/\nfunction getMockedViews(viewDefinitions: OutputNestedClassDefinition[]) {\n  return viewDefinitions.flatMap((definition) => {\n    if (!definition) {\n      return [];\n    }\n    const propsType = generatePropTypesForDefinition(definition);\n    const props = ts.factory.createParameterDeclaration(\n      undefined,\n      undefined,\n      'props',\n      undefined,\n      ts.factory.createTypeReferenceNode('ViewProps', undefined),\n      undefined\n    );\n    const viewFunction = ts.factory.createFunctionDeclaration(\n      [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      undefined,\n      // TODO: Handle this better once requireNativeViewManager accepts view name or a different solution for multiple views is built.\n      viewDefinitions.length === 1 ? 'View' : definition.name,\n      undefined,\n      [props],\n      undefined,\n      ts.factory.createBlock([])\n    );\n    return [propsType, viewFunction];\n  });\n}\n\nfunction getMockedClass(def: OutputNestedClassDefinition) {\n  const classDecl = ts.factory.createClassDeclaration(\n    [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],\n    ts.factory.createIdentifier(def.name),\n    undefined,\n    undefined,\n    [\n      ...getMockedFunctions(def.functions, { classMethod: true }),\n      ...getMockedFunctions(def.asyncFunctions, { async: true, classMethod: true }),\n    ] as ts.MethodDeclaration[]\n  );\n  return classDecl;\n}\n\nfunction getMockedClasses(def: OutputNestedClassDefinition[]) {\n  return def.map((d) => getMockedClass(d));\n}\n\nconst newlineIdentifier = ts.factory.createIdentifier('\\n\\n') as any;\nfunction separateWithNewlines<T>(arr: T) {\n  return [arr, newlineIdentifier];\n}\n\nfunction omitFromSet(set: Set<string>, toOmit: (string | undefined)[]) {\n  const newSet = new Set(set);\n  toOmit.forEach((item) => {\n    if (item) {\n      newSet.delete(item);\n    }\n  });\n  return newSet;\n}\n\nfunction getMockForModule(module: OutputModuleDefinition, includeTypes: boolean) {\n  return (\n    [] as (ts.TypeAliasDeclaration | ts.FunctionDeclaration | ts.JSDoc | ts.ClassDeclaration)[]\n  )\n    .concat(\n      getPrefix(),\n      newlineIdentifier,\n      includeTypes\n        ? getMockedTypes(\n            omitFromSet(\n              new Set([\n                ...getTypesToMock(module),\n                ...new Set(...module.views.map((v) => getTypesToMock(v))),\n                ...new Set(...module.classes.map((c) => getTypesToMock(c))),\n              ]),\n              // Ignore all types that are actually native classes\n              [\n                module.name,\n                ...module.views.map((c) => c.name),\n                ...module.classes.map((c) => c.name),\n              ]\n            )\n          )\n        : [],\n      newlineIdentifier,\n      getMockedFunctions(module.functions) as ts.FunctionDeclaration[],\n      getMockedFunctions(module.asyncFunctions, { async: true }) as ts.FunctionDeclaration[],\n      newlineIdentifier,\n      getMockedViews(module.views),\n      getMockedClasses(module.classes)\n    )\n    .flatMap(separateWithNewlines);\n}\n\nasync function prettifyCode(text: string, parser: 'babel' | 'typescript' = 'babel') {\n  return await prettier.format(text, {\n    parser,\n    tabWidth: 2,\n    printWidth: 100,\n    trailingComma: 'none',\n    singleQuote: true,\n  });\n}\n\nexport async function generateMocks(\n  modules: OutputModuleDefinition[],\n  outputLanguage: 'javascript' | 'typescript' = 'javascript'\n) {\n  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\n  for (const m of modules) {\n    const filename = m.name + (outputLanguage === 'javascript' ? '.js' : '.ts');\n    const resultFile = ts.createSourceFile(\n      filename,\n      '',\n      ts.ScriptTarget.Latest,\n      false,\n      ts.ScriptKind.TSX\n    );\n    fs.mkdirSync(path.join(directoryPath, 'mocks'), { recursive: true });\n    const filePath = path.join(directoryPath, 'mocks', filename);\n    // get ts nodearray from getMockForModule(m) array\n    const mock = ts.factory.createNodeArray(getMockForModule(m, outputLanguage === 'typescript'));\n    const printedTs = printer.printList(\n      ts.ListFormat.MultiLine + ts.ListFormat.PreserveLines,\n      mock,\n      resultFile\n    );\n\n    if (outputLanguage === 'javascript') {\n      const compiledJs = ts.transpileModule(printedTs, {\n        compilerOptions: {\n          module: ts.ModuleKind.ESNext,\n          target: ts.ScriptTarget.ESNext,\n        },\n      }).outputText;\n      const prettifiedJs = await prettifyCode(compiledJs);\n      fs.writeFileSync(filePath, prettifiedJs);\n    } else {\n      const prettifiedTs = await prettifyCode(printedTs, 'typescript');\n      fs.writeFileSync(filePath, prettifiedTs);\n    }\n  }\n}\n"]}