{"version":3,"file":"MagneticObject.js","sourceRoot":"","sources":["../../src/AR/MagneticObject.ts"],"names":[],"mappings":"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","sourcesContent":["import * as THREE from 'three';\nimport {\n  positionFromTransform,\n  worldPositionFromScreenPosition,\n} from './calculations';\n\n//TODO: Evan: Vertical support\n\n\nclass MagneticObject extends THREE.Object3D {\n  // use average of recent positions to avoid jitter\n  recentMagneticPositions: THREE.Vector3[] = [];\n  anchorsOfVisitedPlanes: any[] = [];\n\n  maintainScale = true;\n  maintainRotation = true;\n\n  constructor() {\n    super();\n    // this.visible = false;\n    this.recentMagneticPositions = [];\n    this.anchorsOfVisitedPlanes = [];\n  }\n\n  updateForAnchor = (position, planeAnchor, camera) => {\n    if (planeAnchor != null) {\n      this.anchorsOfVisitedPlanes.unshift(planeAnchor);\n      // TODO: Move in direction\n      // this.visible = false;\n    } else {\n      // this.visible = true;\n    }\n    this.updateTransform(position, camera);\n  };\n\n  update = async (camera, screenPosition) => {\n    const { worldPosition, planeAnchor } = await worldPositionFromScreenPosition(\n      camera,\n      screenPosition,\n      this.position\n    );\n    if (worldPosition) {\n      this.updateForAnchor(worldPosition, planeAnchor, camera);\n    }\n  };\n\n  isValidVector = vector =>\n    vector && !isNaN(vector.x) && !isNaN(vector.y) && !isNaN(vector.z);\n\n  updateTransform = (position, camera) => {\n    if (!this.isValidVector(position)) {\n      return;\n    }\n    // add to list of recent positions\n    this.recentMagneticPositions.push(position);\n\n    // remove anything older than the last 8\n    while (this.recentMagneticPositions.length > 8) {\n      this.recentMagneticPositions.shift();\n    }\n\n    // move to average of recent positions to avoid jitter\n\n    if (this.recentMagneticPositions.length > 4) {\n      const { length } = this.recentMagneticPositions;\n      let average = new THREE.Vector3();\n\n      for (let position of this.recentMagneticPositions) {\n        average.add(position);\n      }\n      average.divide(new THREE.Vector3(length, length, length));\n      this.position.set(average.x, average.y, average.z);\n\n      if (this.maintainScale) {\n        const scale = this.scaleBasedOnDistance(camera);\n        this.scale.set(scale, scale, scale);\n      } else {\n        this.scale.set(1, 1, 1);\n      }\n    }\n\n    if (this.maintainRotation) {\n      // Correct y rotation of camera square\n      if (camera) {\n        let cameraQuaternion = new THREE.Quaternion();\n        camera.getWorldQuaternion(cameraQuaternion);\n\n        let cameraEuler = new THREE.Euler();\n        cameraEuler.setFromQuaternion(cameraQuaternion, 'YZX');\n\n        const tilt = Math.abs(cameraEuler.x);\n        const threshold1 = (Math.PI / 2) * 0.65;\n        const threshold2 = (Math.PI / 2) * 0.75;\n        const yaw = Math.atan2(\n          camera.matrixWorld.elements[0],\n          camera.matrixWorld.elements[1]\n        );\n        let angle = 0;\n\n        if (tilt >= 0 || tilt < threshold1) {\n          angle = cameraEuler.y;\n        } else if (tilt >= threshold1 || tilt < threshold2) {\n          const relativeInRange = Math.abs(\n            (tilt - threshold1) / (threshold2 - threshold1)\n          );\n          const normalizedY = this.normalize(cameraEuler.y, yaw);\n          angle = normalizedY * (1 - relativeInRange) + yaw * relativeInRange;\n        } else {\n          angle = yaw;\n        }\n        this.setRotationFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);\n      }\n    }\n  };\n\n  normalize = (angle, ref) => {\n    // Normalize angle in steps of 90 degrees such that the rotation to the other angle is minimal\n    let normalized = angle;\n    while (Math.abs(normalized - ref) > Math.PI / 4) {\n      if (angle > ref) {\n        normalized -= Math.PI / 2;\n      } else {\n        normalized += Math.PI / 2;\n      }\n    }\n    return normalized;\n  };\n\n  get worldPosition() {\n    let worldPosition = new THREE.Vector3();\n    this.getWorldPosition(worldPosition);\n    return worldPosition;\n  }\n\n  scaleBasedOnDistance = camera => {\n    if (camera) {\n      const cameraPosition = positionFromTransform(camera.matrixWorld);\n\n      const delta = this.position.clone().sub(cameraPosition);\n      let distanceFromCamera = delta.length();\n      // console.log('distanceFromCamera', cameraPosition, this.position, distanceFromCamera);\n\n      // From Apple:\n      // Reduce size changes of the node based on the distance by scaling it up if it is far away,\n      // and down if it is very close.\n      // The values are adjusted such that scale will be 1 in 0.7 m distance (estimated distance when looking at a table),\n      // and 1.2 in 1.5 m distance (estimated distance when looking at the floor).\n      let newScale =\n        distanceFromCamera < 0.7\n          ? distanceFromCamera / 0.7\n          : 0.25 * distanceFromCamera + 0.825;\n\n      return newScale;\n    }\n    return 1.0;\n  };\n}\n\nexport default MagneticObject;\n"]}