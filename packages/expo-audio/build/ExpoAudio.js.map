{"version":3,"file":"ExpoAudio.js","sourceRoot":"","sources":["../src/ExpoAudio.ts"],"names":[],"mappings":"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","sourcesContent":["import { useEvent } from 'expo';\nimport { PermissionResponse, useReleasingSharedObject } from 'expo-modules-core';\nimport { useEffect, useState, useMemo } from 'react';\nimport { Platform } from 'react-native';\n\nimport {\n  AudioMode,\n  AudioPlayerOptions,\n  AudioSource,\n  AudioStatus,\n  PitchCorrectionQuality,\n  RecorderState,\n  RecordingOptions,\n  RecordingStartOptions,\n  RecordingStatus,\n} from './Audio.types';\nimport {\n  AUDIO_SAMPLE_UPDATE,\n  PLAYBACK_STATUS_UPDATE,\n  RECORDING_STATUS_UPDATE,\n} from './AudioEventKeys';\nimport AudioModule from './AudioModule';\nimport { AudioPlayer, AudioRecorder, AudioSample } from './AudioModule.types';\nimport { createRecordingOptions } from './utils/options';\nimport { resolveSource, resolveSourceWithDownload } from './utils/resolveSource';\n\n// TODO: Temporary solution until we develop a way of overriding prototypes that won't break the lazy loading of the module.\nconst replace = AudioModule.AudioPlayer.prototype.replace;\nAudioModule.AudioPlayer.prototype.replace = function (source: AudioSource) {\n  return replace.call(this, resolveSource(source));\n};\n\nconst setPlaybackRate = AudioModule.AudioPlayer.prototype.setPlaybackRate;\nAudioModule.AudioPlayer.prototype.setPlaybackRate = function (\n  rate: number,\n  pitchCorrectionQuality?: PitchCorrectionQuality\n) {\n  if (Platform.OS === 'android') {\n    return setPlaybackRate.call(this, rate);\n  } else {\n    return setPlaybackRate.call(this, rate, pitchCorrectionQuality);\n  }\n};\n\n// Audio recording prototypes should not be shimmed on tvOS, where they do not exist\nif (!Platform.isTV || Platform.OS !== 'ios') {\n  const prepareToRecordAsync = AudioModule.AudioRecorder.prototype.prepareToRecordAsync;\n  AudioModule.AudioRecorder.prototype.prepareToRecordAsync = function (options?: RecordingOptions) {\n    const processedOptions = options ? createRecordingOptions(options) : undefined;\n    return prepareToRecordAsync.call(this, processedOptions);\n  };\n\n  const record = AudioModule.AudioRecorder.prototype.record;\n  AudioModule.AudioRecorder.prototype.record = function (options?: RecordingStartOptions) {\n    return record.call(this, options);\n  };\n}\n\n/**\n * Creates an `AudioPlayer` instance that automatically releases when the component unmounts.\n *\n * This hook manages the player's lifecycle and ensures it's properly disposed when no longer needed.\n * The player will start loading the audio source immediately upon creation.\n *\n * @param source The audio source to load. Can be a local asset via `require()`, a remote URL, or null for no initial source.\n * @param options Audio player configuration options.\n * @returns An `AudioPlayer` instance that's automatically managed by the component lifecycle.\n *\n * @example\n * ```tsx\n * import { useAudioPlayer } from 'expo-audio';\n *\n * function MyComponent() {\n *   const player = useAudioPlayer(require('./sound.mp3'));\n *\n *   return (\n *     <Button title=\"Play\" onPress={() => player.play()} />\n *   );\n * }\n * ```\n *\n * @example Using downloadFirst\n * ```tsx\n * import { useAudioPlayer } from 'expo-audio';\n *\n * function MyComponent() {\n *   const player = useAudioPlayer('https://example.com/audio.mp3', {\n *     updateInterval: 1000,\n *     downloadFirst: true,\n *   });\n *\n *   return (\n *     <Button title=\"Play\" onPress={() => player.play()} />\n *   );\n * }\n * ```\n */\nexport function useAudioPlayer(\n  source: AudioSource = null,\n  options: AudioPlayerOptions = {}\n): AudioPlayer {\n  const { updateInterval = 500, downloadFirst = false, keepAudioSessionActive = false } = options;\n\n  // If downloadFirst is true, we don't need to resolve the source, because it will be resolved in the useEffect below.\n  // If downloadFirst is false, we resolve the source here.\n  // we call .replace() in the useEffect below to replace the source with the downloaded one.\n  const initialSource = useMemo(() => {\n    return downloadFirst ? null : resolveSource(source);\n  }, [JSON.stringify(source), downloadFirst]);\n\n  const player = useReleasingSharedObject(\n    () => new AudioModule.AudioPlayer(initialSource, updateInterval, keepAudioSessionActive),\n    [JSON.stringify(initialSource), updateInterval, keepAudioSessionActive]\n  );\n\n  // Handle async source resolution for downloadFirst\n  useEffect(() => {\n    if (!downloadFirst || source === null) {\n      return;\n    }\n\n    let isCancelled = false;\n\n    // We resolve the source with expo-asset and replace the player's source with the downloaded one.\n    async function resolveAndReplaceSource() {\n      try {\n        const resolved = await resolveSourceWithDownload(source);\n\n        if (\n          !isCancelled &&\n          resolved &&\n          JSON.stringify(resolved) !== JSON.stringify(initialSource)\n        ) {\n          player.replace(resolved);\n        }\n      } catch (error) {\n        if (!isCancelled) {\n          console.warn('expo-audio: Failed to download source, using original:', error);\n        }\n      }\n    }\n\n    resolveAndReplaceSource();\n\n    return () => {\n      isCancelled = true;\n    };\n  }, [player, JSON.stringify(source), downloadFirst]);\n\n  return player;\n}\n\n/**\n * Hook that provides real-time playback status updates for an `AudioPlayer`.\n *\n * This hook automatically subscribes to playback status changes and returns the current status.\n * The status includes information about playback state, current time, duration, loading state, and more.\n *\n * @param player The `AudioPlayer` instance to monitor.\n * @returns The current `AudioStatus` object containing playback information.\n *\n * @example\n * ```tsx\n * import { useAudioPlayer, useAudioPlayerStatus } from 'expo-audio';\n *\n * function PlayerComponent() {\n *   const player = useAudioPlayer(require('./sound.mp3'));\n *   const status = useAudioPlayerStatus(player);\n *\n *   return (\n *     <View>\n *       <Text>Playing: {status.isPlaying ? 'Yes' : 'No'}</Text>\n *       <Text>Current Time: {status.currentTime}s</Text>\n *       <Text>Duration: {status.duration}s</Text>\n *     </View>\n *   );\n * }\n * ```\n */\nexport function useAudioPlayerStatus(player: AudioPlayer): AudioStatus {\n  const currentStatus = useMemo(() => player.currentStatus, [player.id]);\n  return useEvent(player, PLAYBACK_STATUS_UPDATE, currentStatus);\n}\n\n/**\n * Hook that sets up audio sampling for an `AudioPlayer` and calls a listener with audio data.\n *\n * This hook enables audio sampling on the player (if supported) and subscribes to audio sample updates.\n * Audio sampling provides real-time access to audio waveform data for visualization or analysis.\n *\n * > **Note:** Audio sampling requires `RECORD_AUDIO` permission on Android and is not supported on all platforms.\n *\n * @param player The `AudioPlayer` instance to sample audio from.\n * @param listener Function called with each audio sample containing waveform data.\n *\n * @example\n * ```tsx\n * import { useAudioPlayer, useAudioSampleListener } from 'expo-audio';\n *\n * function AudioVisualizerComponent() {\n *   const player = useAudioPlayer(require('./music.mp3'));\n *\n *   useAudioSampleListener(player, (sample) => {\n *     // Use sample.channels array for audio visualization\n *     console.log('Audio sample:', sample.channels[0].frames);\n *   });\n *\n *   return <AudioWaveform player={player} />;\n * }\n * ```\n */\nexport function useAudioSampleListener(player: AudioPlayer, listener: (data: AudioSample) => void) {\n  useEffect(() => {\n    if (!player.isAudioSamplingSupported) {\n      return;\n    }\n    player.setAudioSamplingEnabled(true);\n    const subscription = player.addListener(AUDIO_SAMPLE_UPDATE, listener);\n    return () => subscription.remove();\n  }, [player.id]);\n}\n\n/**\n * Hook that creates an `AudioRecorder` instance for recording audio.\n *\n * This hook manages the recorder's lifecycle and ensures it's properly disposed when no longer needed.\n * The recorder is automatically prepared with the provided options and can be used to record audio.\n *\n * @param options Recording configuration options including format, quality, sample rate, etc.\n * @param statusListener Optional callback function that receives recording status updates.\n * @returns An `AudioRecorder` instance that's automatically managed by the component lifecycle.\n *\n * @example\n * ```tsx\n * import { useAudioRecorder, RecordingPresets } from 'expo-audio';\n *\n * function RecorderComponent() {\n *   const recorder = useAudioRecorder(\n *     RecordingPresets.HIGH_QUALITY,\n *     (status) => console.log('Recording status:', status)\n *   );\n *\n *   const startRecording = async () => {\n *     await recorder.prepareToRecordAsync();\n *     recorder.record();\n *   };\n *\n *   return (\n *     <Button title=\"Start Recording\" onPress={startRecording} />\n *   );\n * }\n * ```\n */\nexport function useAudioRecorder(\n  options: RecordingOptions,\n  statusListener?: (status: RecordingStatus) => void\n): AudioRecorder {\n  const platformOptions = createRecordingOptions(options);\n  const recorder = useReleasingSharedObject(() => {\n    return new AudioModule.AudioRecorder(platformOptions);\n  }, [JSON.stringify(platformOptions)]);\n\n  useEffect(() => {\n    const subscription = recorder.addListener(RECORDING_STATUS_UPDATE, (status) => {\n      statusListener?.(status);\n    });\n    return () => subscription.remove();\n  }, [recorder.id]);\n\n  return recorder;\n}\n\n/**\n * Hook that provides real-time recording state updates for an `AudioRecorder`.\n *\n * This hook polls the recorder's status at regular intervals and returns the current recording state.\n * Use this when you need to monitor the recording status without setting up a status listener.\n *\n * @param recorder The `AudioRecorder` instance to monitor.\n * @param interval How often (in milliseconds) to poll the recorder's status. Defaults to 500ms.\n * @returns The current `RecorderState` containing recording information.\n *\n * @example\n * ```tsx\n * import { useAudioRecorder, useAudioRecorderState, RecordingPresets } from 'expo-audio';\n *\n * function RecorderStatusComponent() {\n *   const recorder = useAudioRecorder(RecordingPresets.HIGH_QUALITY);\n *   const state = useAudioRecorderState(recorder);\n *\n *   return (\n *     <View>\n *       <Text>Recording: {state.isRecording ? 'Yes' : 'No'}</Text>\n *       <Text>Duration: {state.currentTime}s</Text>\n *       <Text>Can Record: {state.canRecord ? 'Yes' : 'No'}</Text>\n *     </View>\n *   );\n * }\n * ```\n */\nexport function useAudioRecorderState(recorder: AudioRecorder, interval: number = 500) {\n  const [state, setState] = useState<RecorderState>(recorder.getStatus());\n\n  useEffect(() => {\n    const int = setInterval(() => {\n      const newState = recorder.getStatus();\n\n      setState((prevState) => {\n        const meteringChanged =\n          (prevState.metering === undefined) !== (newState.metering === undefined) ||\n          (prevState.metering !== undefined &&\n            newState.metering !== undefined &&\n            Math.abs(prevState.metering - newState.metering) > 0.1);\n\n        if (\n          prevState.canRecord !== newState.canRecord ||\n          prevState.isRecording !== newState.isRecording ||\n          prevState.mediaServicesDidReset !== newState.mediaServicesDidReset ||\n          prevState.url !== newState.url ||\n          Math.abs(prevState.durationMillis - newState.durationMillis) > 50 ||\n          meteringChanged\n        ) {\n          return newState;\n        }\n        return prevState;\n      });\n    }, interval);\n\n    return () => clearInterval(int);\n  }, [recorder.id]);\n\n  return state;\n}\n\n/**\n * Creates an instance of an `AudioPlayer` that doesn't release automatically.\n *\n * > **info** For most use cases you should use the [`useAudioPlayer`](#useaudioplayer) hook instead.\n * > See the [Using the `AudioPlayer` directly](#using-the-audioplayer-directly) section for more details.\n * @param source The audio source to load.\n * @param options Audio player configuration options.\n */\nexport function createAudioPlayer(\n  source: AudioSource | string | number | null = null,\n  options: AudioPlayerOptions = {}\n): AudioPlayer {\n  const { updateInterval = 500, downloadFirst = false, keepAudioSessionActive = false } = options;\n  const initialSource = downloadFirst ? null : resolveSource(source);\n  const player = new AudioModule.AudioPlayer(initialSource, updateInterval, keepAudioSessionActive);\n\n  if (downloadFirst && source) {\n    resolveSourceWithDownload(source)\n      .then((resolved) => {\n        if (resolved) {\n          player.replace(resolved);\n        }\n      })\n      .catch((error) => {\n        console.warn('expo-audio: Failed to download source, using fallback:', error);\n        const fallback = resolveSource(source);\n        if (fallback) {\n          player.replace(fallback);\n        }\n      });\n  }\n\n  return player;\n}\n\n/**\n * Enables or disables the audio subsystem globally.\n *\n * When set to `false`, this will pause all audio playback and prevent new audio from playing.\n * This is useful for implementing app-wide audio controls or responding to system events.\n *\n * @param active Whether audio should be active (`true`) or disabled (`false`).\n * @returns A Promise that resolves when the audio state has been updated.\n *\n * @example\n * ```tsx\n * import { setIsAudioActiveAsync } from 'expo-audio';\n *\n * // Disable all audio when app goes to background\n * const handleAppStateChange = async (nextAppState) => {\n *   if (nextAppState === 'background') {\n *     await setIsAudioActiveAsync(false);\n *   } else if (nextAppState === 'active') {\n *     await setIsAudioActiveAsync(true);\n *   }\n * };\n * ```\n */\nexport async function setIsAudioActiveAsync(active: boolean): Promise<void> {\n  return await AudioModule.setIsAudioActiveAsync(active);\n}\n\n/**\n * Configures the global audio behavior and session settings.\n *\n * This function allows you to control how your app's audio interacts with other apps,\n * background playback behavior, audio routing, and interruption handling.\n *\n * @param mode Partial audio mode configuration object. Only specified properties will be updated.\n * @returns A Promise that resolves when the audio mode has been applied.\n *\n * @example\n * ```tsx\n * import { setAudioModeAsync } from 'expo-audio';\n *\n * // Configure audio for background playback\n * await setAudioModeAsync({\n *   playsInSilentMode: true,\n *   shouldPlayInBackground: true,\n *   interruptionModeAndroid: 'duckOthers',\n *   interruptionMode: 'mixWithOthers'\n * });\n *\n * // Configure audio for recording\n * await setAudioModeAsync({\n *   allowsRecording: true,\n *   playsInSilentMode: false\n * });\n * ```\n */\nexport async function setAudioModeAsync(mode: Partial<AudioMode>): Promise<void> {\n  const audioMode: Partial<AudioMode> =\n    Platform.OS === 'ios'\n      ? mode\n      : {\n          shouldPlayInBackground: mode.shouldPlayInBackground,\n          shouldRouteThroughEarpiece: mode.shouldRouteThroughEarpiece,\n          interruptionMode: mode.interruptionModeAndroid,\n        };\n  return await AudioModule.setAudioModeAsync(audioMode);\n}\n\n/**\n * Requests permission to record audio from the microphone.\n *\n * This function prompts the user for microphone access permission, which is required\n * for audio recording functionality. On iOS, this will show the system permission dialog.\n * On Android, this requests the `RECORD_AUDIO` permission.\n *\n * @returns A Promise that resolves to a `PermissionResponse` object containing the permission status.\n *\n * @example\n * ```tsx\n * import { requestRecordingPermissionsAsync } from 'expo-audio';\n *\n * const checkPermissions = async () => {\n *   const { status, granted } = await requestRecordingPermissionsAsync();\n *\n *   if (granted) {\n *     console.log('Recording permission granted');\n *   } else {\n *     console.log('Recording permission denied:', status);\n *   }\n * };\n * ```\n */\nexport async function requestRecordingPermissionsAsync(): Promise<PermissionResponse> {\n  return await AudioModule.requestRecordingPermissionsAsync();\n}\n\n/**\n * Checks the current status of recording permissions without requesting them.\n *\n * This function returns the current permission status for microphone access\n * without triggering a permission request dialog. Use this to check permissions\n * before deciding whether to call `requestRecordingPermissionsAsync()`.\n *\n * @returns A Promise that resolves to a `PermissionResponse` object containing the current permission status.\n *\n * @example\n * ```tsx\n * import { getRecordingPermissionsAsync, requestRecordingPermissionsAsync } from 'expo-audio';\n *\n * const ensureRecordingPermissions = async () => {\n *   const { status } = await getRecordingPermissionsAsync();\n *\n *   if (status !== 'granted') {\n *     // Permission not granted, request it\n *     const { granted } = await requestRecordingPermissionsAsync();\n *     return granted;\n *   }\n *\n *   return true; // Already granted\n * };\n * ```\n */\nexport async function getRecordingPermissionsAsync(): Promise<PermissionResponse> {\n  return await AudioModule.getRecordingPermissionsAsync();\n}\n\nexport { AudioModule };\n"]}