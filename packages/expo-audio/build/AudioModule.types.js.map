{"version":3,"file":"AudioModule.types.js","sourceRoot":"","sources":["../src/AudioModule.types.ts"],"names":[],"mappings":"","sourcesContent":["import { NativeModule, PermissionResponse, SharedObject } from 'expo-modules-core';\n\nimport {\n  AudioMode,\n  AudioSource,\n  AudioStatus,\n  PitchCorrectionQuality,\n  RecorderState,\n  RecordingInput,\n  RecordingOptions,\n  RecordingStartOptions,\n  RecordingStatus,\n} from './Audio.types';\n\n/**\n * @hidden\n */\nexport declare class NativeAudioModule extends NativeModule {\n  setIsAudioActiveAsync(active: boolean): Promise<void>;\n  setAudioModeAsync(category: Partial<AudioMode>): Promise<void>;\n  requestRecordingPermissionsAsync(): Promise<PermissionResponse>;\n  getRecordingPermissionsAsync(): Promise<PermissionResponse>;\n\n  readonly AudioPlayer: typeof AudioPlayer;\n  readonly AudioRecorder: typeof AudioRecorder;\n}\n\nexport declare class AudioPlayer extends SharedObject<AudioEvents> {\n  /**\n   * Initializes a new audio player instance with the given source.\n   * @hidden\n   */\n  constructor(source: AudioSource, updateInterval: number, keepAudioSessionActive: boolean);\n\n  /**\n   * Unique identifier for the player object.\n   */\n  id: number;\n\n  /**\n   * Boolean value indicating whether the player is currently playing.\n   */\n  playing: boolean;\n\n  /**\n   * Boolean value indicating whether the player is currently muted.\n   */\n  muted: boolean;\n\n  /**\n   * Boolean value indicating whether the player is currently looping.\n   */\n  loop: boolean;\n\n  /**\n   * Boolean value indicating whether the player is currently paused.\n   */\n  paused: boolean;\n\n  /**\n   * Boolean value indicating whether the player is finished loading.\n   */\n  isLoaded: boolean;\n\n  /**\n   * Boolean value indicating whether audio sampling is supported on the platform.\n   */\n  isAudioSamplingSupported: boolean;\n\n  /**\n   * Boolean value indicating whether the player is buffering.\n   */\n  isBuffering: boolean;\n\n  /**\n   * The current position through the audio item in seconds.\n   */\n  currentTime: number;\n\n  /**\n   * The total duration of the audio in seconds.\n   */\n  duration: number;\n\n  /**\n   * The current volume of the audio.\n   *\n   * **Range:** `0.0` to `1.0`. For example, `0.0` is completely silent (0%), `0.5` is half volume (50%), and `1.0` is full volume (100%).\n   *\n   *\n   * @example\n   * ```tsx\n   * import { useAudioPlayer } from 'expo-audio';\n   *\n   * export default function App() {\n   *   const player = useAudioPlayer(source);\n   *\n   *   // Mute the audio\n   *   player.volume = 0.0;\n   *\n   *   // Set volume to 50%\n   *   player.volume = 0.5;\n   *\n   *   // Set to full volume\n   *   player.volume = 1.0;\n   * }\n   * ```\n   */\n  volume: number;\n\n  /**\n   * The current playback rate of the audio. It accepts different values depending on the platform:\n   * - **Android**: `0.1` to `2.0`\n   * - **iOS**: `0.0` to `2.0`\n   * - **Web**: Follows browser implementation\n   *\n   * @example\n   * ```tsx\n   * import { useAudioPlayer } from 'expo-audio';\n   *\n   * export default function App() {\n   *   const player = useAudioPlayer(source);\n   *\n   *   // Normal playback speed\n   *   player.playbackRate = 1.0;\n   *\n   *   // Slow motion (half speed)\n   *   player.playbackRate = 0.5;\n   *\n   *   // Fast playback (1.5x speed)\n   *   player.playbackRate = 1.5;\n   *\n   *   // Maximum speed on mobile\n   *   player.playbackRate = 2.0;\n   * }\n   * ```\n   */\n  playbackRate: number;\n\n  /**\n   * A boolean describing if we are correcting the pitch for a changed rate.\n   */\n  shouldCorrectPitch: boolean;\n\n  /**\n   * The current status of the audio player.\n   * @hidden\n   */\n  currentStatus: AudioStatus;\n\n  /**\n   * Start playing audio.\n   */\n  play(): void;\n\n  /**\n   * Pauses the player.\n   */\n  pause(): void;\n\n  /**\n   * Replaces the current audio source with a new one.\n   */\n  replace(source: AudioSource): void;\n\n  /**\n   * Seeks the playback by the given number of seconds.\n   * @param seconds The number of seconds to seek by.\n   * @param toleranceMillisBefore The tolerance allowed before the requested seek time, in milliseconds. iOS only.\n   * @param toleranceMillisAfter The tolerance allowed after the requested seek time, in milliseconds. iOS only.\n   */\n  seekTo(\n    seconds: number,\n    toleranceMillisBefore?: number,\n    toleranceMillisAfter?: number\n  ): Promise<void>;\n\n  /**\n   * Sets the current playback rate of the audio.\n   *\n   * @param rate The playback rate of the audio. See [`playbackRate`](#playbackrate) property for detailed range information.\n   * @param pitchCorrectionQuality The quality of the pitch correction.\n   */\n  setPlaybackRate(rate: number, pitchCorrectionQuality?: PitchCorrectionQuality): void;\n\n  /**\n   *\n   * @hidden\n   */\n  setAudioSamplingEnabled(enabled: boolean): void;\n\n  /**\n   * Remove the player from memory to free up resources.\n   */\n  remove(): void;\n}\n\n/**\n * Represents a single audio sample containing waveform data from all audio channels.\n *\n * Audio samples are provided in real-time when audio sampling is enabled on an `AudioPlayer`.\n * Each sample contains the raw PCM audio data for all channels (mono has 1 channel, stereo has 2).\n * This data can be used for audio visualization, analysis, or processing.\n */\nexport type AudioSample = {\n  /** Array of audio channels, each containing PCM frame data. Stereo audio will have 2 channels (left/right). */\n  channels: AudioSampleChannel[];\n  /** Timestamp of this sample relative to the audio track's timeline, in seconds. */\n  timestamp: number;\n};\n\n/**\n * Represents audio data for a single channel (for example, left or right in stereo audio).\n *\n * Contains the raw PCM (Pulse Code Modulation) audio frames for this channel.\n * Frame values are normalized between -1.0 and 1.0, where 0 represents silence.\n */\nexport type AudioSampleChannel = {\n  /** Array of PCM audio frame values, each between -1.0 and 1.0. */\n  frames: number[];\n};\n\n/**\n * Event types that an `AudioPlayer` can emit.\n *\n * These events allow you to listen for changes in playback state and receive real-time audio data.\n * Use `player.addListener()` to subscribe to these events.\n */\nexport type AudioEvents = {\n  /** Fired when the player's status changes (play/pause/seek/load and so on.). */\n  playbackStatusUpdate(status: AudioStatus): void;\n  /** Fired when audio sampling is enabled and new sample data is available. */\n  audioSampleUpdate(data: AudioSample): void;\n};\n\nexport declare class AudioRecorder extends SharedObject<RecordingEvents> {\n  /**\n   * Initializes a new audio recorder instance with the given source.\n   * @hidden\n   */\n  constructor(options: Partial<RecordingOptions>);\n\n  /**\n   * Unique identifier for the recorder object.\n   */\n  id: number;\n\n  /**\n   * The current length of the recording, in seconds.\n   */\n  currentTime: number;\n\n  /**\n   * Boolean value indicating whether the recording is in progress.\n   */\n  isRecording: boolean;\n\n  /**\n   * The uri of the recording.\n   */\n  uri: string | null;\n\n  /**\n   * Starts the recording.\n   * @param options Optional recording configuration options.\n   */\n  record(options?: RecordingStartOptions): void;\n\n  /**\n   * Stop the recording.\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Pause the recording.\n   */\n  pause(): void;\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  getAvailableInputs(): RecordingInput[];\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  getCurrentInput(): Promise<RecordingInput>;\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  setInput(inputUid: string): void;\n\n  /**\n   * Status of the current recording.\n   */\n  getStatus(): RecorderState;\n\n  /**\n   * Starts the recording at the given time.\n   * @param seconds The time in seconds to start recording at.\n   * @deprecated Use `record({ atTime: seconds })` instead.\n   */\n  startRecordingAtTime(seconds: number): void;\n\n  /**\n   * Prepares the recording for recording.\n   */\n  prepareToRecordAsync(options?: Partial<RecordingOptions>): Promise<void>;\n\n  /**\n   * Stops the recording once the specified time has elapsed.\n   * @param seconds The time in seconds to stop recording at.\n   * @deprecated Use `record({ forDuration: seconds })` instead.\n   */\n  recordForDuration(seconds: number): void;\n}\n\n/**\n * Event types that an `AudioRecorder` can emit.\n *\n * These events are used internally by `expo-audio` hooks to provide real-time status updates.\n * Use `useAudioRecorderState()` or the `statusListener` parameter in `useAudioRecorder()` instead of subscribing directly.\n */\nexport type RecordingEvents = {\n  /** Fired when the recorder's status changes (start/stop/pause/error, and so on). */\n  recordingStatusUpdate: (status: RecordingStatus) => void;\n};\n"]}