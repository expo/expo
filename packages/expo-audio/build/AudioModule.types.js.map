{"version":3,"file":"AudioModule.types.js","sourceRoot":"","sources":["../src/AudioModule.types.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAsB,YAAY,EAAE,MAAM,mBAAmB,CAAC","sourcesContent":["import { NativeModule, PermissionResponse, SharedObject } from 'expo-modules-core';\n\nimport {\n  AudioMode,\n  AudioSource,\n  AudioStatus,\n  PitchCorrectionQuality,\n  RecorderState,\n  RecordingInput,\n  RecordingOptions,\n  RecordingStatus,\n} from './Audio.types';\n\n/**\n * @hidden\n */\nexport declare class NativeAudioModule extends NativeModule {\n  setIsAudioActiveAsync(active: boolean): Promise<void>;\n  setAudioModeAsync(category: Partial<AudioMode>): Promise<void>;\n  requestRecordingPermissionsAsync(): Promise<PermissionResponse>;\n  getRecordingPermissionsAsync(): Promise<PermissionResponse>;\n\n  readonly AudioPlayer: typeof AudioPlayer;\n  readonly AudioRecorder: typeof AudioRecorder;\n}\n\nexport declare class AudioPlayer extends SharedObject<AudioEvents> {\n  /**\n   * Initializes a new audio player instance with the given sources.\n   * @hidden\n   */\n  constructor(sources: AudioSource[], updateInterval: number);\n\n  /**\n   * Unique identifier for the player object.\n   */\n  id: number;\n\n  /**\n   * Boolean value indicating whether the player is currently playing.\n   */\n  playing: boolean;\n\n  /**\n   * Boolean value indicating whether the player is currently muted.\n   */\n  muted: boolean;\n\n  /**\n   * Boolean value indicating whether the player is currently looping.\n   */\n  loop: boolean;\n\n  /**\n   * Boolean value indicating whether the player is currently paused.\n   */\n  paused: boolean;\n\n  /**\n   * Boolean value indicating whether the player is finished loading.\n   */\n  isLoaded: boolean;\n\n  /**\n   * Boolean value indicating whether audio sampling is supported on the platform.\n   */\n  isAudioSamplingSupported: boolean;\n\n  /**\n   * Boolean value indicating whether the player is buffering.\n   */\n  isBuffering: boolean;\n\n  /**\n   * The current position through the audio item in seconds.\n   */\n  currentTime: number;\n\n  /**\n   * The total duration of the audio in seconds.\n   */\n  duration: number;\n\n  /**\n   * The current volume of the audio.\n   */\n  volume: number;\n\n  /**\n   * The current playback rate of the audio.\n   */\n  playbackRate: number;\n\n  /**\n   * A boolean describing if we are correcting the pitch for a changed rate.\n   */\n  shouldCorrectPitch: boolean;\n\n  /**\n   * The current status of the audio player.\n   * @hidden\n   */\n  currentStatus: AudioStatus;\n\n  /**\n   * Start playing audio.\n   */\n  play(): void;\n\n  /**\n   * Pauses the player.\n   */\n  pause(): void;\n\n  /**\n   * Clears the queue and stops the playback.\n   */\n  clearQueue(): void;\n\n  /**\n   * Replaces the current audio source with a new one.\n   * Internally uses the queue functionality (equivalent to setQueue([source])).\n   * Maintains backward compatibility with previous replace behavior.\n   */\n  replace(source: AudioSource): void;\n\n  /**\n   * Sets a queue of audio sources to be played in sequence.\n   * @param sources The array of audio sources.\n   */\n  setQueue(sources: AudioSource[]): void;\n\n  /**\n   * The current queue of audio sources.\n   */\n  getCurrentQueue(): AudioSource[];\n\n  /**\n   * The current index of the queue. Returns null if no track loaded\n   */\n  getCurrentQueueIndex(): number | null;\n\n  /**\n   * Adds tracks to the queue at an optionally specified index.\n   * @param tracks Array of AudioSource objects that will be added\n   * @param insertBeforeIndex The index of the track that will be located immediately after the inserted tracks. Set it to null to add at the end of the queue\n   */\n  addToQueue(tracks: AudioSource[], insertBeforeIndex?: number): void;\n\n  /**\n   * Removes tracks from the queue.\n   * If the current track is removed, the next track will be activated.\n   * If the current track was the last track in the queue, the first track will be activated.\n   * @param tracks The AudioSource objects that will be removed\n   */\n  removeFromQueue(tracks: AudioSource[]): void;\n\n  /**\n   * Skips to a track in the queue.\n   * @param index The track index\n   */\n  skipToQueueIndex(index: number): void;\n\n  /**\n   * Skips to the next track in the queue.\n   */\n  skipToNext(): void;\n\n  /**\n   * Skips to the previous track in the queue.\n   */\n  skipToPrevious(): void;\n\n  /**\n   * Seeks the playback by the given number of seconds.\n   * @param seconds The number of seconds to seek by.\n   */\n  seekTo(seconds: number): Promise<void>;\n\n  /**\n   * Sets the current playback rate of the audio.\n   * @param rate The playback rate of the audio.\n   * @param pitchCorrectionQuality The quality of the pitch correction.\n   */\n  setPlaybackRate(rate: number, pitchCorrectionQuality?: PitchCorrectionQuality): void;\n\n  /**\n   *\n   * @hidden\n   */\n  setAudioSamplingEnabled(enabled: boolean): void;\n\n  /**\n   * Remove the player from memory to free up resources.\n   */\n  remove(): void;\n}\n\n// @docsMissing\nexport type AudioSample = {\n  channels: AudioSampleChannel[];\n  timestamp: number;\n};\n\n// @docsMissing\nexport type AudioSampleChannel = { frames: number[] };\n\n// @docsMissing\nexport type AudioEvents = {\n  playbackStatusUpdate(status: AudioStatus): void;\n  audioSampleUpdate(data: AudioSample): void;\n};\n\nexport declare class AudioRecorder extends SharedObject<RecordingEvents> {\n  /**\n   * Initializes a new audio recorder instance with the given source.\n   * @hidden\n   */\n  constructor(options: Partial<RecordingOptions>);\n\n  /**\n   * Unique identifier for the recorder object.\n   */\n  id: number;\n\n  /**\n   * The current length of the recording, in seconds.\n   */\n  currentTime: number;\n\n  /**\n   * Boolean value indicating whether the recording is in progress.\n   */\n  isRecording: boolean;\n\n  /**\n   * The uri of the recording.\n   */\n  uri: string | null;\n\n  /**\n   * Starts the recording.\n   */\n  record(): void;\n\n  /**\n   * Stop the recording.\n   */\n  stop(): Promise<void>;\n\n  /**\n   * Pause the recording.\n   */\n  pause(): void;\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  getAvailableInputs(): RecordingInput[];\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  getCurrentInput(): RecordingInput;\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  setInput(inputUid: string): void;\n\n  /**\n   * Status of the current recording.\n   */\n  getStatus(): RecorderState;\n\n  /**\n   * Starts the recording at the given time.\n   * @param seconds The time in seconds to start recording at.\n   */\n  startRecordingAtTime(seconds: number): void;\n\n  /**\n   * Prepares the recording for recording.\n   */\n  prepareToRecordAsync(options?: Partial<RecordingOptions>): Promise<void>;\n\n  /**\n   * Stops the recording once the specified time has elapsed.\n   * @param seconds The time in seconds to stop recording at.\n   */\n  recordForDuration(seconds: number): void;\n}\n\n// @docsMissing\nexport type RecordingEvents = {\n  recordingStatusUpdate: (status: RecordingStatus) => void;\n};\n"]}