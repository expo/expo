{"version":3,"file":"Audio.types.js","sourceRoot":"","sources":["../src/Audio.types.ts"],"names":[],"mappings":"","sourcesContent":["import { AudioQuality, IOSOutputFormat } from './RecordingConstants';\n\n// @docsMissing\nexport type AudioSource =\n  | string\n  | number\n  | null\n  | {\n      /**\n       * A string representing the resource identifier for the audio,\n       * which could be an HTTPS address, a local file path, or the name of a static audio file resource.\n       */\n      uri?: string;\n      /**\n       * The asset ID of a local audio asset, acquired with the `require` function.\n       * This property is exclusive with the `uri` property. When both are present, the `assetId` will be ignored.\n       */\n      assetId?: number;\n      /**\n       * An object representing the HTTP headers to send along with the request for a remote audio source.\n       * On web requires the `Access-Control-Allow-Origin` header returned by the server to include the current domain.\n       */\n      headers?: Record<string, string>;\n    };\n\n/**\n * Options for configuring audio player behavior.\n */\nexport type AudioPlayerOptions = {\n  /**\n   * How often (in milliseconds) to emit playback status updates. Defaults to 500ms.\n   *\n   * @example\n   * ```tsx\n   * import { useAudioPlayer } from 'expo-audio';\n   *\n   * export default function App() {\n   *   const player = useAudioPlayer(source);\n   *\n   *   // High-frequency updates for smooth progress bars\n   *   const player = useAudioPlayer(source, { updateInterval: 100 });\n   *\n   *   // Standard updates (default behavior)\n   *   const player = useAudioPlayer(source, { updateInterval: 500 });\n   *\n   *   // Low-frequency updates for better performance\n   *   const player = useAudioPlayer(source, { updateInterval: 1000 });\n   * }\n   * ```\n   *\n   * @default 500ms\n   *\n   * @platform ios\n   * @platform android\n   * @platform web\n   */\n  updateInterval?: number;\n  /**\n   * If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `false`.\n   *\n   * Works with:\n   * - Local assets from `require('path/to/file')`\n   * - Remote HTTP/HTTPS URLs\n   * - Asset objects\n   *\n   * When enabled, this ensures the audio file is fully downloaded before playback begins.\n   * This can improve playback performance and reduce buffering, especially for users\n   * managing multiple audio players simultaneously.\n   *\n   * On Android and iOS, this will download the audio file to the device's tmp directory before playback begins.\n   * The system will purge the file at its discretion.\n   *\n   * On web, this will download the audio file to the user's device memory and make it available for the user to play.\n   * The system will usually purge the file from memory after a reload or on memory pressure.\n   * On web, CORS restrictions apply to the blob url, so you need to make sure the server returns the `Access-Control-Allow-Origin` header.\n   *\n   * @platform ios\n   * @platform web\n   * @platform android\n   */\n  downloadFirst?: boolean;\n  /**\n   * Determines the [cross origin policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/crossorigin) used by the underlying native view on web.\n   * If `undefined` (default), does not use CORS at all. If set to `'anonymous'`, the audio will be loaded with CORS enabled.\n   * Note that some audio may not play if CORS is enabled, depending on the CDN settings.\n   * If you encounter issues, consider adjusting the `crossOrigin` property.\n   *\n   *\n   * @platform web\n   * @default undefined\n   */\n  crossOrigin?: 'anonymous' | 'use-credentials';\n  /**\n   * If set to `true`, the audio session will not be deactivated when this player pauses or finishes playback.\n   * This prevents interrupting other audio sources (like videos) when the audio ends.\n   *\n   * Useful for sound effects that should not interfere with ongoing video playback or other audio.\n   * The audio session for this player will not be deactivated automatically when the player finishes playback.\n   *\n   * > **Note:** If needed, you can manually deactivate the audio session using `setIsAudioActiveAsync(false)`.\n   *\n   * @platform ios\n   * @default false\n   */\n  keepAudioSessionActive?: boolean;\n};\n\n/**\n * @deprecated Use `AudioPlayerOptions` instead.\n * Options for audio loading behavior.\n */\nexport type AudioLoadOptions = AudioPlayerOptions;\n\n/**\n * Represents an available audio input device for recording.\n *\n * This type describes audio input sources like built-in microphones, external microphones,\n * or other audio input devices that can be used for recording. Each input has an identifying\n * information that can be used to select the preferred recording source.\n */\nexport type RecordingInput = {\n  /** Human-readable name of the audio input device. */\n  name: string;\n  /** Type or category of the input device (for example, 'Built-in Microphone', 'External Microphone'). */\n  type: string;\n  /** Unique identifier for the input device, used to select the input ('Built-in Microphone', 'External Microphone') for recording. */\n  uid: string;\n};\n\n/**\n * Pitch correction quality settings for audio playback rate changes.\n *\n * When changing playback rate, pitch correction can be applied to maintain the original pitch.\n * Different quality levels offer trade-offs between processing power and audio quality.\n *\n * @platform ios\n */\nexport type PitchCorrectionQuality = 'low' | 'medium' | 'high';\n\n/**\n * Comprehensive status information for an `AudioPlayer`.\n *\n * This object contains all the current state information about audio playback,\n * including playback position, duration, loading state, and playback settings.\n * Used by `useAudioPlayerStatus()` to provide real-time status updates.\n */\nexport type AudioStatus = {\n  /** Unique identifier for the player instance. */\n  id: number;\n  /** Current playback position in seconds. */\n  currentTime: number;\n  /** String representation of the player's internal playback state. */\n  playbackState: string;\n  /** String representation of the player's time control status (playing/paused/waiting). */\n  timeControlStatus: string;\n  /** Reason why the player is waiting to play (if applicable). */\n  reasonForWaitingToPlay: string;\n  /** Whether the player is currently muted. */\n  mute: boolean;\n  /** Total duration of the audio in seconds, or 0 if not yet determined. */\n  duration: number;\n  /** Whether the audio is currently playing. */\n  playing: boolean;\n  /** Whether the audio is set to loop when it reaches the end. */\n  loop: boolean;\n  /** Whether the audio just finished playing. */\n  didJustFinish: boolean;\n  /** Whether the player is currently buffering data. */\n  isBuffering: boolean;\n  /** Whether the audio has finished loading and is ready to play. */\n  isLoaded: boolean;\n  /** Current playback rate (1.0 = normal speed). */\n  playbackRate: number;\n  /** Whether pitch correction is enabled for rate changes. */\n  shouldCorrectPitch: boolean;\n};\n\n/**\n * Status information for recording operations from the event system.\n *\n * This type represents the status data emitted by `recordingStatusUpdate` events.\n * It contains high-level information about the recording session and any errors.\n * Used internally by the event system. Most users should use `useAudioRecorderState()` instead.\n */\nexport type RecordingStatus = {\n  /** Unique identifier for the recording session. */\n  id: number;\n  /** Whether the recording has finished (stopped). */\n  isFinished: boolean;\n  /** Whether an error occurred during recording. */\n  hasError: boolean;\n  /** Error message if an error occurred, `null` otherwise. */\n  error: string | null;\n  /** File URL of the completed recording, if available. */\n  url: string | null;\n};\n\n/**\n * Current state information for an `AudioRecorder`.\n *\n * This object contains detailed information about the recorder's current state,\n * including recording status, duration, and technical details. This is what you get\n * when calling `recorder.getStatus()` or using `useAudioRecorderState()`.\n */\nexport type RecorderState = {\n  /** Whether the recorder is ready and able to record. */\n  canRecord: boolean;\n  /** Whether recording is currently in progress. */\n  isRecording: boolean;\n  /** Duration of the current recording in milliseconds. */\n  durationMillis: number;\n  /** Whether the media services have been reset (typically indicates a system interruption). */\n  mediaServicesDidReset: boolean;\n  /** Current audio level/volume being recorded (if metering is enabled). */\n  metering?: number;\n  /** File URL where the recording will be saved, if available. */\n  url: string | null;\n};\n\n/**\n * Audio output format options for Android recording.\n *\n * Specifies the container format for recorded audio files on Android.\n * Different formats have different compatibility and compression characteristics.\n *\n * @platform android\n */\nexport type AndroidOutputFormat =\n  | 'default'\n  | '3gp'\n  | 'mpeg4'\n  | 'amrnb'\n  | 'amrwb'\n  | 'aac_adts'\n  | 'mpeg2ts'\n  | 'webm';\n\n/**\n * Audio encoder options for Android recording.\n *\n * Specifies the audio codec used to encode recorded audio on Android.\n * Different encoders offer different quality, compression, and compatibility trade-offs.\n *\n * @platform android\n */\nexport type AndroidAudioEncoder = 'default' | 'amr_nb' | 'amr_wb' | 'aac' | 'he_aac' | 'aac_eld';\n\n/**\n * Bit rate strategies for audio encoding.\n *\n * Determines how the encoder manages bit rate during recording, affecting\n * file size consistency and quality characteristics.\n */\nexport type BitRateStrategy = 'constant' | 'longTermAverage' | 'variableConstrained' | 'variable';\n\n/**\n * Options for controlling how audio recording is started.\n */\nexport type RecordingStartOptions = {\n  /**\n   * The duration in seconds after which recording should automatically stop.\n   * If not provided, recording continues until manually stopped.\n   *\n   * @platform ios\n   * @platform android\n   * @platform web\n   */\n  forDuration?: number;\n  /**\n   * The time in seconds to wait before starting the recording.\n   * If not provided, recording starts immediately.\n   *\n   * **Platform behavior:**\n   * - Android: Ignored, recording starts immediately\n   * - iOS: Uses native AVAudioRecorder.record(atTime:) for precise timing.\n   * - Web: Ignored, recording starts immediately\n   *\n   * > **warning** On iOS, the recording process starts immediately (you'll see status updates),\n   * but actual audio capture begins after the specified delay. This is not a countdown, since\n   * the recorder is active but silent during the delay period.\n   *\n   * @platform ios\n   */\n  atTime?: number;\n};\n\nexport type RecordingOptions = {\n  /**\n   * A boolean that determines whether audio level information will be part of the status object under the \"metering\" key.\n   */\n  isMeteringEnabled?: boolean;\n  /**\n   * The desired file extension.\n   *\n   * @example .caf\n   */\n  extension: string;\n  /**\n   * The desired sample rate.\n   *\n   * @example 44100\n   */\n  sampleRate: number;\n  /**\n   * The desired number of channels.\n   *\n   * @example 2\n   */\n  numberOfChannels: number;\n  /**\n   * The desired bit rate.\n   *\n   * @example 128000\n   */\n  bitRate: number;\n  /**\n   * Recording options for the Android platform.\n   * @platform android\n   */\n  android: RecordingOptionsAndroid;\n  /**\n   * Recording options for the iOS platform.\n   * @platform ios\n   */\n  ios: RecordingOptionsIos;\n  /**\n   * Recording options for the Web platform.\n   * @platform web\n   */\n  web?: RecordingOptionsWeb;\n};\n\n/**\n * Recording options for the web.\n *\n * Web recording uses the `MediaRecorder` API, which has different capabilities\n * compared to native platforms. These options map directly to `MediaRecorder` settings.\n *\n * @platform web\n */\nexport type RecordingOptionsWeb = {\n  /** MIME type for the recording (for example, 'audio/webm', 'audio/mp4'). */\n  mimeType?: string;\n  /** Target bits per second for the recording. */\n  bitsPerSecond?: number;\n};\n\n/**\n * Recording configuration options specific to iOS.\n *\n * iOS recording uses `AVAudioRecorder` with extensive format and quality options.\n * These settings provide fine-grained control over the recording characteristics.\n *\n * @platform ios\n */\nexport type RecordingOptionsIos = {\n  /**\n   * The desired file extension.\n   *\n   * @example .caf\n   */\n  extension?: string;\n  /**\n   * The desired sample rate.\n   *\n   * @example 44100\n   */\n  sampleRate?: number;\n  /**\n   * The desired file format. See the [`IOSOutputFormat`](#iosoutputformat) enum for all valid values.\n   */\n  outputFormat?: string | IOSOutputFormat | number;\n  /**\n   * The desired audio quality. See the [`AudioQuality`](#audioquality) enum for all valid values.\n   */\n  audioQuality: AudioQuality | number;\n  /**\n   * The desired bit rate strategy. See the next section for an enumeration of all valid values of `bitRateStrategy`.\n   */\n  bitRateStrategy?: number;\n  /**\n   * The desired bit depth hint.\n   *\n   * @example 16\n   */\n  bitDepthHint?: number;\n  /**\n   * The desired PCM bit depth.\n   *\n   * @example 16\n   */\n  linearPCMBitDepth?: number;\n  /**\n   * A boolean describing if the PCM data should be formatted in big endian.\n   */\n  linearPCMIsBigEndian?: boolean;\n  /**\n   * A boolean describing if the PCM data should be encoded in floating point or integral values.\n   */\n  linearPCMIsFloat?: boolean;\n};\n\n/**\n * Recording configuration options specific to Android.\n *\n * Android recording uses `MediaRecorder` with options for format, encoder, and file constraints.\n * These settings control the output format and quality characteristics.\n *\n * @platform android\n */\nexport type RecordingOptionsAndroid = {\n  /**\n   * The desired file extension.\n   *\n   * @example .caf\n   */\n  extension?: string;\n  /**\n   * The desired sample rate.\n   *\n   * @example 44100\n   */\n  sampleRate?: number;\n  /**\n   * The desired file format. See the [`AndroidOutputFormat`](#androidoutputformat) enum for all valid values.\n   */\n  outputFormat: AndroidOutputFormat;\n  /**\n   * The desired audio encoder. See the [`AndroidAudioEncoder`](#androidaudioencoder) enum for all valid values.\n   */\n  audioEncoder: AndroidAudioEncoder;\n  /**\n   * The desired maximum file size in bytes, after which the recording will stop (but `stopAndUnloadAsync()` must still\n   * be called after this point).\n   *\n   * @example\n   * `65536`\n   */\n  maxFileSize?: number;\n  /**\n   * The desired audio Source. See the [`AndroidAudioSource`](#androidaudiosource) enum for all valid values.\n   */\n  audioSource?: RecordingSource;\n};\n\nexport type AudioMode = {\n  /**\n   * Determines if audio playback is allowed when the device is in silent mode.\n   *\n   * @platform ios\n   */\n  playsInSilentMode: boolean;\n  /**\n   * Determines how the audio session interacts with other sessions.\n   *\n   * @platform ios\n   */\n  interruptionMode: InterruptionMode;\n  /**\n   * Determines how the audio session interacts with other sessions on Android.\n   *\n   * @platform android\n   */\n  interruptionModeAndroid: InterruptionModeAndroid;\n  /**\n   * Whether the audio session allows recording.\n   *\n   * @default false\n   * @platform ios\n   */\n  allowsRecording: boolean;\n  /**\n   * Whether the audio session stays active when the app moves to the background.\n   * @default false\n   */\n  shouldPlayInBackground: boolean;\n  /**\n   * Whether the audio should route through the earpiece.\n   * @platform android\n   */\n  shouldRouteThroughEarpiece: boolean;\n};\n\n/**\n * Audio interruption behavior modes for iOS.\n *\n * Controls how your app's audio interacts with other apps' audio when interruptions occur.\n * This affects what happens when phone calls, notifications, or other apps play audio.\n *\n * @platform ios\n */\nexport type InterruptionMode = 'mixWithOthers' | 'doNotMix' | 'duckOthers';\n\n/**\n * Audio interruption behavior modes for Android.\n *\n * Controls how your app's audio interacts with other apps' audio on Android.\n * Note that Android doesn't support 'mixWithOthers' mode; audio focus is more strictly managed.\n *\n * @platform android\n */\nexport type InterruptionModeAndroid = 'doNotMix' | 'duckOthers';\n\n/**\n * Recording source for android.\n *\n * An audio source defines both a default physical source of audio signal, and a recording configuration.\n *\n * - `camcorder`: Microphone audio source tuned for video recording, with the same orientation as the camera if available.\n * - `default`: The default audio source.\n * - `mic`: Microphone audio source.\n * - `unprocessed`: Microphone audio source tuned for unprocessed (raw) sound if available, behaves like `default` otherwise.\n * - `voice_communication`: Microphone audio source tuned for voice communications such as VoIP. It will for instance take advantage of echo cancellation or automatic gain control if available.\n * - `voice_performance`: Source for capturing audio meant to be processed in real time and played back for live performance (e.g karaoke). The capture path will minimize latency and coupling with playback path.\n * - `voice_recognition`: Microphone audio source tuned for voice recognition.\n *\n * @see https://developer.android.com/reference/android/media/MediaRecorder.AudioSource\n * @platform android\n */\nexport type RecordingSource =\n  | 'camcorder'\n  | 'default'\n  | 'mic'\n  | 'remote_submix'\n  | 'unprocessed'\n  | 'voice_communication'\n  | 'voice_performance'\n  | 'voice_recognition';\n"]}