{"version":3,"file":"Audio.types.js","sourceRoot":"","sources":["../src/Audio.types.ts"],"names":[],"mappings":"AAqEA,MAAM,CAAN,IAAY,eAmCX;AAnCD,WAAY,eAAe;IACzB,qCAAkB,CAAA;IAClB,+BAAY,CAAA;IACZ,oCAAmB,CAAA;IACnB,qCAAkB,CAAA;IAClB,oCAAiB,CAAA;IACjB,qCAAkB,CAAA;IAClB,qCAAkB,CAAA;IAClB,uCAAoB,CAAA;IACpB,iCAAc,CAAA;IACd,iCAAc,CAAA;IACd,gCAAa,CAAA;IACb,gCAAa,CAAA;IACb,mCAAgB,CAAA;IAChB,oCAAiB,CAAA;IACjB,oCAAiB,CAAA;IACjB,sCAAmB,CAAA;IACnB,sCAAmB,CAAA;IACnB,sCAAmB,CAAA;IACnB,yCAAsB,CAAA;IACtB,uCAAoB,CAAA;IACpB,uCAAoB,CAAA;IACpB,wCAAqB,CAAA;IACrB,4CAAyB,CAAA;IACzB,2CAAwB,CAAA;IACxB,0CAAuB,CAAA;IACvB,4CAAyB,CAAA;IACzB,+BAAY,CAAA;IACZ,kCAAe,CAAA;IACf,mCAAgB,CAAA;IAChB,gCAAa,CAAA;IACb,4EAAwB,CAAA;IACxB,8EAAyB,CAAA;IACzB,gCAAa,CAAA;IACb,uCAAoB,CAAA;AACtB,CAAC,EAnCW,eAAe,KAAf,eAAe,QAmC1B;AAED,MAAM,CAAN,IAAY,YAMX;AAND,WAAY,YAAY;IACtB,6CAAO,CAAA;IACP,8CAAU,CAAA;IACV,oDAAa,CAAA;IACb,gDAAW,CAAA;IACX,+CAAU,CAAA;AACZ,CAAC,EANW,YAAY,KAAZ,YAAY,QAMvB","sourcesContent":["export type AudioSource =\n  | string\n  | {\n      /**\n       * A string representing the resource identifier for the audio,\n       * which could be an HTTPS address, a local file path, or the name of a static audio file resource.\n       */\n      uri?: string;\n      /**\n       * An object representing the HTTP headers to send along with the request for a remote audio source.\n       * On web requires the `Access-Control-Allow-Origin` header returned by the server to include the current domain.\n       */\n      headers?: Record<string, string>;\n    }\n  | null;\n\nexport type RecordingInput = {\n  name: string;\n  type: string;\n  uid: string;\n};\n\nexport type PitchCorrectionQuality = 'low' | 'medium' | 'high';\n\nexport type AudioStatus = {\n  id: number;\n  currentTime: number;\n  playbackState: string;\n  timeControlStatus: string;\n  reasonForWaitingToPlay: string;\n  mute: boolean;\n  duration: number;\n  playing: boolean;\n  loop: boolean;\n  isBuffering: boolean;\n  isLoaded: boolean;\n  playbackRate: number;\n  shouldCorrectPitch: boolean;\n};\n\nexport type RecordingStatus = {\n  id: number;\n  isFinished: boolean;\n  hasError: boolean;\n  error: string | null;\n  url: string | null;\n};\n\nexport type RecorderState = {\n  canRecord: boolean;\n  isRecording: boolean;\n  durationMillis: number;\n  mediaServicesDidReset: boolean;\n  metering?: number;\n  url: string | null;\n};\n\nexport type AndroidOutputFormat =\n  | 'default'\n  | '3gp'\n  | 'mpeg4'\n  | 'amrnb'\n  | 'amrwb'\n  | 'aac_adts'\n  | 'mpeg2ts'\n  | 'webm';\n\nexport type AndroidAudioEncoder = 'default' | 'amr_nb' | 'amr_wb' | 'aac' | 'he_aac' | 'aac_eld';\n\nexport enum IOSOutputFormat {\n  LINEARPCM = 'lpcm',\n  AC3 = 'ac-3',\n  '60958AC3' = 'cac3',\n  APPLEIMA4 = 'ima4',\n  MPEG4AAC = 'aac ',\n  MPEG4CELP = 'celp',\n  MPEG4HVXC = 'hvxc',\n  MPEG4TWINVQ = 'twvq',\n  MACE3 = 'MAC3',\n  MACE6 = 'MAC6',\n  ULAW = 'ulaw',\n  ALAW = 'alaw',\n  QDESIGN = 'QDMC',\n  QDESIGN2 = 'QDM2',\n  QUALCOMM = 'Qclp',\n  MPEGLAYER1 = '.mp1',\n  MPEGLAYER2 = '.mp2',\n  MPEGLAYER3 = '.mp3',\n  APPLELOSSLESS = 'alac',\n  MPEG4AAC_HE = 'aach',\n  MPEG4AAC_LD = 'aacl',\n  MPEG4AAC_ELD = 'aace',\n  MPEG4AAC_ELD_SBR = 'aacf',\n  MPEG4AAC_ELD_V2 = 'aacg',\n  MPEG4AAC_HE_V2 = 'aacp',\n  MPEG4AAC_SPATIAL = 'aacs',\n  AMR = 'samr',\n  AMR_WB = 'sawb',\n  AUDIBLE = 'AUDB',\n  ILBC = 'ilbc',\n  DVIINTELIMA = 0x6d730011,\n  MICROSOFTGSM = 0x6d730031,\n  AES3 = 'aes3',\n  ENHANCEDAC3 = 'ec-3',\n}\n\nexport enum AudioQuality {\n  MIN = 0,\n  LOW = 0x20,\n  MEDIUM = 0x40,\n  HIGH = 0x60,\n  MAX = 0x7f,\n}\n\nexport type BitRateStrategy = 'constant' | 'longTermAverage' | 'variableConstrained' | 'variable';\n\nexport type RecordingOptions = {\n  /**\n   * The desired file extension.\n   *\n   * @example `'.caf'`\n   */\n  extension: string;\n  /**\n   * The desired sample rate.\n   *\n   * @example `44100`\n   */\n  sampleRate: number;\n  /**\n   * The desired number of channels.\n   *\n   * @example `1`, `2`\n   */\n  numberOfChannels: number;\n  /**\n   * The desired bit rate.\n   *\n   * @example `128000`\n   */\n  bitRate: number;\n  /**\n   * Recording options for the Android platform.\n   */\n  android: RecordingOptionsAndroid;\n  /**\n   * Recording options for the iOS platform.\n   */\n  ios: RecordingOptionsIos;\n  /**\n   * Recording options for the Web platform.\n   */\n  web?: RecordingOptionsWeb;\n};\n\nexport type RecordingOptionsWeb = {\n  mimeType?: string;\n  bitsPerSecond?: number;\n};\n\nexport type RecordingOptionsIos = {\n  /**\n   * The desired file extension.\n   *\n   * @example `'.caf'`\n   */\n  extension?: string;\n  /**\n   * The desired sample rate.\n   *\n   * @example `44100`\n   */\n  sampleRate?: number;\n  /**\n   * The desired file format. See the [`IOSOutputFormat`](#iosoutputformat) enum for all valid values.\n   */\n  outputFormat?: string | IOSOutputFormat | number;\n  /**\n   * The desired audio quality. See the [`IOSAudioQuality`](#iosaudioquality) enum for all valid values.\n   */\n  audioQuality: AudioQuality | number;\n  /**\n   * The desired bit rate strategy. See the next section for an enumeration of all valid values of `bitRateStrategy`.\n   */\n  bitRateStrategy?: number;\n  /**\n   * The desired bit depth hint.\n   *\n   * @example\n   * `16`\n   */\n  bitDepthHint?: number;\n  /**\n   * The desired PCM bit depth.\n   *\n   * @example\n   * `16`\n   */\n  linearPCMBitDepth?: number;\n  /**\n   * A boolean describing if the PCM data should be formatted in big endian.\n   */\n  linearPCMIsBigEndian?: boolean;\n  /**\n   * A boolean describing if the PCM data should be encoded in floating point or integral values.\n   */\n  linearPCMIsFloat?: boolean;\n};\n\nexport type RecordingOptionsAndroid = {\n  /**\n   * The desired file extension.\n   *\n   * @example `'.caf'`\n   */\n  extension?: string;\n  /**\n   * The desired sample rate.\n   *\n   * @example `44100`\n   */\n  sampleRate?: number;\n  /**\n   * The desired file format. See the [`AndroidOutputFormat`](#androidoutputformat) enum for all valid values.\n   */\n  outputFormat: AndroidOutputFormat;\n  /**\n   * The desired audio encoder. See the [`AndroidAudioEncoder`](#androidaudioencoder) enum for all valid values.\n   */\n  audioEncoder: AndroidAudioEncoder;\n  /**\n   * The desired maximum file size in bytes, after which the recording will stop (but `stopAndUnloadAsync()` must still\n   * be called after this point).\n   *\n   * @example\n   * `65536`\n   */\n  maxFileSize?: number;\n};\n\nexport type AudioMode = {\n  playsInSilentMode: boolean;\n  interruptionMode: InterruptionMode;\n  allowsRecording: boolean;\n  shouldPlayInBackground: boolean;\n  shouldRouteThroughEarpiece: boolean;\n};\n\nexport type InterruptionMode = 'mixWithOthers' | 'doNotMix' | 'duckOthers';\n"]}