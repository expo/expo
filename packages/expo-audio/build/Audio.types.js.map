{"version":3,"file":"Audio.types.js","sourceRoot":"","sources":["../src/Audio.types.ts"],"names":[],"mappings":"AAiEA,MAAM,CAAN,IAAY,YAmCX;AAnCD,WAAY,YAAY;IACtB,kCAAkB,CAAA;IAClB,4BAAY,CAAA;IACZ,iCAAmB,CAAA;IACnB,kCAAkB,CAAA;IAClB,iCAAiB,CAAA;IACjB,kCAAkB,CAAA;IAClB,kCAAkB,CAAA;IAClB,oCAAoB,CAAA;IACpB,8BAAc,CAAA;IACd,8BAAc,CAAA;IACd,6BAAa,CAAA;IACb,6BAAa,CAAA;IACb,gCAAgB,CAAA;IAChB,iCAAiB,CAAA;IACjB,iCAAiB,CAAA;IACjB,mCAAmB,CAAA;IACnB,mCAAmB,CAAA;IACnB,mCAAmB,CAAA;IACnB,sCAAsB,CAAA;IACtB,oCAAoB,CAAA;IACpB,oCAAoB,CAAA;IACpB,qCAAqB,CAAA;IACrB,yCAAyB,CAAA;IACzB,wCAAwB,CAAA;IACxB,uCAAuB,CAAA;IACvB,yCAAyB,CAAA;IACzB,4BAAY,CAAA;IACZ,+BAAe,CAAA;IACf,gCAAgB,CAAA;IAChB,6BAAa,CAAA;IACb,sEAAwB,CAAA;IACxB,wEAAyB,CAAA;IACzB,6BAAa,CAAA;IACb,oCAAoB,CAAA;AACtB,CAAC,EAnCW,YAAY,KAAZ,YAAY,QAmCvB;AAED,MAAM,CAAN,IAAY,YAMX;AAND,WAAY,YAAY;IACtB,6CAAO,CAAA;IACP,8CAAU,CAAA;IACV,oDAAa,CAAA;IACb,gDAAW,CAAA;IACX,+CAAU,CAAA;AACZ,CAAC,EANW,YAAY,KAAZ,YAAY,QAMvB","sourcesContent":["export type AudioSource = {\n  /**\n   * A string representing the resource identifier for the audio,\n   * which could be an HTTPS address, a local file path, or the name of a static audio file resource.\n   */\n  uri?: string;\n  /**\n   * An object representing the HTTP headers to send along with the request for a remote audio source.\n   * On web requires the `Access-Control-Allow-Origin` header returned by the server to include the current domain.\n   */\n  headers?: Record<string, string>;\n};\n\nexport type RecordingInput = {\n  name: string;\n  type: string;\n  uid: string;\n};\n\nexport type AudioPlayerState = {\n  isLoaded: boolean;\n  isLooping: boolean;\n  isMuted: boolean;\n  positionMillis: number;\n  durationMillis: number;\n  rate: number;\n  volume: number;\n  playing: boolean;\n  audioPan: number;\n  shouldCorrectPitch: boolean;\n};\n\nexport type PitchCorrectionQuality = 'low' | 'medium' | 'high';\n\nexport type AudioStatus = {\n  id: number;\n  currentTime: number;\n  status: string;\n  timeControlStatus: string;\n  reasonForWaitingToPlay: string;\n  mute: boolean;\n  duration: number;\n  playing: boolean;\n  loop: boolean;\n  isBuffering: boolean;\n  isLoaded: boolean;\n  playbackRate: number;\n  shouldCorrectPitch: boolean;\n};\n\nexport type RecordingStatus = {\n  id: number;\n  isFinished: boolean;\n  hasError: boolean;\n  error: string | null;\n};\n\nexport type RecorderState = {\n  canRecord: boolean;\n  isRecording: boolean;\n  durationMillis: number;\n  mediaServicesDidReset: boolean;\n  metering?: number;\n};\n\nexport enum OutputFormat {\n  LINEARPCM = 'lpcm',\n  AC3 = 'ac-3',\n  '60958AC3' = 'cac3',\n  APPLEIMA4 = 'ima4',\n  MPEG4AAC = 'aac ',\n  MPEG4CELP = 'celp',\n  MPEG4HVXC = 'hvxc',\n  MPEG4TWINVQ = 'twvq',\n  MACE3 = 'MAC3',\n  MACE6 = 'MAC6',\n  ULAW = 'ulaw',\n  ALAW = 'alaw',\n  QDESIGN = 'QDMC',\n  QDESIGN2 = 'QDM2',\n  QUALCOMM = 'Qclp',\n  MPEGLAYER1 = '.mp1',\n  MPEGLAYER2 = '.mp2',\n  MPEGLAYER3 = '.mp3',\n  APPLELOSSLESS = 'alac',\n  MPEG4AAC_HE = 'aach',\n  MPEG4AAC_LD = 'aacl',\n  MPEG4AAC_ELD = 'aace',\n  MPEG4AAC_ELD_SBR = 'aacf',\n  MPEG4AAC_ELD_V2 = 'aacg',\n  MPEG4AAC_HE_V2 = 'aacp',\n  MPEG4AAC_SPATIAL = 'aacs',\n  AMR = 'samr',\n  AMR_WB = 'sawb',\n  AUDIBLE = 'AUDB',\n  ILBC = 'ilbc',\n  DVIINTELIMA = 0x6d730011,\n  MICROSOFTGSM = 0x6d730031,\n  AES3 = 'aes3',\n  ENHANCEDAC3 = 'ec-3',\n}\n\nexport enum AudioQuality {\n  MIN = 0,\n  LOW = 0x20,\n  MEDIUM = 0x40,\n  HIGH = 0x60,\n  MAX = 0x7f,\n}\n\nexport type BitRateStrategy = 'constant' | 'longTermAverage' | 'variableConstrained' | 'variable';\n\nexport type RecordingOptions = {\n  /**\n   * The desired file extension.\n   *\n   * @example `'.caf'`\n   */\n  extension: string;\n  /**\n   * The desired file format. See the [`IOSOutputFormat`](#iosoutputformat) enum for all valid values.\n   */\n  outputFormat?: string | OutputFormat | number;\n  /**\n   * The desired audio quality. See the [`IOSAudioQuality`](#iosaudioquality) enum for all valid values.\n   */\n  audioQuality: AudioQuality | number;\n  /**\n   * The desired sample rate.\n   *\n   * @example `44100`\n   */\n  sampleRate: number;\n  /**\n   * The desired number of channels.\n   *\n   * @example `1`, `2`\n   */\n  numberOfChannels: number;\n  /**\n   * The desired bit rate.\n   *\n   * @example `128000`\n   */\n  bitRate: number;\n  /**\n   * The desired bit rate strategy. See the next section for an enumeration of all valid values of `bitRateStrategy`.\n   */\n  bitRateStrategy?: BitRateStrategy;\n  /**\n   * The desired bit depth hint.\n   *\n   * @example `16`\n   */\n  bitDepthHint?: number;\n  /**\n   * The desired PCM bit depth.\n   *\n   * @example `16`\n   */\n  linearPCMBitDepth?: number;\n  /**\n   * A boolean describing if the PCM data should be formatted in big endian.\n   */\n  linearPCMIsBigEndian?: boolean;\n  /**\n   * A boolean describing if the PCM data should be encoded in floating point or integral values.\n   */\n  linearPCMIsFloat?: boolean;\n};\n\nexport type AudioMode = {\n  playsInSilentMode: boolean;\n  interruptionMode: InterruptionMode;\n  allowsRecording: boolean;\n  shouldPlayInBackground: boolean;\n};\n\ntype InterruptionMode = 'mixWithOthers' | 'doNotMix' | 'duckOthers';\n"]}