"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeGitRepoAsync = initializeGitRepoAsync;
exports.addAllToGitIndexAsync = addAllToGitIndexAsync;
exports.commitAsync = commitAsync;
exports.diffAsync = diffAsync;
exports.applyPatchAsync = applyPatchAsync;
exports.getPatchChangedLinesAsync = getPatchChangedLinesAsync;
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const env = __importStar(require("./env"));
async function initializeGitRepoAsync(repoRoot) {
    try {
        await promises_1.default.rm(path_1.default.join(repoRoot, '.git'), { recursive: true, force: true });
    }
    catch { }
    await runGitAsync(['init'], { cwd: repoRoot });
    await generateDefaultGitignoreAsync(repoRoot);
}
async function addAllToGitIndexAsync(repoRoot) {
    await runGitAsync(['add', '-A'], { cwd: repoRoot });
}
async function commitAsync(repoRoot, message) {
    await runGitAsync(['commit', '-m', message], {
        cwd: repoRoot,
        env: {
            ...process.env,
            GIT_AUTHOR_NAME: 'expo-cng',
            GIT_COMMITTER_NAME: 'expo-cng',
            GIT_AUTHOR_EMAIL: 'noreply@expo.dev',
            GIT_COMMITTER_EMAIL: 'noreply@expo.dev',
        },
    });
}
async function diffAsync(repoRoot, outputPatchFilePath, options) {
    await runGitAsync([
        'diff',
        '--no-color',
        '--ignore-space-at-eol',
        '--no-ext-diff',
        '--src-prefix=a/',
        '--dst-prefix=b/',
        ...options,
        '--output',
        outputPatchFilePath,
    ], {
        cwd: repoRoot,
    });
}
async function applyPatchAsync(projectRoot, patchFilePath) {
    return await runGitAsync(['apply', patchFilePath], { cwd: projectRoot });
}
async function getPatchChangedLinesAsync(patchFilePath) {
    const stdout = await runGitAsync(['apply', '--numstat', patchFilePath]);
    const lines = stdout.split(/\r?\n/);
    let changedLines = 0;
    for (const line of lines) {
        if (line === '') {
            continue;
        }
        const [added, deleted] = line.split('\t', 2);
        changedLines += Number(added) + Number(deleted);
    }
    return changedLines;
}
async function runGitAsync(args, options) {
    try {
        const { stdout, stderr } = await (0, spawn_async_1.default)('git', args, options);
        if (env.EXPO_DEBUG) {
            console.log(`Running \`git ${args}\` outputs:\nstdout:\n${stdout}\nstderr:\n${stderr}`);
        }
        return stdout.trim();
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            e.message += `\nGit is required to apply patches. Install Git and try again.`;
        }
        else if (e.stderr) {
            e.message += `\nstderr:\n${e.stderr}`;
        }
        throw e;
    }
}
async function generateDefaultGitignoreAsync(repoRoot) {
    const contents = `\
# These files are generated by pod install and should not be included in patch files.
Podfile.lock
contents.xcworkspacedata
`;
    await promises_1.default.writeFile(path_1.default.join(repoRoot, '.gitignore'), contents, 'utf8');
}
//# sourceMappingURL=gitPatch.js.map