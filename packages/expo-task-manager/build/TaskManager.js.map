{"version":3,"file":"TaskManager.js","sourceRoot":"","sources":["../src/TaskManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, UnavailabilityError } from '@unimodules/core';\n\nimport ExpoTaskManager from './ExpoTaskManager';\n\n/**\n * Error object that can be received through TaskManagerTaskBody when the task fails.\n */\nexport interface TaskManagerError {\n  code: string | number;\n  message: string;\n}\n\n/**\n * Represents the object that is passed to the task executor.\n */\nexport interface TaskManagerTaskBody {\n  /**\n   * An object of data passed to the task executor. Its properties depends on the type of the task.\n   */\n  data: object;\n\n  /**\n   * Error object if the task failed or `null` otherwise.\n   */\n  error: TaskManagerError | null;\n\n  /**\n   * Additional details containing unique ID of task event and name of the task.\n   */\n  executionInfo: {\n    eventId: string;\n    taskName: string;\n  };\n}\n\n/**\n * Represents an already registered task.\n */\nexport interface TaskManagerTask {\n  /**\n   * Name that the task is registered with.\n   */\n  taskName: string;\n\n  /**\n   * Type of the task which depends on how the task was registered.\n   */\n  taskType: string;\n\n  /**\n   * Provides `options` that the task was registered with.\n   */\n  options: any;\n}\n\n/**\n * @deprecated in favor of TaskManagerTask.\n */\nexport interface RegisteredTask extends TaskManagerTask {}\n\n/**\n * Type of task executor – a function that handles the task.\n */\nexport type TaskManagerTaskExecutor = (body: TaskManagerTaskBody) => void;\n\nconst tasks: Map<string, TaskManagerTaskExecutor> = new Map<string, TaskManagerTaskExecutor>();\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.');\n  }\n}\n\n/**\n * Method that you use to define a task – it saves given task executor under given task name\n * which must be correlated with the task name used when registering the task.\n *\n * @param taskName Name of the task. It must be the same as the name you provided when registering the task.\n * @param taskExecutor A function that handles the task.\n */\nexport function defineTask(taskName: string, taskExecutor: TaskManagerTaskExecutor) {\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!taskExecutor || typeof taskExecutor !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  tasks.set(taskName, taskExecutor);\n}\n\n/**\n * Checks whether the task is already defined.\n *\n * @param taskName Name of the task.\n */\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\n/**\n * Checks whether the task has been registered.\n *\n * @param taskName Name of the task.\n * @returns A promise resolving to boolean value. If `false` then even if the task is defined, it won't be called because it's not registered.\n */\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\n/**\n * Retrieves an `options` object for provided `taskName`.\n *\n * @param taskName Name of the task.\n */\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync');\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\n/**\n * Provides informations about registered tasks.\n *\n * @returns Returns a promise resolving to an array containing all tasks registered by the app.\n */\nexport async function getRegisteredTasksAsync(): Promise<TaskManagerTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync');\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\n/**\n * Unregisters the task. Tasks are usually registered by other modules (e.g. expo-location).\n *\n * @param taskName Name of the task.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync');\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\n/**\n * Unregisters all tasks registered by the app. You may want to call this when the user is\n * signing out and you no longer need to track his location or run any other background tasks.\n */\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync');\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\nif (ExpoTaskManager) {\n  const eventEmitter = new EventEmitter(ExpoTaskManager);\n  eventEmitter.addListener<TaskManagerTaskBody>(\n    ExpoTaskManager.EVENT_NAME,\n    async ({ data, error, executionInfo }) => {\n      const { eventId, taskName } = executionInfo;\n      const taskExecutor = tasks.get(taskName);\n      let result: any = null;\n\n      if (taskExecutor) {\n        try {\n          // Execute JS task\n          result = await taskExecutor({ data, error, executionInfo });\n        } catch (error) {\n          console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n        } finally {\n          // Notify manager the task is finished.\n          await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        }\n      } else {\n        console.warn(\n          `TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`\n        );\n        // No tasks defined -> we need to notify about finish anyway.\n        await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n        // We should also unregister such tasks automatically as the task might have been removed\n        // from the app or just renamed - in that case it needs to be registered again (with the new name).\n        await ExpoTaskManager.unregisterTaskAsync(taskName);\n      }\n    }\n  );\n}\n"]}