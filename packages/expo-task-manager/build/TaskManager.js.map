{"version":3,"file":"TaskManager.js","sourceRoot":"","sources":["../src/TaskManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'expo-core';\nimport { UnavailabilityError } from 'expo-errors';\nimport ExpoTaskManager from './ExpoTaskManager';\n\ninterface TaskError {\n  code: string | number,\n  message: string,\n}\n\ninterface TaskBody {\n  data: object,\n  error: TaskError | null,\n  executionInfo: {\n    eventId: string,\n    taskName: string,\n  },\n}\n\ninterface RegisteredTask {\n  taskName: string,\n  taskType: string,\n  options: any,\n}\n\ntype Task = (body: TaskBody) => void;\n\nlet eventEmitter: EventEmitter | null = null;\nif (ExpoTaskManager.addListener) {\n  eventEmitter = new EventEmitter(ExpoTaskManager);\n} else {\n  console.warn('ExpoTaskManager is not an event emitter, are you sure all the installed Expo modules are properly linked?')\n}\n\nconst tasks: Map<string, Task> = new Map<string, Task>();\n\nlet isRunningDuringInitialization = true;\n\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new TypeError('`taskName` must be a non-empty string.')\n  }\n}\n\nexport function defineTask(taskName: string, task: Task) {\n  if (!isRunningDuringInitialization) {\n    console.error(`TaskManager.defineTask must be called during initialization phase!`);\n    return;\n  }\n  if (!taskName || typeof taskName !== 'string') {\n    console.warn(`TaskManager.defineTask: 'taskName' argument must be a non-empty string.`);\n    return;\n  }\n  if (!task || typeof task !== 'function') {\n    console.warn(`TaskManager.defineTask: 'task' argument must be a function.`);\n    return;\n  }\n  if (tasks.has(taskName)) {\n    console.warn(`TaskManager.defineTask: task '${taskName}' is already defined.`);\n    return;\n  }\n  tasks.set(taskName, task);\n}\n\nexport function isTaskDefined(taskName: string): boolean {\n  return tasks.has(taskName);\n}\n\nexport async function isTaskRegisteredAsync(taskName: string): Promise<boolean> {\n  if (!ExpoTaskManager.isTaskRegisteredAsync) {\n    throw new UnavailabilityError('TaskManager', 'isTaskRegisteredAsync')\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.isTaskRegisteredAsync(taskName);\n}\n\nexport async function getTaskOptionsAsync<TaskOptions>(taskName: string): Promise<TaskOptions> {\n  if (!ExpoTaskManager.getTaskOptionsAsync) {\n    throw new UnavailabilityError('TaskManager', 'getTaskOptionsAsync')\n  }\n\n  _validateTaskName(taskName);\n  return ExpoTaskManager.getTaskOptionsAsync(taskName);\n}\n\nexport async function getRegisteredTasksAsync(): Promise<RegisteredTask[]> {\n  if (!ExpoTaskManager.getRegisteredTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'getRegisteredTasksAsync')\n  }\n\n  return ExpoTaskManager.getRegisteredTasksAsync();\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoTaskManager.unregisterTaskAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterTaskAsync')\n  }\n\n  _validateTaskName(taskName);\n  await ExpoTaskManager.unregisterTaskAsync(taskName);\n}\n\nexport async function unregisterAllTasksAsync(): Promise<void> {\n  if (!ExpoTaskManager.unregisterAllTasksAsync) {\n    throw new UnavailabilityError('TaskManager', 'unregisterAllTasksAsync')\n  }\n\n  await ExpoTaskManager.unregisterAllTasksAsync();\n}\n\nif (eventEmitter) {\n  eventEmitter.addListener<TaskBody>(ExpoTaskManager.EVENT_NAME, async ({ data, error, executionInfo }) => {\n    const { eventId, taskName } = executionInfo;\n    const task = tasks.get(taskName);\n    let result: any = null;\n  \n    if (task) {\n      try {\n        // Execute JS task\n        result = await task({ data, error, executionInfo });\n      } catch (error) {\n        console.error(`TaskManager: Task \"${taskName}\" failed:`, error);\n      } finally {\n        // Notify manager the task is finished.\n        await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n      }\n    } else {\n      console.warn(`TaskManager: Task \"${taskName}\" has been executed but looks like it is not defined. Please make sure that \"TaskManager.defineTask\" is called during initialization phase.`);\n      // No tasks defined -> we need to notify about finish anyway.\n      await ExpoTaskManager.notifyTaskFinishedAsync(taskName, { eventId, result });\n      // We should also unregister such tasks automatically as the task might have been removed\n      // from the app or just renamed - in that case it needs to be registered again (with the new name).\n      await ExpoTaskManager.unregisterTaskAsync(taskName);\n    }\n  });\n}\n\n// @tsapeta: Turn off `defineTask` function right after the initialization phase.\n// Promise.resolve() ensures that it will be called as a microtask just after the first event loop.\nPromise.resolve().then(() => {\n  isRunningDuringInitialization = false;\n});\n"]}