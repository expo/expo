{"version":3,"file":"registerCommand.js","sourceRoot":"","sources":["../src/registerCommand.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,6CAA+B;AAG/B,kEAA0C;AAC1C,yCAAsC;AAStC,SAAS,WAAW,CAAC,QAAgB;IACnC,IAAI,QAAQ,KAAK,SAAS,EAAE,CAAC;QAC3B,OAAO,mBAAQ,CAAC,OAAO,CAAC;IAC1B,CAAC;SAAM,IAAI,QAAQ,KAAK,KAAK,EAAE,CAAC;QAC9B,OAAO,mBAAQ,CAAC,GAAG,CAAC;IACtB,CAAC;SAAM,IAAI,QAAQ,KAAK,MAAM,EAAE,CAAC;QAC/B,OAAO,mBAAQ,CAAC,IAAI,CAAC;IACvB,CAAC;IAED,MAAM,IAAI,KAAK,CAAC,qBAAqB,QAAQ,EAAE,CAAC,CAAC;AACnD,CAAC;AAED,SAAgB,eAAe,CAC7B,SAA0B,EAC1B,WAAmB,EACnB,EAA0D;IAE1D,OAAO,SAAS;SACb,OAAO,CAAC,WAAW,CAAC;SACpB,MAAM,CAAC,qBAAqB,EAAE,0BAA0B,CAAC;SACzD,MAAM,CACL,uBAAuB,EACvB,gGAAgG,CACjG;SACA,MAAM,CAAC,qBAAqB,EAAE,8CAA8C,CAAC;SAC7E,MAAM,CAAC,KAAK,EAAE,eAAe,EAAE,EAAE;QAChC,IAAI,eAAe,CAAC,QAAQ,EAAE,CAAC;YAC7B,eAAe,CAAC,QAAQ,GAAG,WAAW,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;QACnE,CAAC;aAAM,CAAC;YACN,eAAe,CAAC,QAAQ,GAAG,mBAAQ,CAAC,IAAI,CAAC;QAC3C,CAAC;QAED,iDAAiD;QACjD,eAAe,CAAC,eAAe,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC;QACxD,eAAe,CAAC,IAAI,GAAG,eAAe,CAAC,IAAI,IAAI,KAAK,CAAC,SAAS,EAAE,CAAC;QAEjE,eAAe,CAAC,UAAU,GAAG,sBAAY,CAAC,WAAW,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;QAElF,MAAM,OAAO,GAAG,eAA8B,CAAC;QAC/C,MAAM,YAAY,GAAG,IAAI,sBAAY,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAE1D,IAAI,CAAC;YACH,MAAM,EAAE,CAAC,YAAY,CAAC,cAAc,EAAE,EAAE,OAAO,CAAC,CAAC;QACnD,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACX,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACjB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACH,CAAC,CAAC,CAAC;AACP,CAAC;AApCD,0CAoCC","sourcesContent":["import { CommanderStatic } from 'commander';\nimport * as tempy from 'tempy';\n\nimport { Config } from './Config';\nimport ConfigReader from './ConfigReader';\nimport { Platform } from './Platform';\n\nexport interface DefaultOptions {\n  configFile: string;\n  platform: Platform;\n  path: string;\n  shouldBeCleaned: boolean;\n}\n\nfunction mapPlatform(platform: string): Platform {\n  if (platform === 'android') {\n    return Platform.Android;\n  } else if (platform === 'ios') {\n    return Platform.iOS;\n  } else if (platform === 'both') {\n    return Platform.Both;\n  }\n\n  throw new Error(`Unknown platform: ${platform}`);\n}\n\nexport function registerCommand<OptionsType extends DefaultOptions>(\n  commander: CommanderStatic,\n  commandName: string,\n  fn: (config: Config, options: OptionsType) => Promise<any>\n) {\n  return commander\n    .command(commandName)\n    .option('-c, --config <path>', 'Path to the config file.')\n    .option(\n      '--platform <platform>',\n      'Platform for which the project should be created. Available options: `ios`, `android`, `both`.'\n    )\n    .option('-p, --path <string>', 'Location where the test app will be created.')\n    .action(async (providedOptions) => {\n      if (providedOptions.platform) {\n        providedOptions.platform = mapPlatform(providedOptions.platform);\n      } else {\n        providedOptions.platform = Platform.Both;\n      }\n\n      // clean temp folder if the path wasn't provided.\n      providedOptions.shouldBeCleaned = !providedOptions.path;\n      providedOptions.path = providedOptions.path ?? tempy.directory();\n\n      providedOptions.configFile = ConfigReader.getFilePath(providedOptions.configFile);\n\n      const options = providedOptions as OptionsType;\n      const configReader = new ConfigReader(options.configFile);\n\n      try {\n        await fn(configReader.readConfigFile(), options);\n      } catch (e) {\n        console.error(e);\n        process.exit(1);\n      }\n    });\n}\n"]}