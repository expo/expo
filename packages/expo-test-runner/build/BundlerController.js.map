{"version":3,"file":"BundlerController.js","sourceRoot":"","sources":["../src/BundlerController.ts"],"names":[],"mappings":";;;;;AAAA,iDAAoD;AACpD,4DAA+B;AAE/B,mCAAgC;AAEhC,MAAqB,iBAAiB;IAGpC,YAAoB,IAAY;QAAZ,SAAI,GAAJ,IAAI,CAAQ;IAAG,CAAC;IAEpC,KAAK,CAAC,KAAK;QACT,MAAM,OAAO,GAAG,IAAA,qBAAK,EAAC,MAAM,EAAE,CAAC,OAAO,CAAC,EAAE,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,CAAC,CAAC;QAC/E,MAAM,IAAA,aAAK,EAAC,IAAI,CAAC,CAAC;QAClB,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,KAAK,CAAC,IAAI;QACR,IAAI;YACF,SAAS;YACT,kBAAkB;YAClB,iEAAiE;YACjE,sCAAsC;YACtC,MAAM,WAAW,GAAoD,CAAC,GAAG,EAAE,OAAO,EAAE,EAAE,CACpF,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACpC,MAAM,MAAM,GAAG,SAAS,CAAC;gBACzB,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;gBAC1B,IAAI,KAAK,GAAG,CAAC,CAAC;gBACd,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE;oBAChC,IAAI;wBACF,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;qBACtB;oBAAC,MAAM;wBACN,aAAa,CAAC,QAAQ,CAAC,CAAC;wBACxB,sCAAsC;wBACtC,OAAO,EAAE,CAAC;qBACX;oBACD,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,GAAG,OAAO,EAAE;wBAC5B,aAAa,CAAC,QAAQ,CAAC,CAAC;wBACxB,MAAM,CAAC,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC;qBAC3C;gBACH,CAAC,EAAE,GAAG,CAAC,CAAC;YACV,CAAC,CAAC,CAAC;YAEL,MAAM,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE,GAAI,EAAE,IAAI,CAAC,CAAC;SAC7C;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,CAAC,GAAG,CAAC,wBAAwB,KAAK,GAAG,CAAC,CAAC;SAC/C;IACH,CAAC;IAEO,KAAK,CAAC,uBAAuB;QACnC,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,OAAO,OAAO,EAAE,GAAG,CAAC,EAAE;YACpB,IAAI;gBACF,MAAM,aAAa,GAAG,MAAM,IAAA,oBAAK,EAAC,8BAA8B,CAAC,CAAC;gBAClE,IAAI,aAAa,CAAC,MAAM,KAAK,GAAG,EAAE;oBAChC,OAAO;iBACR;aACF;YAAC,MAAM,GAAE;YAEV,MAAM,IAAA,aAAK,EAAC,GAAG,CAAC,CAAC;SAClB;QAED,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;IAC9C,CAAC;CACF;AA3DD,oCA2DC","sourcesContent":["import { ChildProcess, spawn } from 'child_process';\nimport fetch from 'node-fetch';\n\nimport { delay } from './Utils';\n\nexport default class BundlerController {\n  private process: ChildProcess | undefined;\n\n  constructor(private path: string) {}\n\n  async start() {\n    const bundler = spawn('yarn', ['start'], { cwd: this.path, stdio: 'inherit' });\n    await delay(1000);\n    this.ensureBundlerWasStarted();\n    this.process = bundler;\n  }\n\n  async stop() {\n    try {\n      // Fixes:\n      // Error: read EIO\n      // at TTY.onStreamRead (node:internal/stream_base_commons:211:20)\n      // Emitted 'error' event on ReadStream\n      const killProcess: (pid: number, timeout: number) => Promise<void> = (pid, timeout) =>\n        new Promise<void>((resolve, reject) => {\n          const signal = 'SIGTERM';\n          process.kill(pid, signal);\n          let count = 0;\n          const interval = setInterval(() => {\n            try {\n              process.kill(pid, 0);\n            } catch {\n              clearInterval(interval);\n              // the process does not exists anymore\n              resolve();\n            }\n            if ((count += 100) > timeout) {\n              clearInterval(interval);\n              reject(new Error('Timeout process kill'));\n            }\n          }, 100);\n        });\n\n      await killProcess(this.process?.pid!, 2000);\n    } catch (error) {\n      console.log(`Cannot kill bundler: ${error}.`);\n    }\n  }\n\n  private async ensureBundlerWasStarted() {\n    let retries = 10;\n    while (retries-- > 0) {\n      try {\n        const bundlerStatus = await fetch('http://localhost:8081/status');\n        if (bundlerStatus.status === 200) {\n          return;\n        }\n      } catch {}\n\n      await delay(500);\n    }\n\n    throw new Error(\"Bundler isn't available.\");\n  }\n}\n"]}