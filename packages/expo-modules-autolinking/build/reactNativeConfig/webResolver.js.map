{"version":3,"file":"webResolver.js","sourceRoot":"","sources":["../../src/reactNativeConfig/webResolver.ts"],"names":[],"mappings":";;;;;AASA,0DAqCC;AA9CD,2DAA6B;AAC7B,gDAAwB;AAQjB,KAAK,UAAU,uBAAuB,CAC3C,UAA6C,EAC7C,iBAAwE,EACxE,gBAA0C;IAE1C,IAAI,CAAC,iBAAiB,IAAI,gBAAgB,EAAE,CAAC;QAC3C,qCAAqC;QACrC,0DAA0D;QAC1D,OAAO,IAAI,CAAC;IACd,CAAC;IAED,MAAM,oBAAoB,GAAG,CAAC,CAAC,iBAAiB,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;IAC9F,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAC5B,MAAM,kBAAE,CAAC,QAAQ,CAAC,cAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,cAAc,CAAC,EAAE,MAAM,CAAC,CACtE,CAAC;QACF,MAAM,gBAAgB,GACpB,WAAW,CAAC,gBAAgB,IAAI,OAAO,WAAW,CAAC,gBAAgB,KAAK,QAAQ;YAC9E,CAAC,CAAC,WAAW,CAAC,gBAAgB;YAC9B,CAAC,CAAC,EAAE,CAAC;QACT,MAAM,aAAa,GACjB,WAAW,CAAC,aAAa,IAAI,OAAO,WAAW,CAAC,aAAa,KAAK,QAAQ;YACxE,CAAC,CAAC,WAAW,CAAC,aAAa;YAC3B,CAAC,CAAC,IAAI,CAAC;QACX,MAAM,kBAAkB,GAAG,CAAC,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;QAC9D,MAAM,gBAAgB,GAAG,CAAC,CAAC,aAAa,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;QAClF,4FAA4F;QAC5F,+FAA+F;QAC/F,sCAAsC;QACtC,IAAI,CAAC,kBAAkB,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC7C,OAAO,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED,OAAO;QACL,OAAO,EAAE,UAAU,CAAC,OAAO;KAC5B,CAAC;AACJ,CAAC","sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\n\nimport type { ExpoModuleConfig } from '../ExpoModuleConfig';\nimport {\n  RNConfigReactNativePlatformsConfig,\n  RNConfigDependencyWeb,\n} from './reactNativeConfig.types';\n\nexport async function checkDependencyWebAsync(\n  resolution: { path: string; version: string },\n  reactNativeConfig: RNConfigReactNativePlatformsConfig | null | undefined,\n  expoModuleConfig?: ExpoModuleConfig | null\n): Promise<RNConfigDependencyWeb | null> {\n  if (!reactNativeConfig || expoModuleConfig) {\n    // Skip autolinking for this package.\n    // Skip autolinking web when we have an expo module config\n    return null;\n  }\n\n  const hasReactNativeConfig = !!reactNativeConfig && Object.keys(reactNativeConfig).length > 0;\n  if (!hasReactNativeConfig) {\n    const packageJson = JSON.parse(\n      await fs.readFile(path.join(resolution.path, 'package.json'), 'utf8')\n    );\n    const peerDependencies: Record<string, unknown> =\n      packageJson.peerDependencies && typeof packageJson.peerDependencies === 'object'\n        ? packageJson.peerDependencies\n        : {};\n    const codegenConfig: Record<string, unknown> | null =\n      packageJson.codegenConfig && typeof packageJson.codegenConfig === 'object'\n        ? packageJson.codegenConfig\n        : null;\n    const hasReactNativePeer = !!peerDependencies['react-native'];\n    const hasCodegenConfig = !!codegenConfig && Object.keys(codegenConfig).length > 0;\n    // NOTE(@kitten): This is a heuristic for React Native modules that don't have a config file\n    // They'll still be considered a native module when they have a peer dependency on react-native\n    // and contain a `codegenConfig` entry\n    if (!hasReactNativePeer || !hasCodegenConfig) {\n      return null;\n    }\n  }\n\n  return {\n    version: resolution.version,\n  };\n}\n"]}