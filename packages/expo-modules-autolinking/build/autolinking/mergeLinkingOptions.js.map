{"version":3,"file":"mergeLinkingOptions.js","sourceRoot":"","sources":["../../src/autolinking/mergeLinkingOptions.ts"],"names":[],"mappings":"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","sourcesContent":["import findUp from 'find-up';\nimport fs from 'fs';\nimport path from 'path';\n\nimport type { PlatformAutolinkingOptions, SearchOptions, SupportedPlatform } from '../types';\n\nasync function loadPackageJSONAsync(packageJsonPath: string) {\n  const packageJsonText = await fs.promises.readFile(packageJsonPath, 'utf8');\n  return JSON.parse(packageJsonText);\n}\n\n/**\n * Find the path to the `package.json` of the closest project in the given project root.\n */\nexport async function getProjectPackageJsonPathAsync(projectRoot: string): Promise<string> {\n  const result = await findUp('package.json', { cwd: projectRoot });\n  if (!result) {\n    throw new Error(`Couldn't find \"package.json\" up from path \"${projectRoot}\"`);\n  }\n  return result;\n}\n\n/**\n * Synchronous version of {@link getProjectPackageJsonPathAsync}.\n */\nexport function getProjectPackageJsonPathSync(projectRoot: string): string {\n  const result = findUp.sync('package.json', { cwd: projectRoot });\n  if (!result) {\n    throw new Error(`Couldn't find \"package.json\" up from path \"${projectRoot}\"`);\n  }\n  return result;\n}\n\ninterface LinkingOptionsFactory<OptionsType extends SearchOptions> {\n  getProjectRoot(): Promise<string>;\n  getPlatformOptions(platform?: SupportedPlatform): Promise<OptionsType>;\n}\n\nexport function createLinkingOptionsFactory<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): LinkingOptionsFactory<OptionsType> {\n  let _packageJsonPath: Promise<string> | undefined;\n  const getPackageJsonPath = async () => {\n    return (\n      _packageJsonPath ||\n      (_packageJsonPath = getProjectPackageJsonPathAsync(providedOptions.projectRoot))\n    );\n  };\n\n  let _baseOptions: Promise<PlatformAutolinkingOptions> | undefined;\n  const getBaseOptions = async () => {\n    if (!_baseOptions) {\n      _baseOptions = loadPackageJSONAsync(await getPackageJsonPath()).then((packageJson) => {\n        return packageJson.expo?.autolinking as PlatformAutolinkingOptions;\n      });\n    }\n    return _baseOptions;\n  };\n\n  return {\n    async getProjectRoot() {\n      return path.dirname(await getPackageJsonPath());\n    },\n    async getPlatformOptions(platform = providedOptions.platform) {\n      const baseOptions = await getBaseOptions();\n\n      const platformOptions = getPlatformOptions(platform, baseOptions);\n      const finalOptions = Object.assign(\n        {},\n        baseOptions,\n        platformOptions,\n        providedOptions\n      ) as OptionsType;\n\n      // Makes provided paths absolute or falls back to default paths if none was provided.\n      finalOptions.searchPaths = resolveSearchPaths(\n        finalOptions.searchPaths || [],\n        providedOptions.projectRoot\n      );\n\n      finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(\n        finalOptions.nativeModulesDir,\n        providedOptions.projectRoot\n      );\n\n      // We shouldn't assume that `projectRoot` (which typically is CWD) is already at the project root\n      finalOptions.projectRoot = await this.getProjectRoot();\n\n      return finalOptions;\n    },\n  };\n}\n\n/**\n * Merges autolinking options from different sources (the later the higher priority)\n * - options defined in package.json's `expo.autolinking` field\n * - platform-specific options from the above (e.g. `expo.autolinking.apple`)\n * - options provided to the CLI command\n */\nexport async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): Promise<OptionsType> {\n  return await createLinkingOptionsFactory(providedOptions).getPlatformOptions();\n}\n\n/**\n * Resolves autolinking search paths. If none is provided, it accumulates all node_modules when\n * going up through the path components. This makes workspaces work out-of-the-box without any configs.\n */\nexport function resolveSearchPaths(searchPaths: string[] | null, cwd: string): string[] {\n  return searchPaths?.map((searchPath) => path.resolve(cwd, searchPath)) || [];\n}\n\n/**\n * Finds the real path to custom native modules directory.\n * - When {@link cwd} is inside the project directory, the path is searched relatively\n * to the project root (directory with the `package.json` file).\n * - When {@link cwd} is outside project directory (no `package.json` found), it is relative to\n * the current working directory (the {@link cwd} param).\n *\n * @param nativeModulesDir path to custom native modules directory. Defaults to `\"./modules\"` if null.\n * @param cwd current working directory\n * @returns resolved native modules directory or `null` if it is not found or doesn't exist.\n */\nasync function resolveNativeModulesDirAsync(\n  nativeModulesDir: string | null | undefined,\n  cwd: string\n): Promise<string | null> {\n  const packageJsonPath = await findUp('package.json', { cwd });\n  const projectRoot = packageJsonPath != null ? path.join(packageJsonPath, '..') : cwd;\n  const resolvedPath = path.resolve(projectRoot, nativeModulesDir || 'modules');\n  return fs.existsSync(resolvedPath) ? resolvedPath : null;\n}\n\n/**\n * Gets the platform-specific autolinking options from the base options.\n */\nfunction getPlatformOptions(\n  platform: SupportedPlatform,\n  options?: PlatformAutolinkingOptions\n): PlatformAutolinkingOptions {\n  if (platform === 'apple') {\n    return options?.apple ?? options?.ios ?? {};\n  }\n  return options?.[platform] ?? {};\n}\n"]}