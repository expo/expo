{"version":3,"file":"resolveModules.js","sourceRoot":"","sources":["../../src/autolinking/resolveModules.ts"],"names":[],"mappings":";;AAUA,kDA4BC;AAQD,gFAYC;AAzDD,4CAAmE;AAQnE,4EAA4E;AACrE,KAAK,UAAU,mBAAmB,CACvC,aAA4B,EAC5B,kBAAwE;IAExE,MAAM,eAAe,GAAG,IAAA,+CAAmC,EAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;IACzF,iDAAiD;IACjD,MAAM,WAAW,GAAG,EAAE,KAAK,EAAE,kBAAkB,CAAC,KAAK,EAAE,CAAC;IAExD,MAAM,oBAAoB,GAAG,MAAM,OAAO,CAAC,GAAG,CAC5C,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,WAAW,EAAE,QAAQ,CAAC,EAAE,EAAE;QAClE,MAAM,cAAc,GAAG,MAAM,eAAe,CAAC,kBAAkB,CAC7D,WAAW,EACX,QAAQ,EACR,WAAW,CACZ,CAAC;QACF,OAAO,cAAc;YACnB,CAAC,CAAC;gBACE,GAAG,cAAc;gBACjB,cAAc,EAAE,QAAQ,CAAC,OAAO;gBAChC,WAAW,EAAE,cAAc,CAAC,WAAW,IAAI,WAAW;aACvD;YACH,CAAC,CAAC,IAAI,CAAC;IACX,CAAC,CAAC,CACH,CAAC;IAEF,OAAO,oBAAoB;SACxB,MAAM,CAAC,CAAC,gBAAgB,EAAE,EAAE,CAAC,gBAAgB,IAAI,IAAI,CAAC;SACtD,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;AAChE,CAAC;AAOD,sHAAsH;AAC/G,KAAK,UAAU,kCAAkC,CAAC,EACvD,WAAW,EACX,QAAQ,GAC4B;IACpC,MAAM,eAAe,GAAG,IAAA,+CAAmC,EAAC,QAAQ,CAAC,CAAC;IACtE,MAAM,iBAAiB,GAAG,MAAM,eAAe,CAAC,kCAAkC;IAChF,2DAA2D;IAC3D,oGAAoG;IACpG,iCAAiC;IACjC,WAAW,CACZ,CAAC;IACF,OAAO,iBAAiB,IAAI,EAAE,CAAC;AACjC,CAAC","sourcesContent":["import { AutolinkingOptions } from '../commands/autolinkingOptions';\nimport { getLinkingImplementationForPlatform } from '../platforms';\nimport type {\n  ExtraDependencies,\n  ModuleDescriptor,\n  SearchResults,\n  SupportedPlatform,\n} from '../types';\n\n/** Resolves search results to a list of platform-specific configuration. */\nexport async function resolveModulesAsync(\n  searchResults: SearchResults,\n  autolinkingOptions: AutolinkingOptions & { platform: SupportedPlatform }\n): Promise<ModuleDescriptor[]> {\n  const platformLinking = getLinkingImplementationForPlatform(autolinkingOptions.platform);\n  // Additional output property for Cocoapods flags\n  const extraOutput = { flags: autolinkingOptions.flags };\n\n  const moduleDescriptorList = await Promise.all(\n    Object.entries(searchResults).map(async ([packageName, revision]) => {\n      const resolvedModule = await platformLinking.resolveModuleAsync(\n        packageName,\n        revision,\n        extraOutput\n      );\n      return resolvedModule\n        ? {\n            ...resolvedModule,\n            packageVersion: revision.version,\n            packageName: resolvedModule.packageName ?? packageName,\n          }\n        : null;\n    })\n  );\n\n  return moduleDescriptorList\n    .filter((moduleDescriptor) => moduleDescriptor != null)\n    .sort((a, b) => a.packageName.localeCompare(b.packageName));\n}\n\ninterface ResolveExtraBuildDependenciesParams {\n  commandRoot: string;\n  platform: SupportedPlatform;\n}\n\n/** Resolves the extra build dependencies for the project, such as additional Maven repositories or CocoaPods pods. */\nexport async function resolveExtraBuildDependenciesAsync({\n  commandRoot,\n  platform,\n}: ResolveExtraBuildDependenciesParams): Promise<ExtraDependencies> {\n  const platformLinking = getLinkingImplementationForPlatform(platform);\n  const extraDependencies = await platformLinking.resolveExtraBuildDependenciesAsync(\n    // NOTE: We assume we must be inside the native folder here\n    // The `resolve` command either is invoked in the CWD of `./{android,ios}` or has a `--project-root`\n    // that's in the native directory\n    commandRoot\n  );\n  return extraDependencies ?? [];\n}\n"]}