{"version":3,"file":"findModules.js","sourceRoot":"","sources":["../../src/autolinking/findModules.ts"],"names":[],"mappings":";;;;;AAaA,8CAyBC;AAKD,4CAmBC;AA9DD,4CAAoB;AAEpB,+DAAiE;AACjE,0DAAoE;AACpE,kDAMyB;AAGlB,KAAK,UAAU,iBAAiB,CACrC,UAAgC,EAChC,QAA2B,EAC3B,YAAyB;IAEzB,IAAI,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;QACtC,OAAO,IAAI,CAAC;IACd,CAAC;IACD,MAAM,gBAAgB,GAAG,MAAM,IAAA,gDAA6B,EAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IAC9E,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC;QACpE,OAAO;YACL,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,OAAO,EAAE,UAAU,CAAC,OAAO;YAC3B,MAAM,EAAE,gBAAgB;YACxB,UAAU,EACR,UAAU,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;gBACzC,IAAI,EAAE,SAAS,CAAC,IAAI;gBACpB,IAAI,EAAE,SAAS,CAAC,IAAI;gBACpB,OAAO,EAAE,SAAS,CAAC,OAAO;aAC3B,CAAC,CAAC,IAAI,EAAE;SACZ,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC;AAED;;GAEG;AACI,KAAK,UAAU,gBAAgB,CAAC,eAA8B;IACnE,MAAM,OAAO,GAAG,MAAM,IAAA,8CAAwB,EAAC,eAAe,CAAC,CAAC;IAChE,MAAM,YAAY,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAE9C,yFAAyF;IACzF,MAAM,WAAW,GACf,OAAO,CAAC,gBAAgB,IAAI,YAAE,CAAC,UAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC;QACjE,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,EAAE,GAAG,CAAC,OAAO,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC;QAC5D,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC;IAElC,OAAO,IAAA,wCAAyB,EAC9B,IAAA,qCAAsB,EACpB,MAAM,OAAO,CAAC,GAAG,CAAC;QAChB,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAA,2CAA4B,EAAC,UAAU,CAAC,CAAC;QAC5E,IAAA,0CAA2B,EAAC,OAAO,CAAC,WAAW,CAAC;KACjD,CAAC,CACH,EACD,CAAC,UAAU,EAAE,EAAE,CAAC,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC,CAC9E,CAAC;AACJ,CAAC","sourcesContent":["import fs from 'fs';\n\nimport { mergeLinkingOptionsAsync } from './mergeLinkingOptions';\nimport { discoverExpoModuleConfigAsync } from '../ExpoModuleConfig';\nimport {\n  type DependencyResolution,\n  scanDependenciesRecursively,\n  scanDependenciesInSearchPath,\n  filterMapResolutionResult,\n  mergeResolutionResults,\n} from '../dependencies';\nimport { PackageRevision, SearchOptions, SearchResults, SupportedPlatform } from '../types';\n\nexport async function resolveExpoModule(\n  resolution: DependencyResolution,\n  platform: SupportedPlatform,\n  excludeNames: Set<string>\n): Promise<PackageRevision | null> {\n  if (excludeNames.has(resolution.name)) {\n    return null;\n  }\n  const expoModuleConfig = await discoverExpoModuleConfigAsync(resolution.path);\n  if (expoModuleConfig && expoModuleConfig.supportsPlatform(platform)) {\n    return {\n      name: resolution.name,\n      path: resolution.path,\n      version: resolution.version,\n      config: expoModuleConfig,\n      duplicates:\n        resolution.duplicates?.map((duplicate) => ({\n          name: duplicate.name,\n          path: duplicate.path,\n          version: duplicate.version,\n        })) ?? [],\n    };\n  } else {\n    return null;\n  }\n}\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const excludeNames = new Set(options.exclude);\n\n  // custom native modules should be resolved first so that they can override other modules\n  const searchPaths =\n    options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)\n      ? [options.nativeModulesDir, ...(options.searchPaths ?? [])]\n      : (options.searchPaths ?? []);\n\n  return filterMapResolutionResult(\n    mergeResolutionResults(\n      await Promise.all([\n        ...searchPaths.map((searchPath) => scanDependenciesInSearchPath(searchPath)),\n        scanDependenciesRecursively(options.projectRoot),\n      ])\n    ),\n    (resolution) => resolveExpoModule(resolution, options.platform, excludeNames)\n  );\n}\n"]}