{"version":3,"file":"findModules.js","sourceRoot":"","sources":["../../src/autolinking/findModules.ts"],"names":[],"mappings":";;;;;AAyDA,4CAmBC;AA5ED,4CAAoB;AACpB,gDAAwB;AAExB,+DAAiE;AACjE,0DAAkF;AAClF,kDAMyB;AAGzB,qEAAqE;AACrE,MAAM,4BAA4B,GAAG,CAAC,yBAAyB,EAAE,gBAAgB,CAAC,CAAC;AAEnF,KAAK,UAAU,iBAAiB,CAC9B,UAAgC,EAChC,QAA2B,EAC3B,YAAyB;IAEzB,IAAI,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;QACtC,OAAO,IAAI,CAAC;IACd,CAAC;IACD,IAAI,gBAAgB,GAA4B,IAAI,CAAC;IACrD,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,4BAA4B,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC;QACnE,IAAI,CAAC;YACH,gBAAgB,GAAG,MAAM,IAAA,4CAAyB,EAChD,cAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,4BAA4B,CAAC,GAAG,CAAC,CAAC,CAC9D,CAAC;YACF,MAAM;QACR,CAAC;QAAC,MAAM,CAAC;YACP,oBAAoB;QACtB,CAAC;IACH,CAAC;IACD,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE,CAAC;QACpE,OAAO;YACL,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,OAAO,EAAE,UAAU,CAAC,OAAO;YAC3B,MAAM,EAAE,gBAAgB;YACxB,UAAU,EACR,UAAU,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;gBACzC,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,IAAI,EAAE,SAAS;gBACf,OAAO,EAAE,EAAE,EAAE,oCAAoC;aAClD,CAAC,CAAC,IAAI,EAAE;SACZ,CAAC;IACJ,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,CAAC;IACd,CAAC;AACH,CAAC;AAED;;GAEG;AACI,KAAK,UAAU,gBAAgB,CAAC,eAA8B;IACnE,MAAM,OAAO,GAAG,MAAM,IAAA,8CAAwB,EAAC,eAAe,CAAC,CAAC;IAChE,MAAM,YAAY,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAE9C,yFAAyF;IACzF,MAAM,WAAW,GACf,OAAO,CAAC,gBAAgB,IAAI,YAAE,CAAC,UAAU,CAAC,OAAO,CAAC,gBAAgB,CAAC;QACjE,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,EAAE,GAAG,CAAC,OAAO,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC;QAC5D,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC;IAElC,OAAO,IAAA,wCAAyB,EAC9B,IAAA,qCAAsB,EACpB,MAAM,OAAO,CAAC,GAAG,CAAC;QAChB,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,IAAA,2CAA4B,EAAC,UAAU,CAAC,CAAC;QAC5E,IAAA,0CAA2B,EAAC,OAAO,CAAC,WAAW,CAAC;KACjD,CAAC,CACH,EACD,CAAC,UAAU,EAAE,EAAE,CAAC,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,QAAQ,EAAE,YAAY,CAAC,CAC9E,CAAC;AACJ,CAAC","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nimport { mergeLinkingOptionsAsync } from './mergeLinkingOptions';\nimport { ExpoModuleConfig, loadExpoModuleConfigAsync } from '../ExpoModuleConfig';\nimport {\n  type DependencyResolution,\n  scanDependenciesRecursively,\n  scanDependenciesInSearchPath,\n  filterMapResolutionResult,\n  mergeResolutionResults,\n} from '../dependencies';\nimport { PackageRevision, SearchOptions, SearchResults, SupportedPlatform } from '../types';\n\n/** Names of Expo Module config files (highest to lowest priority) */\nconst EXPO_MODULE_CONFIG_FILENAMES = ['expo-module.config.json', 'unimodule.json'];\n\nasync function resolveExpoModule(\n  resolution: DependencyResolution,\n  platform: SupportedPlatform,\n  excludeNames: Set<string>\n): Promise<PackageRevision | null> {\n  if (excludeNames.has(resolution.name)) {\n    return null;\n  }\n  let expoModuleConfig: ExpoModuleConfig | null = null;\n  for (let idx = 0; idx < EXPO_MODULE_CONFIG_FILENAMES.length; idx++) {\n    try {\n      expoModuleConfig = await loadExpoModuleConfigAsync(\n        path.join(resolution.path, EXPO_MODULE_CONFIG_FILENAMES[idx])\n      );\n      break;\n    } catch {\n      // try the next file\n    }\n  }\n  if (expoModuleConfig && expoModuleConfig.supportsPlatform(platform)) {\n    return {\n      name: resolution.name,\n      path: resolution.path,\n      version: resolution.version,\n      config: expoModuleConfig,\n      duplicates:\n        resolution.duplicates?.map((duplicate) => ({\n          name: resolution.name,\n          path: duplicate,\n          version: '', // NOTE: Are we actually using this?\n        })) ?? [],\n    };\n  } else {\n    return null;\n  }\n}\n\n/**\n * Searches for modules to link based on given config.\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const excludeNames = new Set(options.exclude);\n\n  // custom native modules should be resolved first so that they can override other modules\n  const searchPaths =\n    options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)\n      ? [options.nativeModulesDir, ...(options.searchPaths ?? [])]\n      : (options.searchPaths ?? []);\n\n  return filterMapResolutionResult(\n    mergeResolutionResults(\n      await Promise.all([\n        ...searchPaths.map((searchPath) => scanDependenciesInSearchPath(searchPath)),\n        scanDependenciesRecursively(options.projectRoot),\n      ])\n    ),\n    (resolution) => resolveExpoModule(resolution, options.platform, excludeNames)\n  );\n}\n"]}