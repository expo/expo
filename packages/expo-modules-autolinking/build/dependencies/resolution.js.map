{"version":3,"file":"resolution.js","sourceRoot":"","sources":["../../src/dependencies/resolution.ts"],"names":[],"mappings":"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","sourcesContent":["import Module from 'node:module';\n\nimport {\n  type ResolutionResult,\n  type DependencyResolution,\n  DependencyResolutionSource,\n} from './types';\nimport {\n  type PackageJson,\n  defaultShouldIncludeDependency,\n  mergeResolutionResults,\n  loadPackageJson,\n  maybeRealpath,\n  fastJoin,\n} from './utils';\n\ndeclare module 'node:module' {\n  export function _nodeModulePaths(base: string): readonly string[];\n}\n\n// NOTE(@kitten): There's no need to search very deep for modules\n// We don't expect native modules to be excessively nested in the dependency tree\nconst MAX_DEPTH = 8;\n\nconst createNodeModulePathsCreator = () => {\n  const _nodeModulePathCache = new Map<string, string | null>();\n  return async function getNodeModulePaths(packagePath: string) {\n    const outputPaths: string[] = [];\n    const nodeModulePaths = Module._nodeModulePaths(packagePath);\n    for (let idx = 0; idx < nodeModulePaths.length; idx++) {\n      const nodeModulePath = nodeModulePaths[idx];\n      let target = _nodeModulePathCache.get(nodeModulePath);\n      if (target === undefined) {\n        target = await maybeRealpath(nodeModulePath);\n        if (idx !== 0) {\n          _nodeModulePathCache.set(nodeModulePath, target);\n        }\n      }\n      if (target != null) {\n        outputPaths.push(target);\n      }\n    }\n    return outputPaths;\n  };\n};\n\nasync function resolveDependencies(\n  packageJson: PackageJson,\n  nodeModulePaths: readonly string[],\n  depth: number,\n  shouldIncludeDependency: (dependencyName: string) => boolean\n): Promise<DependencyResolution[]> {\n  const dependencies: Record<string, string> = Object.create(null);\n  if (packageJson.dependencies != null && typeof packageJson.dependencies === 'object') {\n    Object.assign(dependencies, packageJson.dependencies);\n  }\n  // NOTE(@kitten): Also traverse devDependencies for top-level package.json\n  if (\n    depth === 0 &&\n    packageJson.devDependencies != null &&\n    typeof packageJson.devDependencies === 'object'\n  ) {\n    Object.assign(dependencies, packageJson.devDependencies);\n  }\n  if (packageJson.peerDependencies != null && typeof packageJson.peerDependencies === 'object') {\n    const peerDependenciesMeta =\n      packageJson.peerDependenciesMeta != null &&\n      typeof packageJson.peerDependenciesMeta === 'object'\n        ? (packageJson.peerDependenciesMeta as Record<string, unknown>)\n        : undefined;\n    for (const dependencyName in packageJson.peerDependencies) {\n      // NOTE(@kitten): We only check peer dependencies because some package managers auto-install them\n      // which would mean they'd have no reference in any dependencies. However, optional peer dependencies\n      // don't auto-install and we can skip them\n      if (!isOptionalPeerDependencyMeta(peerDependenciesMeta, dependencyName)) {\n        dependencies[dependencyName] = '';\n      }\n    }\n  }\n\n  const resolveDependency = async (\n    dependencyName: string\n  ): Promise<DependencyResolution | null> => {\n    for (let idx = 0; idx < nodeModulePaths.length; idx++) {\n      const originPath = fastJoin(nodeModulePaths[idx], dependencyName);\n      const nodeModulePath = await maybeRealpath(originPath);\n      if (nodeModulePath != null) {\n        return {\n          source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n          name: dependencyName,\n          version: '',\n          path: nodeModulePath,\n          originPath,\n          duplicates: null,\n          depth,\n        };\n      }\n    }\n    return null;\n  };\n\n  const modules = await Promise.all(\n    Object.keys(dependencies)\n      .filter((dependencyName) => shouldIncludeDependency(dependencyName))\n      .map((dependencyName) => resolveDependency(dependencyName))\n  );\n\n  return modules.filter((resolution) => resolution != null);\n}\n\ninterface ResolutionOptions {\n  shouldIncludeDependency?(name: string): boolean;\n  limitDepth?: number;\n}\n\nexport async function scanDependenciesRecursively(\n  rawPath: string,\n  { shouldIncludeDependency = defaultShouldIncludeDependency, limitDepth }: ResolutionOptions = {}\n): Promise<ResolutionResult> {\n  const rootPath = await maybeRealpath(rawPath);\n  if (!rootPath) {\n    return {};\n  }\n\n  const _visitedPackagePaths = new Set();\n  const getNodeModulePaths = createNodeModulePathsCreator();\n  const maxDepth = limitDepth != null ? limitDepth : MAX_DEPTH;\n\n  const recurse = async (\n    resolution: DependencyResolution,\n    depth = 0\n  ): Promise<ResolutionResult> => {\n    const searchResults: ResolutionResult = Object.create(null);\n    const [nodeModulePaths, packageJson] = await Promise.all([\n      getNodeModulePaths(resolution.path),\n      loadPackageJson(fastJoin(resolution.path, 'package.json')),\n    ]);\n    if (!packageJson) {\n      return searchResults;\n    } else {\n      resolution.version = packageJson.version || '';\n    }\n\n    const modules = await resolveDependencies(\n      packageJson,\n      nodeModulePaths,\n      depth,\n      shouldIncludeDependency\n    );\n    for (let idx = 0; idx < modules.length; idx++) {\n      searchResults[modules[idx].name] = modules[idx];\n    }\n\n    if (depth + 1 < maxDepth) {\n      const childResults = await Promise.all(\n        modules\n          .filter((resolution) => {\n            if (_visitedPackagePaths.has(resolution.path)) {\n              return false;\n            } else {\n              _visitedPackagePaths.add(resolution.path);\n              return true;\n            }\n          })\n          .map((resolution) => recurse(resolution, depth + 1))\n      );\n      return mergeResolutionResults(childResults, searchResults);\n    } else {\n      return searchResults;\n    }\n  };\n\n  const searchResults = await recurse({\n    source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n    name: '',\n    version: '',\n    path: rootPath,\n    originPath: rawPath,\n    duplicates: null,\n    depth: -1,\n  });\n\n  return searchResults;\n}\n\nconst isOptionalPeerDependencyMeta = (\n  peerDependenciesMeta: Record<string, unknown> | undefined,\n  packageName: string\n) => {\n  return (\n    peerDependenciesMeta &&\n    peerDependenciesMeta[packageName] != null &&\n    typeof peerDependenciesMeta[packageName] === 'object' &&\n    'optional' in peerDependenciesMeta[packageName] &&\n    !!peerDependenciesMeta[packageName].optional\n  );\n};\n"]}