{"version":3,"file":"resolution.js","sourceRoot":"","sources":["../../src/dependencies/resolution.ts"],"names":[],"mappings":"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","sourcesContent":["import Module from 'node:module';\n\nimport {\n  type ResolutionResult,\n  type DependencyResolution,\n  DependencyResolutionSource,\n} from './types';\nimport {\n  type PackageJson,\n  defaultShouldIncludeDependency,\n  mergeWithDuplicate,\n  loadPackageJson,\n  maybeRealpath,\n  fastJoin,\n} from './utils';\n\ndeclare module 'node:module' {\n  export function _nodeModulePaths(base: string): readonly string[];\n}\n\n// NOTE(@kitten): There's no need to search very deep for modules\n// We don't expect native modules to be excessively nested in the dependency tree\nconst MAX_DEPTH = 8;\n\nconst createNodeModulePathsCreator = () => {\n  const _nodeModulePathCache = new Map<string, string | null>();\n  return async function getNodeModulePaths(packagePath: string) {\n    const outputPaths: string[] = [];\n    const nodeModulePaths = Module._nodeModulePaths(packagePath);\n    for (let idx = 0; idx < nodeModulePaths.length; idx++) {\n      const nodeModulePath = nodeModulePaths[idx];\n      let target = _nodeModulePathCache.get(nodeModulePath);\n      if (target === undefined) {\n        target = await maybeRealpath(nodeModulePath);\n        if (idx !== 0) {\n          _nodeModulePathCache.set(nodeModulePath, target);\n        }\n      }\n      if (target != null) {\n        outputPaths.push(target);\n      }\n    }\n    return outputPaths;\n  };\n};\n\nasync function resolveDependencies(\n  packageJson: PackageJson,\n  nodeModulePaths: readonly string[],\n  depth: number,\n  shouldIncludeDependency: (dependencyName: string) => boolean\n): Promise<DependencyResolution[]> {\n  const modules: DependencyResolution[] = [];\n  let dependencies =\n    packageJson.dependencies != null && typeof packageJson.dependencies === 'object'\n      ? packageJson.dependencies\n      : {};\n\n  // NOTE(@kitten): Also traverse devDependencies for top-level package.json\n  const devDependencies =\n    packageJson.devDependencies != null && typeof packageJson.devDependencies === 'object'\n      ? (packageJson.devDependencies as Record<string, string>)\n      : null;\n  if (depth === 0 && devDependencies) {\n    dependencies = { ...dependencies, ...devDependencies };\n  }\n\n  for (const dependencyName in dependencies) {\n    if (!shouldIncludeDependency(dependencyName)) {\n      continue;\n    }\n    for (let idx = 0; idx < nodeModulePaths.length; idx++) {\n      const originPath = fastJoin(nodeModulePaths[idx], dependencyName);\n      const nodeModulePath = await maybeRealpath(originPath);\n      if (nodeModulePath != null) {\n        modules.push({\n          source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n          name: dependencyName,\n          version: '',\n          path: nodeModulePath,\n          originPath,\n          duplicates: null,\n          depth,\n        });\n        break;\n      }\n    }\n  }\n\n  if (packageJson.peerDependencies != null && typeof packageJson.peerDependencies === 'object') {\n    const peerDependenciesMeta =\n      packageJson.peerDependenciesMeta != null &&\n      typeof packageJson.peerDependenciesMeta === 'object'\n        ? (packageJson.peerDependenciesMeta as Record<string, unknown>)\n        : undefined;\n    for (const dependencyName in packageJson.peerDependencies) {\n      if (dependencyName in dependencies || !shouldIncludeDependency(dependencyName)) {\n        continue;\n      } else if (isOptionalPeerDependencyMeta(peerDependenciesMeta, dependencyName)) {\n        // NOTE(@kitten): We only check peer dependencies because some package managers auto-install them\n        // which would mean they'd have no reference in any dependencies. However, optional peer dependencies\n        // don't auto-install and we can skip them\n        continue;\n      }\n      for (let idx = 0; idx < nodeModulePaths.length; idx++) {\n        const originPath = fastJoin(nodeModulePaths[idx], dependencyName);\n        const nodeModulePath = await maybeRealpath(originPath);\n        if (nodeModulePath != null) {\n          modules.push({\n            source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n            name: dependencyName,\n            version: '',\n            path: nodeModulePath,\n            originPath,\n            duplicates: null,\n            depth,\n          });\n          break;\n        }\n      }\n    }\n  }\n\n  return modules;\n}\n\ninterface ResolutionOptions {\n  shouldIncludeDependency?(name: string): boolean;\n  limitDepth?: number;\n}\n\nexport async function scanDependenciesRecursively(\n  rawPath: string,\n  { shouldIncludeDependency = defaultShouldIncludeDependency, limitDepth }: ResolutionOptions = {}\n): Promise<ResolutionResult> {\n  const rootPath = await maybeRealpath(rawPath);\n  if (!rootPath) {\n    return {};\n  }\n\n  const modulePathsQueue: DependencyResolution[] = [\n    {\n      source: DependencyResolutionSource.RECURSIVE_RESOLUTION,\n      name: '',\n      version: '',\n      path: rootPath,\n      originPath: rawPath,\n      duplicates: null,\n      depth: -1,\n    },\n  ];\n\n  const _visitedPackagePaths = new Set();\n  const getNodeModulePaths = createNodeModulePathsCreator();\n  const searchResults: ResolutionResult = Object.create(null);\n  const maxDepth = limitDepth != null ? limitDepth : MAX_DEPTH;\n  for (let depth = 0; modulePathsQueue.length > 0 && depth < maxDepth; depth++) {\n    const resolutions = await Promise.all(\n      modulePathsQueue.map(async (resolution) => {\n        const nodeModulePaths = await getNodeModulePaths(resolution.path);\n        const packageJson = await loadPackageJson(fastJoin(resolution.path, 'package.json'));\n        if (packageJson) {\n          resolution.version = packageJson.version || '';\n          return await resolveDependencies(\n            packageJson,\n            nodeModulePaths,\n            depth,\n            shouldIncludeDependency\n          );\n        } else {\n          return [];\n        }\n      })\n    );\n\n    modulePathsQueue.length = 0;\n    for (let resolutionIdx = 0; resolutionIdx < resolutions.length; resolutionIdx++) {\n      const modules = resolutions[resolutionIdx];\n      for (let moduleIdx = 0; moduleIdx < modules.length; moduleIdx++) {\n        const resolution = modules[moduleIdx];\n        if (_visitedPackagePaths.has(resolution.path)) {\n          continue;\n        }\n\n        _visitedPackagePaths.add(resolution.path);\n        modulePathsQueue.push(resolution);\n\n        const prevEntry = searchResults[resolution.name];\n        if (prevEntry != null && resolution.path !== prevEntry.path) {\n          searchResults[resolution.name] = mergeWithDuplicate(prevEntry, resolution);\n        } else if (prevEntry == null) {\n          searchResults[resolution.name] = resolution;\n        }\n      }\n    }\n  }\n\n  return searchResults;\n}\n\nconst isOptionalPeerDependencyMeta = (\n  peerDependenciesMeta: Record<string, unknown> | undefined,\n  packageName: string\n) => {\n  return (\n    peerDependenciesMeta &&\n    peerDependenciesMeta[packageName] != null &&\n    typeof peerDependenciesMeta[packageName] === 'object' &&\n    'optional' in peerDependenciesMeta[packageName] &&\n    !!peerDependenciesMeta[packageName].optional\n  );\n};\n"]}