{"version":3,"file":"scanning.js","sourceRoot":"","sources":["../../src/dependencies/scanning.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs';\n\nimport {\n  type ResolutionResult,\n  type DependencyResolution,\n  DependencyResolutionSource,\n} from './types';\nimport { defaultShouldIncludeDependency, loadPackageJson, maybeRealpath, fastJoin } from './utils';\n\nasync function resolveDependency(\n  basePath: string,\n  dependencyName: string,\n  shouldIncludeDependency: (dependencyName: string) => boolean\n): Promise<DependencyResolution | null> {\n  if (!shouldIncludeDependency(dependencyName)) {\n    return null;\n  }\n  const originPath = fastJoin(basePath, dependencyName);\n  const realPath = await maybeRealpath(originPath);\n  const packageJson = await loadPackageJson(fastJoin(realPath || originPath, 'package.json'));\n  if (packageJson) {\n    return {\n      source: DependencyResolutionSource.SEARCH_PATH,\n      name: packageJson.name,\n      version: packageJson.version || '',\n      path: realPath || originPath,\n      originPath,\n      duplicates: null,\n      depth: 0,\n    };\n  } else if (realPath) {\n    return {\n      source: DependencyResolutionSource.SEARCH_PATH,\n      name: dependencyName.toLowerCase(),\n      version: '',\n      path: realPath,\n      originPath,\n      duplicates: null,\n      depth: 0,\n    };\n  } else {\n    return null;\n  }\n}\n\ninterface ResolutionOptions {\n  shouldIncludeDependency?(name: string): boolean;\n}\n\nexport async function scanDependenciesInSearchPath(\n  rawPath: string,\n  { shouldIncludeDependency = defaultShouldIncludeDependency }: ResolutionOptions = {}\n): Promise<ResolutionResult> {\n  const rootPath = await maybeRealpath(rawPath);\n  const searchResults: ResolutionResult = Object.create(null);\n  if (!rootPath) {\n    return searchResults;\n  }\n\n  const resolvedDependencies: DependencyResolution[] = [];\n  const dirents = await fs.promises.readdir(rootPath!, { withFileTypes: true });\n\n  await Promise.all(\n    dirents.map(async (entry) => {\n      if (entry.isSymbolicLink()) {\n        const resolution = await resolveDependency(rootPath, entry.name, shouldIncludeDependency);\n        if (resolution) resolvedDependencies.push(resolution);\n      } else if (entry.isDirectory()) {\n        if (entry.name === 'node_modules') {\n          // Ignore nested node_modules folder\n        }\n        if (entry.name[0] === '.') {\n          // Ignore hidden folders\n        } else if (entry.name[0] === '@') {\n          // NOTE: We don't expect @-scope folders to be symlinks\n          const entryPath = fastJoin(rootPath, entry.name);\n          const childEntries = await fs.promises.readdir(entryPath, { withFileTypes: true });\n          await Promise.all(\n            childEntries.map(async (child) => {\n              const dependencyName = `${entry.name}/${child.name}`;\n              if (child.isDirectory() || child.isSymbolicLink()) {\n                const resolution = await resolveDependency(\n                  rootPath,\n                  dependencyName,\n                  shouldIncludeDependency\n                );\n                if (resolution) resolvedDependencies.push(resolution);\n              }\n            })\n          );\n        } else {\n          const resolution = await resolveDependency(rootPath, entry.name, shouldIncludeDependency);\n          if (resolution) resolvedDependencies.push(resolution);\n        }\n      }\n    })\n  );\n\n  for (let idx = 0; idx < resolvedDependencies.length; idx++) {\n    const resolution = resolvedDependencies[idx];\n    const prevEntry = searchResults[resolution.name];\n    if (prevEntry != null && resolution.path !== prevEntry.path) {\n      (prevEntry.duplicates ?? (prevEntry.duplicates = [])).push({\n        name: resolution.name,\n        version: resolution.version,\n        path: resolution.path,\n        originPath: resolution.originPath,\n      });\n    } else if (prevEntry == null) {\n      searchResults[resolution.name] = resolution;\n    }\n  }\n\n  return searchResults;\n}\n"]}