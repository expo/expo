{"version":3,"file":"memoize.js","sourceRoot":"","sources":["../src/memoize.ts"],"names":[],"mappings":"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","sourcesContent":["// expo-modules-autolinking has a few memoizable operations that we don't want to repeat.\n// However, memoizing them naively means that we may hold on to the cached values for too long.\n// Instead, we wrap all calls with a `Memoizer`.\n//\n// This could use AsyncLocalStorage, but those are expensive. Instead, we only share one\n// cache for all calls, and assume that all memoizable return values may be memoized and\n// shared globally.\n//\n// Memoizers are created once per run, and then shared between all subsequent calls. They\n// are freed when their usage count to zero, after one tick.\n//\n// NOTE: If you need to debug whether the memoizer is properly used, change when the\n// `console.warn` appears to see if you have any uncached calls. We allow uncached calls\n// for backwards-compatibility, since, at worst, we have an uncached call, if the\n// Memoizer is missing.\n\nconst MAX_SIZE = 5_000;\n\nexport interface Memoizer {\n  /** Calls a function with a memoizer cache, caching its return value */\n  call<T, Args extends any[], Fn extends MemoizableAsyncFn<Args, T>>(\n    fn: Fn,\n    input: string,\n    ...args: Args\n  ): Promise<T>;\n\n  /** Invokes an async context with a memoizer cache */\n  withMemoizer<R>(callback: () => R): R;\n  withMemoizer<R, TArgs extends any[]>(callback: (...args: TArgs) => R, ...args: TArgs): R;\n}\n\nexport interface MemoizableAsyncFn<Args extends any[] = any[], T = any> {\n  (input: string, ...args: Args): Promise<T>;\n}\n\nlet currentMemoizer: Memoizer | undefined;\nlet currentContexts = 0;\n\n/** Wraps a function in a memoizer, using the memoizer async local storage */\nexport function memoize<Args extends any[], T, Fn extends MemoizableAsyncFn<Args, T>>(\n  fn: Fn\n): MemoizableAsyncFn<Args, T> {\n  return (input: string, ...args: Args) => {\n    // We either use the current memoizer (sync) or the memoize context (async)\n    if (!currentMemoizer) {\n      if (process.env.NODE_ENV === 'test') {\n        console.warn(\n          `expo-modules-autolinking: Memoized function called without memoize context (${fn.name})\\n` +\n            new Error().stack\n        );\n      }\n      return fn(input, ...args);\n    }\n    return currentMemoizer.call(fn, input, ...args);\n  };\n}\n\n/** Creates a memoizer that can provide a cache to memoized functions */\nexport function createMemoizer(): Memoizer {\n  // If we already have a memoizer, reuse it, since we can share them globally\n  if (currentMemoizer) {\n    return currentMemoizer;\n  }\n\n  const cacheByFn = new Map<MemoizableAsyncFn, Map<string, any>>();\n  const memoizer: Memoizer = {\n    async call(fn, input, ...args) {\n      let cache = cacheByFn.get(fn);\n      if (!cache) {\n        cache = new Map();\n        cacheByFn.set(fn, cache);\n      }\n      if (!cache.has(input)) {\n        const value = await memoizer.withMemoizer(fn, input, ...args);\n        if (cache.size > MAX_SIZE) {\n          cache.clear();\n        }\n        cache.set(input, value);\n        return value;\n      }\n      return cache.get(input);\n    },\n    async withMemoizer<R, TArgs extends any[] = []>(fn: (...args: TArgs) => R, ...args: TArgs) {\n      currentMemoizer = memoizer;\n      currentContexts++;\n      try {\n        return await fn(...args);\n      } finally {\n        if (currentContexts > 0) {\n          currentContexts--;\n        }\n        if (currentContexts === 0) {\n          currentMemoizer = undefined;\n        }\n      }\n    },\n  };\n  return memoizer;\n}\n\n/** @internal Used in tests to verify the memoizer was freed */\nexport function _verifyMemoizerFreed() {\n  return currentMemoizer === undefined && currentContexts === 0;\n}\n"]}