{"version":3,"file":"inlineModules.js","sourceRoot":"","sources":["../../src/inlineModules/inlineModules.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nexport type InlineModulesMirror = {\n  files: { filePath: string; watchedDirRoot: string }[];\n  swiftModuleClassNames: string[];\n  kotlinClasses: string[];\n};\n\nfunction findUpProjectRoot(cwd: string): string | null {\n  const packageJsonPath = path.resolve(cwd, './package.json');\n  if (fs.existsSync(packageJsonPath)) {\n    return path.dirname(packageJsonPath);\n  }\n\n  const parent = path.dirname(cwd);\n  if (parent === cwd) return null;\n\n  return findUpProjectRoot(parent);\n}\n\nexport async function getAppRoot(): Promise<string> {\n  const cwd = process.cwd();\n  const result = findUpProjectRoot(cwd);\n  if (!result) {\n    throw new Error(`Couldn't find \"package.json\" up from path \"${cwd}\"`);\n  }\n  return result;\n}\n\nconst nativeExtensions = ['.kt', '.swift'];\n\nfunction isValidInlineModuleFileName(fileName: string): boolean {\n  const ext = path.extname(fileName);\n  if (!nativeExtensions.includes(ext)) {\n    return false;\n  }\n\n  const baseName = path.basename(fileName, ext);\n  return !baseName.includes('.');\n}\n\nfunction trimExtension(fileName: string) {\n  return fileName.substring(0, fileName.lastIndexOf('.'));\n}\n\nasync function getKotlinFileNameWithItsPackage(absoluteFilePath: string): Promise<string> {\n  const HEADER_SIZE = 512;\n  const buffer = Buffer.alloc(HEADER_SIZE);\n\n  const fileHandle = await fs.promises.open(absoluteFilePath, 'r');\n  try {\n    const { bytesRead } = await fileHandle.read(buffer, 0, HEADER_SIZE, 0);\n    const header = buffer.toString('utf8', 0, bytesRead);\n\n    // We want to find `package some.package` and capture the `some.package` from it.\n    const pacakgeRegex = /^package\\s+([\\w.]+)/m;\n    const packageMatch = header.match(pacakgeRegex);\n    if (!packageMatch) {\n      return '';\n    }\n\n    return `${packageMatch[1]}.${trimExtension(path.basename(absoluteFilePath))}`;\n  } finally {\n    await fileHandle.close();\n  }\n}\n\nfunction getSwiftModuleClassName(absoluteFilePath: string): string {\n  return trimExtension(path.basename(absoluteFilePath));\n}\n\nexport async function getMirrorStateObject(\n  watchedDirectories: string[]\n): Promise<InlineModulesMirror> {\n  const appRoot = await getAppRoot();\n  const inlineModulesMirror: InlineModulesMirror = {\n    kotlinClasses: [],\n    swiftModuleClassNames: [],\n    files: [],\n  };\n\n  const recursivelyScanDirectory = async (absoluteDirPath: string, watchedDirRoot: string) => {\n    const dir = await fs.promises.opendir(absoluteDirPath);\n    for await (const dirent of dir) {\n      const absoluteDirentPath = path.resolve(absoluteDirPath, dirent.name);\n      if (dirent.isDirectory()) {\n        await recursivelyScanDirectory(absoluteDirentPath, watchedDirRoot);\n      }\n      if (!dirent.isFile() || !isValidInlineModuleFileName(dirent.name)) {\n        continue;\n      }\n\n      if (/\\.(kt)$/.test(dirent.name)) {\n        const kotlinFileWithPackage = await getKotlinFileNameWithItsPackage(absoluteDirentPath);\n        inlineModulesMirror.kotlinClasses.push(kotlinFileWithPackage);\n        inlineModulesMirror.files.push({ filePath: absoluteDirentPath, watchedDirRoot });\n      } else if (/\\.(swift)$/.test(dirent.name)) {\n        const swiftClassName = getSwiftModuleClassName(absoluteDirentPath);\n        inlineModulesMirror.swiftModuleClassNames.push(swiftClassName);\n        inlineModulesMirror.files.push({ filePath: absoluteDirentPath, watchedDirRoot });\n      }\n    }\n  };\n\n  for (const dir of watchedDirectories ?? []) {\n    const absoluteDirPath = path.resolve(appRoot, dir);\n    const watchedDirRoot = fs.realpathSync(path.resolve(appRoot, dir));\n\n    await recursivelyScanDirectory(absoluteDirPath, watchedDirRoot);\n  }\n  return inlineModulesMirror;\n}\n"]}