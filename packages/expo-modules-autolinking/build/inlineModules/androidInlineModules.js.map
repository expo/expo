{"version":3,"file":"androidInlineModules.js","sourceRoot":"","sources":["../../src/inlineModules/androidInlineModules.ts"],"names":[],"mappings":";;;;;AAKA,kEAaC;AAUD,sEA6BC;AAzDD,4CAAoB;AACpB,gDAAwB;AAExB,mDAAuD;AAEhD,KAAK,UAAU,2BAA2B,CAAC,UAAkB,EAAE,WAAqB;IACzF,MAAM,mBAAmB,GAAG,MAAM,IAAA,oCAAoB,EAAC,WAAW,CAAC,CAAC;IAEpE,KAAK,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE,IAAI,mBAAmB,CAAC,KAAK,EAAE,CAAC;QACrE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YAC9B,SAAS;QACX,CAAC;QACD,MAAM,gCAAgC,GAAG,cAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QACjF,MAAM,UAAU,GAAG,cAAI,CAAC,OAAO,CAAC,UAAU,EAAE,gCAAgC,CAAC,CAAC;QAE9E,YAAE,CAAC,SAAS,CAAC,cAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QAC5D,YAAE,CAAC,WAAW,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;IACvC,CAAC;AACH,CAAC;AAED,SAAS,YAAY,CAAC,oBAA4B;IAChD,MAAM,KAAK,GAAG,oBAAoB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IACpD,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC;QACrD,OAAO,oBAAoB,CAAC;IAC9B,CAAC;IACD,OAAO,oBAAoB,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AACnD,CAAC;AAEM,KAAK,UAAU,6BAA6B,CACjD,qBAA6B,EAC7B,WAAqB;IAErB,MAAM,mBAAmB,GAAG,MAAM,IAAA,oCAAoB,EAAC,WAAW,CAAC,CAAC;IACpE,MAAM,WAAW,GAAG;;;;;;;;;;;;;;EAcpB,mBAAmB,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,SAAS,WAAW,YAAY,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;;;;;;CAMjI,CAAC;IAEA,YAAE,CAAC,SAAS,CAAC,qBAAqB,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACzD,YAAE,CAAC,aAAa,CAAC,cAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,4BAA4B,CAAC,EAAE,WAAW,CAAC,CAAC;AACnG,CAAC","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nimport { getMirrorStateObject } from './inlineModules';\n\nexport async function createSymlinksToKotlinFiles(mirrorPath: string, watchedDirs: string[]) {\n  const inlineModulesObject = await getMirrorStateObject(watchedDirs);\n\n  for (const { filePath, watchedDirRoot } of inlineModulesObject.files) {\n    if (!filePath.endsWith('.kt')) {\n      continue;\n    }\n    const filePathRelativeToWatchedDirRoot = path.relative(watchedDirRoot, filePath);\n    const targetPath = path.resolve(mirrorPath, filePathRelativeToWatchedDirRoot);\n\n    fs.mkdirSync(path.dirname(targetPath), { recursive: true });\n    fs.symlinkSync(filePath, targetPath);\n  }\n}\n\nfunction getClassName(classNameWithPackage: string): string {\n  const index = classNameWithPackage.lastIndexOf('.');\n  if (index < 0 || index > classNameWithPackage.length) {\n    return classNameWithPackage;\n  }\n  return classNameWithPackage.substring(index + 1);\n}\n\nexport async function generateInlineModulesListFile(\n  inlineModulesListPath: string,\n  watchedDirs: string[]\n) {\n  const inlineModulesObject = await getMirrorStateObject(watchedDirs);\n  const fileContent = `package inline.modules;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport expo.modules.kotlin.ModulesProvider;\nimport expo.modules.kotlin.modules.Module;\n\npublic class ExpoInlineModulesList implements ModulesProvider {\n\n  @Override\n  public Map<Class<? extends Module>, String> getModulesMap() {\n    return Map.of(\n${inlineModulesObject.kotlinClasses.map((moduleClass) => `      ${moduleClass}.class, \"${getClassName(moduleClass)}\"`).join(',\\n')}\n    );\n  }\n\n}\n\n`;\n\n  fs.mkdirSync(inlineModulesListPath, { recursive: true });\n  fs.writeFileSync(path.resolve(inlineModulesListPath, 'ExpoInlineModulesList.java'), fileContent);\n}\n"]}