{"version":3,"file":"androidInlineModules.js","sourceRoot":"","sources":["../../src/inlineModules/androidInlineModules.ts"],"names":[],"mappings":";;;;;AAKA,kEAgBC;AAUD,sEAuCC;AAtED,4CAAoB;AACpB,gDAAwB;AAExB,mDAAuD;AAEhD,KAAK,UAAU,2BAA2B,CAC/C,UAAkB,EAClB,kBAA4B;IAE5B,MAAM,mBAAmB,GAAG,MAAM,IAAA,oCAAoB,EAAC,kBAAkB,CAAC,CAAC;IAE3E,KAAK,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE,IAAI,mBAAmB,CAAC,KAAK,EAAE,CAAC;QACrE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YAC9B,SAAS;QACX,CAAC;QACD,MAAM,gCAAgC,GAAG,cAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;QACjF,MAAM,UAAU,GAAG,cAAI,CAAC,OAAO,CAAC,UAAU,EAAE,gCAAgC,CAAC,CAAC;QAE9E,MAAM,YAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;QACvE,MAAM,YAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;IAClD,CAAC;AACH,CAAC;AAED,SAAS,YAAY,CAAC,oBAA4B;IAChD,MAAM,KAAK,GAAG,oBAAoB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IACpD,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC;QACrD,OAAO,oBAAoB,CAAC;IAC9B,CAAC;IACD,OAAO,oBAAoB,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AACnD,CAAC;AAEM,KAAK,UAAU,6BAA6B,CACjD,qBAA6B,EAC7B,kBAA4B;IAE5B,MAAM,mBAAmB,GAAG,MAAM,IAAA,oCAAoB,EAAC,kBAAkB,CAAC,CAAC;IAC3E,MAAM,WAAW,GAAG;;;;;;;;;;;;;;;;;EAiBpB,mBAAmB,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,SAAS,WAAW,YAAY,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;;;;;;;;;;CAUjI,CAAC;IAEA,MAAM,YAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,qBAAqB,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACpE,MAAM,YAAE,CAAC,QAAQ,CAAC,SAAS,CACzB,cAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,4BAA4B,CAAC,EACjE,WAAW,CACZ,CAAC;AACJ,CAAC","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nimport { getMirrorStateObject } from './inlineModules';\n\nexport async function createSymlinksToKotlinFiles(\n  mirrorPath: string,\n  watchedDirectories: string[]\n) {\n  const inlineModulesObject = await getMirrorStateObject(watchedDirectories);\n\n  for (const { filePath, watchedDirRoot } of inlineModulesObject.files) {\n    if (!filePath.endsWith('.kt')) {\n      continue;\n    }\n    const filePathRelativeToWatchedDirRoot = path.relative(watchedDirRoot, filePath);\n    const targetPath = path.resolve(mirrorPath, filePathRelativeToWatchedDirRoot);\n\n    await fs.promises.mkdir(path.dirname(targetPath), { recursive: true });\n    await fs.promises.symlink(filePath, targetPath);\n  }\n}\n\nfunction getClassName(classNameWithPackage: string): string {\n  const index = classNameWithPackage.lastIndexOf('.');\n  if (index < 0 || index > classNameWithPackage.length) {\n    return classNameWithPackage;\n  }\n  return classNameWithPackage.substring(index + 1);\n}\n\nexport async function generateInlineModulesListFile(\n  inlineModulesListPath: string,\n  watchedDirectories: string[]\n) {\n  const inlineModulesObject = await getMirrorStateObject(watchedDirectories);\n  const fileContent = `package inline.modules;\n\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport expo.modules.kotlin.ModulesProvider;\nimport expo.modules.kotlin.modules.Module;\nimport expo.modules.kotlin.services.Service;\n\npublic class ExpoInlineModulesList implements ModulesProvider {\n\n  @Override\n  public Map<Class<? extends Module>, String> getModulesMap() {\n    return Map.of(\n${inlineModulesObject.kotlinClasses.map((moduleClass) => `      ${moduleClass}.class, \"${getClassName(moduleClass)}\"`).join(',\\n')}\n    );\n  }\n\n  @Override\n  public List<Class<? extends @NotNull Service>> getServices() {\n    return new ArrayList<>();\n  }\n}\n\n`;\n\n  await fs.promises.mkdir(inlineModulesListPath, { recursive: true });\n  await fs.promises.writeFile(\n    path.resolve(inlineModulesListPath, 'ExpoInlineModulesList.java'),\n    fileContent\n  );\n}\n"]}