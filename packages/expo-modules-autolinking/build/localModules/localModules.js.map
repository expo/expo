{"version":3,"file":"inlineModules.js","sourceRoot":"","sources":["../../src/inlineModules/inlineModules.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\nexport type InlineModulesMirror = {\n  files: { filePath: string; watchedDirRoot: string }[];\n  swiftModuleClassNames: string[];\n  kotlinClasses: string[];\n};\n\nfunction findUpProjectRoot(cwd: string): string | null {\n  const packageJsonPath = path.resolve(cwd, './package.json');\n  if (fs.existsSync(packageJsonPath)) {\n    return path.dirname(packageJsonPath);\n  }\n\n  const parent = path.dirname(cwd);\n  if (parent === cwd) return null;\n\n  return findUpProjectRoot(parent);\n}\n\nexport async function getAppRoot(): Promise<string> {\n  const cwd = process.cwd();\n  const result = findUpProjectRoot(cwd);\n  if (!result) {\n    throw new Error(`Couldn't find \"package.json\" up from path \"${cwd}\"`);\n  }\n  return result;\n}\n\nconst nativeExtensions = ['.kt', '.swift'];\n\nfunction isValidLocalModuleFileName(fileName: string): boolean {\n  let numberOfDots = 0;\n  for (const character of fileName) {\n    if (character === '.') {\n      numberOfDots += 1;\n    }\n  }\n\n  let hasNativeExtension: boolean = false;\n  for (const extension of nativeExtensions) {\n    if (fileName.endsWith(extension)) {\n      hasNativeExtension = true;\n      break;\n    }\n  }\n\n  return hasNativeExtension && numberOfDots === 1;\n}\n\nfunction trimExtension(fileName: string) {\n  return fileName.substring(0, fileName.lastIndexOf('.'));\n}\n\nfunction getKotlinFileNameWithItsPackage(absoluteFilePath: string): string {\n  const pacakgeRegex = /^package\\s+/;\n  const lines = fs.readFileSync(absoluteFilePath).toString().split('\\n');\n  const packageLine = lines.findIndex((line) => pacakgeRegex.test(line));\n  if (packageLine < 0) {\n    return '';\n  }\n  const packageName = lines[packageLine].substring('package '.length);\n  return `${packageName}.${trimExtension(path.basename(absoluteFilePath))}`;\n}\n\nfunction getSwiftModuleClassName(absoluteFilePath: string): string {\n  return trimExtension(path.basename(absoluteFilePath));\n}\n\nexport async function getMirrorStateObject(watchedDirectories: string[]): Promise<InlineModulesMirror> {\n  const appRoot = await getAppRoot();\n  const inlineModulesMirror: InlineModulesMirror = {\n    kotlinClasses: [],\n    swiftModuleClassNames: [],\n    files: [],\n  };\n\n  const recursivelyScanDirectory = async (absoluteDirPath: string, watchedDirRoot: string) => {\n    const dir = fs.opendirSync(absoluteDirPath);\n    for await (const dirent of dir) {\n      const absoluteDirentPath = path.resolve(absoluteDirPath, dirent.name);\n      if (dirent.isDirectory()) {\n        await recursivelyScanDirectory(absoluteDirentPath, watchedDirRoot);\n      }\n      if (!dirent.isFile() || !isValidLocalModuleFileName(dirent.name)) {\n        continue;\n      }\n\n      if (/\\.(kt)$/.test(dirent.name)) {\n        const kotlinFileWithPackage = getKotlinFileNameWithItsPackage(absoluteDirentPath);\n        inlineModulesMirror.kotlinClasses.push(kotlinFileWithPackage);\n        inlineModulesMirror.files.push({ filePath: absoluteDirentPath, watchedDirRoot });\n      } else if (/\\.(swift)$/.test(dirent.name)) {\n        const swiftClassName = getSwiftModuleClassName(absoluteDirentPath);\n        inlineModulesMirror.swiftModuleClassNames.push(swiftClassName);\n        inlineModulesMirror.files.push({ filePath: absoluteDirentPath, watchedDirRoot });\n      }\n    }\n  };\n\n  for (const dir of watchedDirectories ?? []) {\n    await recursivelyScanDirectory(\n      path.resolve(appRoot, dir),\n      fs.realpathSync(path.resolve(appRoot, dir))\n    );\n  }\n  return inlineModulesMirror;\n}\n"]}