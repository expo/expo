{"version":3,"file":"autolinking.js","sourceRoot":"","sources":["../src/autolinking.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk';\nimport glob from 'fast-glob';\nimport findUp from 'find-up';\nimport fs from 'fs-extra';\nimport { createRequire } from 'module';\nimport path from 'path';\n\nimport { requireAndResolveExpoModuleConfig } from './ExpoModuleConfig';\nimport {\n  GenerateOptions,\n  ModuleDescriptor,\n  PackageRevision,\n  ResolveOptions,\n  SearchOptions,\n  SearchResults,\n} from './types';\n\n// Names of the config files. From lowest to highest priority.\nconst EXPO_MODULE_CONFIG_FILENAMES = ['unimodule.json', 'expo-module.config.json'];\n\n/**\n * Path to the `package.json` of the closest project in the current working dir.\n */\nconst projectPackageJsonPath = findUp.sync('package.json', { cwd: process.cwd() }) as string;\n\n// This won't happen in usual scenarios, but we need to unwrap the optional path :)\nif (!projectPackageJsonPath) {\n  throw new Error(`Couldn't find \"package.json\" up from path \"${process.cwd()}\"`);\n}\n\n/**\n * Custom `require` that resolves from the current working dir instead of this script path.\n * **Requires Node v12.2.0**\n */\nconst projectRequire = createRequire(projectPackageJsonPath);\n\n/**\n * Resolves autolinking search paths. If none is provided, it accumulates all node_modules when\n * going up through the path components. This makes workspaces work out-of-the-box without any configs.\n */\nexport async function resolveSearchPathsAsync(\n  searchPaths: string[] | null,\n  cwd: string\n): Promise<string[]> {\n  return searchPaths && searchPaths.length > 0\n    ? searchPaths.map((searchPath) => path.resolve(cwd, searchPath))\n    : await findDefaultPathsAsync(cwd);\n}\n\n/**\n * Looks up for workspace's `node_modules` paths.\n */\nexport async function findDefaultPathsAsync(cwd: string): Promise<string[]> {\n  const paths = [];\n  let dir = cwd;\n  let pkgJsonPath: string | undefined;\n\n  while ((pkgJsonPath = await findUp('package.json', { cwd: dir }))) {\n    dir = path.dirname(path.dirname(pkgJsonPath));\n    paths.push(path.join(pkgJsonPath, '..', 'node_modules'));\n  }\n  return paths;\n}\n\n// TODO: (barthap): WIP, just a temporary solution, improve this\n// make it work the same way as findDefaultPathsAsync\n// @returns undefined if custom modules dir doesn't exist\nexport async function resolveNativeModulesDirAsync(\n  nativeModulesDir: string | undefined,\n  cwd: string\n): Promise<string | undefined> {\n  // const up = await findUp('package.json', { cwd });\n  // if (!up) {\n  //   return undefined;\n  // }\n  // const resolvedPath = path.join(up, '..', nativeModulesDir || 'modules');\n  // console.log(resolvedPath);\n  // return fs.existsSync(resolvedPath) ? resolvedPath : 'xdd';\n  return path.resolve(nativeModulesDir || 'modules');\n}\n\n/**\n * Adds {@link revision} to the {@link results} map\n * or to package duplicates if it already exists.\n * @param results [mutable] yet resolved packages map\n * @param name resolved package name\n * @param revision resolved package revision\n */\nfunction addRevisionToResults(\n  results: Map<string, PackageRevision>,\n  name: string,\n  revision: PackageRevision\n): void {\n  if (!results.has(name)) {\n    // The revision that was found first will be the main one.\n    // An array of duplicates and the config are needed only here.\n    results.set(name, {\n      ...revision,\n      duplicates: [],\n    });\n  } else if (\n    results.get(name)?.path !== revision.path &&\n    results.get(name)?.duplicates?.every(({ path }) => path !== revision.path)\n  ) {\n    const { config, duplicates, ...duplicateEntry } = revision;\n    results.get(name)?.duplicates?.push(duplicateEntry);\n  }\n}\n\n/**\n * Returns paths to the highest priority config files, relative to the {@link searchPath}.\n * @example\n * ```\n * // Given the following file exists: /foo/myapp/modules/mymodule/expo-module.config.json\n * await findPackagesConfigPathsAsync('/foo/myapp/modules');\n * // returns ['mymodule/expo-module.config.json']\n * ```\n */\nasync function findPackagesConfigPathsAsync(searchPath: string): Promise<string[]> {\n  const bracedFilenames = '{' + EXPO_MODULE_CONFIG_FILENAMES.join(',') + '}';\n  const paths = await glob([`*/${bracedFilenames}`, `@*/*/${bracedFilenames}`], {\n    cwd: searchPath,\n  });\n\n  // If the package has multiple configs (e.g. `unimodule.json` and `expo-module.config.json` during the transition time)\n  // then we want to give `expo-module.config.json` the priority.\n  return Object.values(\n    paths.reduce<Record<string, string>>((acc, configPath) => {\n      const dirname = path.dirname(configPath);\n\n      if (!acc[dirname] || configPriority(configPath) > configPriority(acc[dirname])) {\n        acc[dirname] = configPath;\n      }\n      return acc;\n    }, {})\n  );\n}\n\n/**\n * Resolves package name and version for the given {@link packagePath} from its `package.json`.\n * if {@link options.fallbackToDirName} is true, it returns the dir name when `package.json` doesn't exist.\n */\nfunction resolvePackageNameAndVersion(\n  packagePath: string,\n  options: { fallbackToDirName?: boolean } = {}\n): { name: string; version: string } {\n  try {\n    const { name, version } = require(path.join(packagePath, 'package.json'));\n    return { name, version };\n  } catch (e) {\n    if (options.fallbackToDirName) {\n      // we don't have the package.json name, so we'll use the directory name\n      return {\n        name: path.basename(packagePath),\n        version: 'UNVERSIONED',\n      };\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Searches for modules to link based on given config.\n * TODO: (barthap): still duplicated code\n */\nexport async function findModulesAsync(providedOptions: SearchOptions): Promise<SearchResults> {\n  const options = await mergeLinkingOptionsAsync(providedOptions);\n  const results: Map<string, PackageRevision> = new Map();\n  const nativeModuleResults: Map<string, PackageRevision> = new Map();\n\n  if (options.nativeModulesDir && fs.existsSync(options.nativeModulesDir)) {\n    const packageConfigPaths = await findPackagesConfigPathsAsync(options.nativeModulesDir);\n\n    for (const packageConfigPath of packageConfigPaths) {\n      const packagePath = await fs.realpath(\n        path.join(options.nativeModulesDir, path.dirname(packageConfigPath))\n      );\n      const expoModuleConfig = requireAndResolveExpoModuleConfig(\n        path.join(packagePath, path.basename(packageConfigPath))\n      );\n\n      if (!expoModuleConfig.supportsPlatform(options.platform)) {\n        continue;\n      }\n\n      const { name, version } = resolvePackageNameAndVersion(packagePath, {\n        fallbackToDirName: true,\n      });\n\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n        config: expoModuleConfig,\n      };\n\n      addRevisionToResults(nativeModuleResults, name, currentRevision);\n    }\n  }\n\n  for (const searchPath of options.searchPaths) {\n    // nativeModulesDir was already processed, so we skip it\n    // in case someone specified it in the search paths.\n    if (options.nativeModulesDir === searchPath) {\n      continue;\n    }\n\n    const packageConfigPaths = await findPackagesConfigPathsAsync(searchPath);\n\n    for (const packageConfigPath of packageConfigPaths) {\n      const packagePath = await fs.realpath(path.join(searchPath, path.dirname(packageConfigPath)));\n      const expoModuleConfig = requireAndResolveExpoModuleConfig(\n        path.join(packagePath, path.basename(packageConfigPath))\n      );\n      const { name, version } = resolvePackageNameAndVersion(packagePath);\n\n      if (options.exclude?.includes(name) || !expoModuleConfig.supportsPlatform(options.platform)) {\n        continue;\n      }\n\n      const currentRevision: PackageRevision = {\n        path: packagePath,\n        version,\n        config: expoModuleConfig,\n      };\n\n      addRevisionToResults(results, name, currentRevision);\n    }\n  }\n\n  // It doesn't make much sense to strip modules if there is only one search path.\n  // Workspace root usually doesn't specify all its dependencies (see Expo Go),\n  // so in this case we should link everything.\n  const searchResults: SearchResults = Object.fromEntries(results.entries());\n  const filteredResults =\n    options.searchPaths.length > 1\n      ? filterToProjectDependencies(searchResults, providedOptions)\n      : searchResults;\n\n  // Custom native modules are not filtered out\n  // when they're not specified in package.json dependencies.\n  // Moreover, they override the native modules from the dependencies.\n  return {\n    ...filteredResults,\n    ...Object.fromEntries(nativeModuleResults.entries()),\n  };\n}\n\n/**\n * Filters out packages that are not the dependencies of the project.\n */\nfunction filterToProjectDependencies(\n  results: SearchResults,\n  options: Pick<SearchOptions, 'silent'> = {}\n) {\n  const filteredResults: SearchResults = {};\n  const visitedPackages = new Set<string>();\n\n  // Helper for traversing the dependency hierarchy.\n  function visitPackage(packageJsonPath: string) {\n    const packageJson = require(packageJsonPath);\n\n    // Prevent getting into the recursive loop.\n    if (visitedPackages.has(packageJson.name)) {\n      return;\n    }\n    visitedPackages.add(packageJson.name);\n\n    // Iterate over the dependencies to find transitive modules.\n    for (const dependencyName in packageJson.dependencies) {\n      const dependencyResult = results[dependencyName];\n\n      if (!filteredResults[dependencyName]) {\n        let dependencyPackageJsonPath: string;\n\n        if (dependencyResult) {\n          filteredResults[dependencyName] = dependencyResult;\n          dependencyPackageJsonPath = path.join(dependencyResult.path, 'package.json');\n        } else {\n          try {\n            dependencyPackageJsonPath = projectRequire.resolve(`${dependencyName}/package.json`);\n          } catch (error: any) {\n            // Some packages don't include package.json in its `exports` field,\n            // but none of our packages do that, so it seems fine to just ignore that type of error.\n            // Related issue: https://github.com/react-native-community/cli/issues/1168\n            if (!options.silent && error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED') {\n              console.warn(\n                chalk.yellow(`⚠️  Cannot resolve the path to \"${dependencyName}\" package.`)\n              );\n            }\n            continue;\n          }\n        }\n\n        // Visit the dependency package.\n        visitPackage(dependencyPackageJsonPath);\n      }\n    }\n  }\n\n  // Visit project's package.\n  visitPackage(projectPackageJsonPath);\n\n  return filteredResults;\n}\n\n/**\n * Merges autolinking options from different sources (the later the higher priority)\n * - options defined in package.json's `expo.autolinking` field\n * - platform-specific options from the above (e.g. `expo.autolinking.ios`)\n * - options provided to the CLI command\n */\nexport async function mergeLinkingOptionsAsync<OptionsType extends SearchOptions>(\n  providedOptions: OptionsType\n): Promise<OptionsType> {\n  const packageJson = require(projectPackageJsonPath);\n  const baseOptions = packageJson.expo?.autolinking;\n  const platformOptions = providedOptions.platform && baseOptions?.[providedOptions.platform];\n  const finalOptions = Object.assign(\n    {},\n    baseOptions,\n    platformOptions,\n    providedOptions\n  ) as OptionsType;\n\n  // Makes provided paths absolute or falls back to default paths if none was provided.\n  finalOptions.searchPaths = await resolveSearchPathsAsync(finalOptions.searchPaths, process.cwd());\n\n  finalOptions.nativeModulesDir = await resolveNativeModulesDirAsync(\n    finalOptions.nativeModulesDir,\n    process.cwd()\n  );\n\n  // TODO: (barthap): remove these console.logs when done ;)\n  console.log(finalOptions.searchPaths);\n  console.log(finalOptions.nativeModulesDir);\n\n  return finalOptions;\n}\n\n/**\n * Verifies the search results by checking whether there are no duplicates.\n */\nexport function verifySearchResults(searchResults: SearchResults): number {\n  const cwd = process.cwd();\n  const relativePath: (pkg: PackageRevision) => string = (pkg) => path.relative(cwd, pkg.path);\n  let counter = 0;\n\n  for (const moduleName in searchResults) {\n    const revision = searchResults[moduleName];\n\n    if (revision.duplicates?.length) {\n      console.warn(`⚠️  Found multiple revisions of ${chalk.green(moduleName)}`);\n      console.log(` - ${chalk.magenta(relativePath(revision))} (${chalk.cyan(revision.version)})`);\n\n      for (const duplicate of revision.duplicates) {\n        console.log(` - ${chalk.gray(relativePath(duplicate))} (${chalk.gray(duplicate.version)})`);\n      }\n      counter++;\n    }\n  }\n  if (counter > 0) {\n    console.warn(\n      '⚠️  Please get rid of multiple revisions as it may introduce some side effects or compatibility issues'\n    );\n  }\n  return counter;\n}\n\n/**\n * Resolves search results to a list of platform-specific configuration.\n */\nexport async function resolveModulesAsync(\n  searchResults: SearchResults,\n  options: ResolveOptions\n): Promise<ModuleDescriptor[]> {\n  const platformLinking = require(`./platforms/${options.platform}`);\n\n  return (\n    await Promise.all(\n      Object.entries(searchResults).map(async ([packageName, revision]) => {\n        const resolvedModule = await platformLinking.resolveModuleAsync(\n          packageName,\n          revision,\n          options\n        );\n        return resolvedModule\n          ? {\n              packageName,\n              packageVersion: revision.version,\n              ...resolvedModule,\n            }\n          : null;\n      })\n    )\n  )\n    .filter(Boolean)\n    .sort((a, b) => a.packageName.localeCompare(b.packageName));\n}\n\n/**\n * Generates a source file listing all packages to link.\n * Right know it works only for Android platform.\n */\nexport async function generatePackageListAsync(\n  modules: ModuleDescriptor[],\n  options: GenerateOptions\n) {\n  try {\n    const platformLinking = require(`./platforms/${options.platform}`);\n    await platformLinking.generatePackageListAsync(modules, options.target, options.namespace);\n  } catch (e) {\n    console.error(\n      chalk.red(`Generating package list is not available for platform: ${options.platform}`)\n    );\n    throw e;\n  }\n}\n\n/**\n * Returns the priority of the config at given path. Higher number means higher priority.\n */\nfunction configPriority(fullpath: string): number {\n  return EXPO_MODULE_CONFIG_FILENAMES.indexOf(path.basename(fullpath));\n}\n"]}