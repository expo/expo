{"version":3,"file":"getRandomValues.js","sourceRoot":"","sources":["../src/getRandomValues.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,IAAI,yBAAyB,EAAE,MAAM,aAAa,CAAC;AAE3E,MAAM,gBAAgB,GAAG,KAAK,CAAC;AAW/B;;;;;;GAMG;AACH,MAAM,CAAC,OAAO,UAAU,eAAe,CAAiC,MAAc;IACpF,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACzB,MAAM,IAAI,SAAS,CACjB,gFAAgF,CACjF,CAAC;IACJ,CAAC;IAED,IACE,CAAC,CAAC,MAAM,YAAY,SAAS,CAAC;QAC9B,CAAC,CAAC,MAAM,YAAY,UAAU,CAAC;QAC/B,CAAC,CAAC,MAAM,YAAY,UAAU,CAAC;QAC/B,CAAC,CAAC,MAAM,YAAY,WAAW,CAAC;QAChC,CAAC,CAAC,MAAM,YAAY,UAAU,CAAC;QAC/B,CAAC,CAAC,MAAM,YAAY,WAAW,CAAC;QAChC,CAAC,CAAC,MAAM,YAAY,iBAAiB,CAAC,EACtC,CAAC;QACD,MAAM,IAAI,SAAS,CAAC,6DAA6D,CAAC,CAAC;IACrF,CAAC;IAED,IAAI,MAAM,CAAC,UAAU,GAAG,gBAAgB,EAAE,CAAC;QACzC,MAAM,IAAI,kBAAkB,CAC1B,uCAAuC,MAAM,CAAC,UAAU,oEAAoE,gBAAgB,GAAG,CAChJ,CAAC;IACJ,CAAC;IAED,IAAI,CAAC;QACH,0FAA0F;QAC1F,yBAAyB,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAAC,MAAM,CAAC;QACP,2EAA2E;QAC3E,OAAO,CAAC,IAAI,CAAC,8EAA8E,CAAC,CAAC;QAC7F,OAAO,uBAAuB,CAAC,MAAM,CAAC,CAAC;IACzC,CAAC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,uBAAuB,CAA8B,MAAc;IACjF,sEAAsE;IACtE,MAAM,QAAQ,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;IACrF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACzC,sFAAsF;QACtF,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC;IACpC,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,kBAAmB,SAAQ,KAAK;IACpC,IAAI,GAAG,oBAAoB,CAAC;IAC5B,IAAI,GAAG,EAAE,CAAC,CAAC,qBAAqB;CACjC","sourcesContent":["import { getRandomValues as expoCryptoGetRandomValues } from 'expo-crypto';\n\nconst MAX_RANDOM_BYTES = 65536;\n\ntype IntegerArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\n/**\n * An implementation of Crypto.getRandomValues that uses expo-random's secure random generator if\n * available and falls back to Math.random (cryptographically insecure) when synchronous bridged\n * methods are unavailable.\n *\n * See https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues\n */\nexport default function getRandomValues<TArray extends ArrayBufferView>(values: TArray): TArray {\n  if (arguments.length < 1) {\n    throw new TypeError(\n      `An ArrayBuffer view must be specified as the destination for the random values`\n    );\n  }\n\n  if (\n    !(values instanceof Int8Array) &&\n    !(values instanceof Uint8Array) &&\n    !(values instanceof Int16Array) &&\n    !(values instanceof Uint16Array) &&\n    !(values instanceof Int32Array) &&\n    !(values instanceof Uint32Array) &&\n    !(values instanceof Uint8ClampedArray)\n  ) {\n    throw new TypeError(`The provided ArrayBuffer view is not an integer-typed array`);\n  }\n\n  if (values.byteLength > MAX_RANDOM_BYTES) {\n    throw new QuotaExceededError(\n      `The ArrayBuffer view's byte length (${values.byteLength}) exceeds the number of bytes of entropy available via this API (${MAX_RANDOM_BYTES})`\n    );\n  }\n\n  try {\n    // NOTE: Consider implementing `fillRandomBytes` to populate the given TypedArray directly\n    expoCryptoGetRandomValues(values);\n  } catch {\n    // TODO: rethrow the error if it's not due to a lack of synchronous methods\n    console.warn(`Random.getRandomBytes is not supported; falling back to insecure Math.random`);\n    return getRandomValuesInsecure(values);\n  }\n\n  return values;\n}\n\nexport function getRandomValuesInsecure<TArray extends IntegerArray>(values: TArray): TArray {\n  // Write random bytes to the given TypedArray's underlying ArrayBuffer\n  const byteView = new Uint8Array(values.buffer, values.byteOffset, values.byteLength);\n  for (let i = 0; i < byteView.length; i++) {\n    // The range of Math.random() is [0, 1) and the ToUint8 abstract operation rounds down\n    byteView[i] = Math.random() * 256;\n  }\n  return values;\n}\n\nclass QuotaExceededError extends Error {\n  name = 'QuotaExceededError';\n  code = 22; // QUOTA_EXCEEDED_ERR\n}\n"]}